
--
-- RoboChart generator version 3.0.0.qualifier
-- Automatically generated on 06-01-2026 10:12:27
--
-- Iterated compression status: true
-- Assertions compression status: false
--

module Adaptation_Plan_Adaptation_Plan
exports
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase

	-- Transition identifiers
	-- declaring identifiers of transitions
	datatype NIDS = 
	              NID_i0|
	              NID_Initialise|
	              NID_WaitForSignal|
	              NID_MakePlan|
	              NID_PlanMade|
	              NID_WaitForVerification|
	              NID_Replan
	
	channel internal__ : NIDS
	
	-- Flow channels		
	channel interrupt
	channel exited
	channel exit
	channel terminate
	
	-- Variable channels
	channel get_modelScore, set_modelScore, setL_modelScore, setR_modelScore: LSeq(core_nat,2)
	channel get_modelRanking, set_modelRanking, setL_modelRanking, setR_modelRanking: LSeq(core_nat,2)
	channel get_model, set_model, setL_model, setR_model: core_nat
	channel get_image, set_image, setL_image, setR_image: core_nat
	channel get_pos, set_pos, setL_pos, setR_pos: core_nat
	channel get_imagesWithLight_var, set_imagesWithLight_var, setL_imagesWithLight_var, setR_imagesWithLight_var: LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
	channel get_imagesWithPoorLight_var, set_imagesWithPoorLight_var, setL_imagesWithPoorLight_var, setR_imagesWithPoorLight_var: LSeq(core_nat,2)
	
	-- Shared variable channels
	
	-- Local variable channels for defined operations that are required by the state machine
	
	-- Declaring state machine events
	channel planningCompleted__: NIDS.InOut
	channel planningCompleted: InOut
	channel planRejected__: NIDS.InOut
	channel planRejected: InOut
	channel requestPlan__: NIDS.InOut
	channel requestPlan: InOut
	channel newModel__: NIDS.InOut.core_nat
	channel newModel: InOut.core_nat
	channel get_newModel__: NIDS.InOut
	channel get_newModel: InOut
	channel set_newModel__: NIDS.InOut.core_nat
	channel set_newModel: InOut.core_nat
	channel imagesWithLight__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
	channel imagesWithLight: InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
	channel get_imagesWithLight__: NIDS.InOut
	channel get_imagesWithLight: InOut
	channel newConfidences__: NIDS.InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
	channel newConfidences: InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
	channel get_newConfidences__: NIDS.InOut
	channel get_newConfidences: InOut
	channel imagesWithPoorLight__: NIDS.InOut.LSeq(core_nat,2)
	channel imagesWithPoorLight: InOut.LSeq(core_nat,2)
	channel get_imagesWithPoorLight__: NIDS.InOut
	channel get_imagesWithPoorLight: InOut
	
	-- Declaring call and ret events for undefined operations
	
	enterSS = {|
	i0::enter,
	Initialise::enter,
	WaitForSignal::enter,
	MakePlan::enter,
	PlanMade::enter,
	WaitForVerification::enter,
	Replan::enter
	|}
	
	enteredSS = 	{|
	Initialise::entered,
	WaitForSignal::entered,
	MakePlan::entered,
	PlanMade::entered,
	WaitForVerification::entered,
	Replan::entered
	|}
	
	internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
	
	shared_variable_events = {|
	|}
	
	-- channel set with all visible events
	sem__events = {|
		terminate
	,	planningCompleted,
		planRejected,
		requestPlan,
		newModel,
		get_newModel,
		set_newModel,
		imagesWithLight,
		get_imagesWithLight,
		newConfidences,
		get_newConfidences,
		imagesWithPoorLight,
		get_imagesWithPoorLight
		|}
	
	channel clockReset, clockResetL, clockResetR 
	
	localClockResets = {||}
	
	
	channel get_CLID_PlanMade : core_clock_type 
	channel get_CLID_Replan : core_clock_type 
	channel get_CLID_MakePlan : core_clock_type 
	channel get_CLID_WaitForSignal : core_clock_type 
	channel get_CLID_Initialise : core_clock_type 
	channel get_CLID_WaitForVerification : core_clock_type 
	--channel increment__
	
	CLID_PlanMade_clock_type(id__,
			          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
			          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
			          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
		let
			max = (clock_type_max(Union({
	{}
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	CLID_Replan_clock_type(id__,
			          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
			          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
			          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
		let
			max = (clock_type_max(Union({
	{}
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	CLID_MakePlan_clock_type(id__,
			          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
			          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
			          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
		let
			max = (clock_type_max(Union({
	{}
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	CLID_WaitForSignal_clock_type(id__,
			          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
			          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
			          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
		let
			max = (clock_type_max(Union({
	{}
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	CLID_Initialise_clock_type(id__,
			          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
			          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
			          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
		let
			max = (clock_type_max(Union({
	{}
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	CLID_WaitForVerification_clock_type(id__,
			          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
			          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
			          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
		let
			max = (clock_type_max(Union({
	{}
	}))+1)
		ctype = {0..max}
	within
		if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
	
	

		-- Nodes --
		-- declaring all nodes
		
		----------------------------------------------------------------------
		-- Initial: i0
		module i0
		exports
		
			channel enter, interrupt
			
			Timed(OneStep) {
				D__(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= share__choice(interrupt -> SKIP) ; Inactive
					within
						Inactive [| {terminate} |> SKIP)
				
				VS_O__(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = D__(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: Initialise
		module Initialise
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--channel increment__
			
			
			--	Nodes
			-- declaring all nodes
			
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
				
				-- Clocks
				
				StateClocks(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
				
				stateClockSync = {||}
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: WaitForSignal
		module WaitForSignal
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--channel increment__
			
			
			--	Nodes
			-- declaring all nodes
			
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
				
				-- Clocks
				
				StateClocks(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
				
				stateClockSync = {||}
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: MakePlan
		module MakePlan
		
		enterSS = 
				{|			i0::enter,
					CheckModel::enter,
					CheckImage::enter,
					RankModel::enter,
					f0::enter
				|}
		enteredSS = 
				{|			CheckModel::entered,
					CheckImage::entered,
					RankModel::entered,
					f0::entered
				|}
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			-- declaring identifiers of transitions
			datatype NIDS = 
			              NID_i0|
			              NID_CheckModel|
			              NID_CheckImage|
			              NID_RankModel|
			              NID_f0
			
			channel internal__ : NIDS
			channel planningCompleted__: NIDS.InOut
			channel planRejected__: NIDS.InOut
			channel requestPlan__: NIDS.InOut
			channel newModel__: NIDS.InOut.core_nat
			channel get_newModel__: NIDS.InOut
			channel set_newModel__: NIDS.InOut.core_nat
			channel imagesWithLight__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
			channel get_imagesWithLight__: NIDS.InOut
			channel newConfidences__: NIDS.InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
			channel get_newConfidences__: NIDS.InOut
			channel imagesWithPoorLight__: NIDS.InOut.LSeq(core_nat,2)
			channel get_imagesWithPoorLight__: NIDS.InOut
			
			channel get_CLID_CheckModel : core_clock_type 
			channel get_CLID_CheckImage : core_clock_type 
			channel get_CLID_RankModel : core_clock_type 
			--channel increment__
			
			CLID_CheckModel_clock_type(id__,
					          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
					          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
					          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_CheckImage_clock_type(id__,
					          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
					          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
					          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			CLID_RankModel_clock_type(id__,
					          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
					          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
					          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
				let
					max = (clock_type_max(Union({
			{}
			}))+1)
				ctype = {0..max}
			within
				if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
			
			
			--	Nodes
			-- declaring all nodes
			
			----------------------------------------------------------------------
			-- Initial: i0
			module i0
			exports
			
				channel enter, interrupt
				
				Timed(OneStep) {
					D__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
							
							Termination = terminate -> SKIP
							
							Active 		= share__choice(interrupt -> SKIP) ; Inactive
						within
							Inactive [| {terminate} |> SKIP)
					
					VS_O__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = D__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: CheckModel
			module CheckModel
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--channel increment__
				
				
				--	Nodes
				-- declaring all nodes
				
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
					
					-- Clocks
					
					StateClocks(id__,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
					
					stateClockSync = {||}
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: CheckImage
			module CheckImage
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--channel increment__
				
				
				--	Nodes
				-- declaring all nodes
				
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
					
					-- Clocks
					
					StateClocks(id__,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
					
					stateClockSync = {||}
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- State: RankModel
			module RankModel
			
			enterSS = {}
			
			enteredSS = {}
			
			exports
			
				--  Declarations
				
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
								
				
				--channel increment__
				
				
				--	Nodes
				-- declaring all nodes
				
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					--  Note that FDR has problems with efficiently compiling the process below
					-- 	if using a different recursion pattern.
					D__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					dbisim(let
						-- IMPLEMENTATION NOTE: 
						-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
						-- however FDR struggles with that form in certain cases. So we use the exception operator
						-- instead to 'terminate'.
						
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					dbisim(let
						Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
						
						Termination = terminate -> SKIP
						
						Active 		= SKIP ; 
								 	  Behaviour ; 
								 	  share__choice(exit -> SKIP) ; SKIP ; 
								 	  share__choice(exited -> SKIP) ; Inactive
					
						Behaviour 	= entered -> During
						During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
					within
						Inactive [| {terminate} |> SKIP)
					
					
					-- Clocks
					
					StateClocks(id__,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
					
					stateClockSync = {||}
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			----------------------------------------------------------------------
			-- Final state: f0
			module f0
			
			exports
			
				channel enter, entered, interrupt
				channel enteredL, enteredR
				
				Timed(OneStep) {
					--	Rule: behaviours(Node)
					D__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						dbisim(let
							Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
							
							Entering 	= entered -> SKIP ; Active
							Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
							Interrupted	= share__choice(exit -> exited -> Inactive)
						within
							Inactive [| {terminate} |> SKIP)
						
					VS_O__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = D__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				}
			
			endmodule
			----------------------------------------------------------------------
			
			
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
				
					Behaviour 	= dbisim(
						((
						 (((dbisim(
						 	sbisim(
						 		dbisim(
						 			sbisim(
						 				dbisim(
						 					sbisim(
						 						(let
						 							-- IMPLEMENTATION NOTE:
						 							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						 							-- modules for defining the semantics of each node.
						 							enterSS = {|
						 							i0::enter,
						 							CheckModel::enter,
						 							CheckImage::enter,
						 							RankModel::enter,
						 							f0::enter
						 							|}
						 							hideSet = union(enterSS,{|exit,exited,internal__|})
						 						within 
						 							((let
						 								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						 								-- because CSPM modules are used for the semantics of Node.
						 								flowevts = union(enterSS,{|exit,exited,interrupt|})
						 								transSync = {|internal__.NID_i0,internal__.NID_CheckModel,internal__.NID_CheckImage,internal__.NID_CheckImage,internal__.NID_RankModel,internal__.NID_RankModel,internal__.NID_CheckModel|}
						 							within
						 								((
						 								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						 								   i0::D__(id__,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						 								   [| { share__, terminate } |] (
						 								   CheckModel::D__(id__,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						 								   [| { share__, terminate } |] (
						 								   CheckImage::D__(id__,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						 								   [| { share__, terminate } |] (
						 								   RankModel::D__(id__,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						 								   [| { share__, terminate } |] (
						 								   f0::D__(id__,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						 								   )
						 								   )
						 								   )
						 								   )
						 								 )
						 								 [[CheckModel::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CheckModel,internal__.NID_CheckModel|}]]
						 								 [[CheckImage::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CheckImage,internal__.NID_CheckImage|}]]
						 								 [[RankModel::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_RankModel,internal__.NID_RankModel|}]]
						 								 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
						 								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
						 								 )
						 								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 								  [[set_image <- setL_image,set_pos <- setL_pos,set_model <- setL_model,set_imagesWithPoorLight_var <- setL_imagesWithPoorLight_var,set_modelRanking <- setL_modelRanking,set_modelScore <- setL_modelScore]]
						 								 )
						 								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 								 			,setL_image
						 								 			,setL_pos
						 								 			,setL_model
						 								 			,setL_imagesWithPoorLight_var
						 								 			,setL_modelRanking
						 								 			,setL_modelScore
						 								|}) |]
						 								 ((i0::enter -> Transitions(id__,
						 								 		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 								 		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 								 		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
						 								  [[ share__ <- x__ | x__ <- {| share__,setL_image,setL_pos,setL_model,setL_imagesWithPoorLight_var,setL_modelRanking,setL_modelScore |} ]]
						 								 )
						 								)[[setL_image <- set_image,setL_pos <- set_pos,setL_model <- set_model,setL_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setL_modelRanking <- set_modelRanking,setL_modelScore <- set_modelScore]]
						 								)
						 							)
						 							 \ hideSet)
						 							[[
						 								planningCompleted__.x____ <- planningCompleted,
						 								planRejected__.x____ <- planRejected,
						 								requestPlan__.x____ <- requestPlan,
						 								newModel__.x____ <- newModel,
						 								get_newModel__.x____ <- get_newModel,
						 								set_newModel__.x____ <- set_newModel,
						 								imagesWithLight__.x____ <- imagesWithLight,
						 								get_imagesWithLight__.x____ <- get_imagesWithLight,
						 								newConfidences__.x____ <- newConfidences,
						 								get_newConfidences__.x____ <- get_newConfidences,
						 								imagesWithPoorLight__.x____ <- imagesWithPoorLight,
						 								get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight
						 								| x____ <- NIDS
						 							]]
						 						)
						 						[| {|get_CLID_RankModel,RankModel::entered,terminate|} |]
						 						dbisim(Clock_CLID_RankModel(id__,0,
						 								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
						 					)\{|get_CLID_RankModel|}
						 				)
						 				[| {|get_CLID_CheckImage,CheckImage::entered,terminate|} |]
						 				dbisim(Clock_CLID_CheckImage(id__,0,
						 						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
						 			)\{|get_CLID_CheckImage|}
						 		)
						 		[| {|get_CLID_CheckModel,CheckModel::entered,terminate|} |]
						 		dbisim(Clock_CLID_CheckModel(id__,0,
						 				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
						 	)\{|get_CLID_CheckModel|}
						 )
						 ))
						  [[ share__ <- x__ | x__ <- {| share__,setR_image,setR_pos,setR_imagesWithLight_var,setR_model,setR_modelRanking,setR_imagesWithPoorLight_var,setR_modelScore |} ]] 
						  [[set_image <- setL_image,set_pos <- setL_pos,set_imagesWithLight_var <- setL_imagesWithLight_var,set_model <- setL_model,set_modelRanking <- setL_modelRanking,set_imagesWithPoorLight_var <- setL_imagesWithPoorLight_var,set_modelScore <- setL_modelScore]]
						 )
						 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
						 			,setL_image
						 			,setL_pos
						 			,setL_imagesWithLight_var
						 			,setL_model
						 			,setL_modelRanking
						 			,setL_imagesWithPoorLight_var
						 			,setL_modelScore
						 			,setR_image
						 			 			,setR_pos
						 			 			,setR_imagesWithLight_var
						 			 			,setR_model
						 			 			,setR_modelRanking
						 			 			,setR_imagesWithPoorLight_var
						 			 			,setR_modelScore
						 			|}) |]
						 ((During)
						  [[ share__ <- x__ | x__ <- {| share__,setL_image,setL_pos,setL_imagesWithLight_var,setL_model,setL_modelRanking,setL_imagesWithPoorLight_var,setL_modelScore |} ]]
						  [[set_image <- setR_image,set_pos <- setR_pos,set_imagesWithLight_var <- setR_imagesWithLight_var,set_model <- setR_model,set_modelRanking <- setR_modelRanking,set_imagesWithPoorLight_var <- setR_imagesWithPoorLight_var,set_modelScore <- setR_modelScore]]
						 )
						)[[setL_image <- set_image,setL_pos <- set_pos,setL_imagesWithLight_var <- set_imagesWithLight_var,setL_model <- set_model,setL_modelRanking <- set_modelRanking,setL_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setL_modelScore <- set_modelScore]]
						 [[setR_image <- set_image,setR_pos <- set_pos,setR_imagesWithLight_var <- set_imagesWithLight_var,setR_model <- set_model,setR_modelRanking <- set_modelRanking,setR_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setR_modelScore <- set_modelScore]]
						)\union(enteredSS,{terminate}) 
					)
					During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
							 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
				
					Behaviour 	= dbisim(
						((
						 (((dbisim(
						 	sbisim(
						 		dbisim(
						 			sbisim(
						 				dbisim(
						 					sbisim(
						 						(let
						 							-- IMPLEMENTATION NOTE:
						 							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
						 							-- modules for defining the semantics of each node.
						 							enterSS = {|
						 							i0::enter,
						 							CheckModel::enter,
						 							CheckImage::enter,
						 							RankModel::enter,
						 							f0::enter
						 							|}
						 							hideSet = union(enterSS,{|exit,exited,internal__|})
						 						within 
						 							((let
						 								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						 								-- because CSPM modules are used for the semantics of Node.
						 								flowevts = union(enterSS,{|exit,exited,interrupt|})
						 								transSync = {|internal__.NID_i0,internal__.NID_CheckModel,internal__.NID_CheckImage,internal__.NID_CheckImage,internal__.NID_RankModel,internal__.NID_RankModel,internal__.NID_CheckModel|}
						 							within
						 								((
						 								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						 								   i0::VS_O__(id__,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						 								   [| { share__, terminate } |] (
						 								   CheckModel::VS_O__(id__,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						 								   [| { share__, terminate } |] (
						 								   CheckImage::VS_O__(id__,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						 								   [| { share__, terminate } |] (
						 								   RankModel::VS_O__(id__,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						 								   [| { share__, terminate } |] (
						 								   f0::VS_O__(id__,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						 								   )
						 								   )
						 								   )
						 								   )
						 								 )
						 								 [[CheckModel::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CheckModel,internal__.NID_CheckModel|}]]
						 								 [[CheckImage::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CheckImage,internal__.NID_CheckImage|}]]
						 								 [[RankModel::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_RankModel,internal__.NID_RankModel|}]]
						 								 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
						 								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
						 								 )
						 								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 								  [[set_image <- setL_image,set_pos <- setL_pos,set_model <- setL_model,set_imagesWithPoorLight_var <- setL_imagesWithPoorLight_var,set_modelRanking <- setL_modelRanking,set_modelScore <- setL_modelScore]]
						 								 )
						 								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						 								 			,setL_image
						 								 			,setL_pos
						 								 			,setL_model
						 								 			,setL_imagesWithPoorLight_var
						 								 			,setL_modelRanking
						 								 			,setL_modelScore
						 								|}) |]
						 								 ((i0::enter -> Transitions(id__,
						 								 		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 								 		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 								 		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
						 								  [[ share__ <- x__ | x__ <- {| share__,setL_image,setL_pos,setL_model,setL_imagesWithPoorLight_var,setL_modelRanking,setL_modelScore |} ]]
						 								 )
						 								)[[setL_image <- set_image,setL_pos <- set_pos,setL_model <- set_model,setL_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setL_modelRanking <- set_modelRanking,setL_modelScore <- set_modelScore]]
						 								)
						 							)
						 							 \ hideSet)
						 							[[
						 								planningCompleted__.x____ <- planningCompleted,
						 								planRejected__.x____ <- planRejected,
						 								requestPlan__.x____ <- requestPlan,
						 								newModel__.x____ <- newModel,
						 								get_newModel__.x____ <- get_newModel,
						 								set_newModel__.x____ <- set_newModel,
						 								imagesWithLight__.x____ <- imagesWithLight,
						 								get_imagesWithLight__.x____ <- get_imagesWithLight,
						 								newConfidences__.x____ <- newConfidences,
						 								get_newConfidences__.x____ <- get_newConfidences,
						 								imagesWithPoorLight__.x____ <- imagesWithPoorLight,
						 								get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight
						 								| x____ <- NIDS
						 							]]
						 						)
						 						[| {|get_CLID_RankModel,RankModel::entered,terminate|} |]
						 						dbisim(Clock_CLID_RankModel(id__,0,
						 								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
						 					)\{|get_CLID_RankModel|}
						 				)
						 				[| {|get_CLID_CheckImage,CheckImage::entered,terminate|} |]
						 				dbisim(Clock_CLID_CheckImage(id__,0,
						 						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
						 			)\{|get_CLID_CheckImage|}
						 		)
						 		[| {|get_CLID_CheckModel,CheckModel::entered,terminate|} |]
						 		dbisim(Clock_CLID_CheckModel(id__,0,
						 				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
						 	)\{|get_CLID_CheckModel|}
						 )
						 ))
						  [[ share__ <- x__ | x__ <- {| share__,setR_image,setR_pos,setR_imagesWithLight_var,setR_model,setR_modelRanking,setR_imagesWithPoorLight_var,setR_modelScore |} ]] 
						  [[set_image <- setL_image,set_pos <- setL_pos,set_imagesWithLight_var <- setL_imagesWithLight_var,set_model <- setL_model,set_modelRanking <- setL_modelRanking,set_imagesWithPoorLight_var <- setL_imagesWithPoorLight_var,set_modelScore <- setL_modelScore]]
						 )
						 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
						 			,setL_image
						 			,setL_pos
						 			,setL_imagesWithLight_var
						 			,setL_model
						 			,setL_modelRanking
						 			,setL_imagesWithPoorLight_var
						 			,setL_modelScore
						 			,setR_image
						 			 			,setR_pos
						 			 			,setR_imagesWithLight_var
						 			 			,setR_model
						 			 			,setR_modelRanking
						 			 			,setR_imagesWithPoorLight_var
						 			 			,setR_modelScore
						 			|}) |]
						 ((During)
						  [[ share__ <- x__ | x__ <- {| share__,setL_image,setL_pos,setL_imagesWithLight_var,setL_model,setL_modelRanking,setL_imagesWithPoorLight_var,setL_modelScore |} ]]
						  [[set_image <- setR_image,set_pos <- setR_pos,set_imagesWithLight_var <- setR_imagesWithLight_var,set_model <- setR_model,set_modelRanking <- setR_modelRanking,set_imagesWithPoorLight_var <- setR_imagesWithPoorLight_var,set_modelScore <- setR_modelScore]]
						 )
						)[[setL_image <- set_image,setL_pos <- set_pos,setL_imagesWithLight_var <- set_imagesWithLight_var,setL_model <- set_model,setL_modelRanking <- set_modelRanking,setL_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setL_modelScore <- set_modelScore]]
						 [[setR_image <- set_image,setR_pos <- set_pos,setR_imagesWithLight_var <- set_imagesWithLight_var,setR_model <- set_model,setR_modelRanking <- set_modelRanking,setR_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setR_modelScore <- set_modelScore]]
						)\{terminate} 
					)
					During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
							 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
				within
					Inactive [| {terminate} |> SKIP)
				
				Transitions(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = ((let
					Trans = share__choice(get_image?image -> get_pos?pos -> get_model?model -> get_imagesWithPoorLight_var?imagesWithPoorLight_var -> get_modelRanking?modelRanking -> get_modelScore?modelScore -> TimeOut_1(
						 (share__ -> SKIP
						 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((true&(share__choice(get_imagesWithLight.out -> SKIP));true&(share__choice(imagesWithLight.in?imagesWithLight_var -> (SStop /\ set_imagesWithLight_var!imagesWithLight_var -> SKIP)));true&(share__choice(get_imagesWithPoorLight.out -> SKIP));true&(share__choice(imagesWithPoorLight.in?imagesWithPoorLight_var -> (SStop /\ set_imagesWithPoorLight_var!imagesWithPoorLight_var -> SKIP)));share__choice(true & (share__choice(set_model!1 -> SKIP))) ; CheckModel::enter -> SKIP))))
						 [] dbisim(((model<=const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS))&(internal__!NID_CheckModel -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_image!1 -> SKIP)));share__choice(share__choice(get_modelScore?modelScore -> true & (share__choice(set_modelScore!(modelScore ^ <0>) -> SKIP)))) ; CheckImage::enter -> SKIP)))
						 [] dbisim(((image<=length(imagesWithPoorLight_var)))&(internal__!NID_CheckImage -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_image?image -> share__choice(get_imagesWithLight_var?imagesWithLight_var -> share__choice(get_model?model -> share__choice(get_imagesWithPoorLight_var?imagesWithPoorLight_var -> share__choice(get_modelScore?modelScore -> (model <= length(modelScore))&(model >= 1) & (share__choice(set_modelScore!update_(modelScore,Plus(access_(modelScore, model), ((let
						 			light = tuple3_2((access_(imagesWithLight_var, access_(imagesWithPoorLight_var, image))))
						 			within
						 				(if ((light<tuple2_1(((callFunc((IDEAL_LIGHTING), (model)))))) or (light>tuple2_2(((callFunc((IDEAL_LIGHTING), (model))))))) then 0 else 1)
						 			)), core_nat),model) -> SKIP)))))))) ; CheckImage::enter -> SKIP)))
						 [] dbisim(((image>length(imagesWithPoorLight_var)))&(internal__!NID_CheckImage -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_model?model -> share__choice(get_modelRanking?modelRanking -> true & (share__choice(set_modelRanking!(<model> ^ modelRanking) -> SKIP)))));share__choice(true & (share__choice(set_pos!1 -> SKIP))) ; RankModel::enter -> SKIP)))
						 [] dbisim((((pos<length(modelRanking)) and (access_(modelScore, model)<=access_(modelScore, access_(modelRanking, Plus(pos, 1, core_nat))))))&(internal__!NID_RankModel -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_pos?pos -> share__choice(get_modelRanking?modelRanking -> (pos <= length(modelRanking))&(pos >= 1)&Plus(pos, 1, core_nat) <= length(modelRanking)&Plus(pos, 1, core_nat) >= 1 & (share__choice(set_modelRanking!update_(modelRanking,access_(modelRanking, Plus(pos, 1, core_nat)),pos) -> SKIP)))));share__choice(share__choice(get_pos?pos -> share__choice(get_model?model -> share__choice(get_modelRanking?modelRanking -> (Plus(pos, 1, core_nat) <= length(modelRanking))&(Plus(pos, 1, core_nat) >= 1) & (share__choice(set_modelRanking!update_(modelRanking,model,Plus(pos, 1, core_nat)) -> SKIP))))));share__choice(share__choice(get_pos?pos -> true & (share__choice(set_pos!Plus(pos, 1, core_nat) -> SKIP)))) ; RankModel::enter -> SKIP)))
						 [] dbisim((((pos>=length(modelRanking)) or (access_(modelScore, model)>access_(modelScore, access_(modelRanking, Plus(pos, 1, core_nat))))))&(internal__!NID_RankModel -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_model?model -> true & (share__choice(set_model!Plus(model, 1, core_nat) -> SKIP)))) ; CheckModel::enter -> SKIP)))
						 [] dbisim(((model>const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS))&(internal__!NID_CheckModel -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; f0::enter -> SKIP)))
						 []
						 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
						 []
						 terminate -> SKIP
						 )
					,SKIP);Trans
					)
				within
					Trans [|{terminate}|> SKIP
				)
				)
				
				
				-- Clocks
				Clock_CLID_CheckModel(id__,x__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					TimeOut_1(
						CheckModel::entered -> Clock_CLID_CheckModel(id__,0,
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						[]
						get_CLID_CheckModel!x__ -> Clock_CLID_CheckModel(id__,x__,
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						[]
						terminate -> SKIP,Clock_CLID_CheckModel(id__,clock_type_plus(x__,1,CLID_CheckModel_clock_type(id__,
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
				Clock_CLID_CheckImage(id__,x__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					TimeOut_1(
						CheckImage::entered -> Clock_CLID_CheckImage(id__,0,
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						[]
						get_CLID_CheckImage!x__ -> Clock_CLID_CheckImage(id__,x__,
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						[]
						terminate -> SKIP,Clock_CLID_CheckImage(id__,clock_type_plus(x__,1,CLID_CheckImage_clock_type(id__,
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
				Clock_CLID_RankModel(id__,x__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					TimeOut_1(
						RankModel::entered -> Clock_CLID_RankModel(id__,0,
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						[]
						get_CLID_RankModel!x__ -> Clock_CLID_RankModel(id__,x__,
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						[]
						terminate -> SKIP,Clock_CLID_RankModel(id__,clock_type_plus(x__,1,CLID_RankModel_clock_type(id__,
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
				
				StateClocks(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = dbisim(Clock_CLID_CheckModel(id__,0,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
				[| { terminate } |] (
				dbisim(Clock_CLID_CheckImage(id__,0,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
				[| { terminate } |] (
				dbisim(Clock_CLID_RankModel(id__,0,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
				)
				)
				
				stateClockSync = {|get_CLID_CheckModel,CheckModel::entered,get_CLID_CheckImage,CheckImage::entered,get_CLID_RankModel,RankModel::entered|}
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: PlanMade
		module PlanMade
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--channel increment__
			
			
			--	Nodes
			-- declaring all nodes
			
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(get_modelRanking?modelRanking -> pre_sequence_toolkit_head(modelRanking)&(share__choice(set_newModel.out!sequence_toolkit_head(modelRanking) -> SKIP))) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(get_modelRanking?modelRanking -> pre_sequence_toolkit_head(modelRanking)&(share__choice(set_newModel.out!sequence_toolkit_head(modelRanking) -> SKIP))) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
				
				-- Clocks
				
				StateClocks(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
				
				stateClockSync = {||}
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: WaitForVerification
		module WaitForVerification
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--channel increment__
			
			
			--	Nodes
			-- declaring all nodes
			
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= SKIP ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
				
				-- Clocks
				
				StateClocks(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
				
				stateClockSync = {||}
			}
		
		endmodule
		----------------------------------------------------------------------
		
		
		----------------------------------------------------------------------
		-- State: Replan
		module Replan
		
		enterSS = {}
		
		enteredSS = {}
		
		exports
		
			--  Declarations
			
			channel enter, entered, interrupt
			channel enteredL, enteredR
			
							
			
			--channel increment__
			
			
			--	Nodes
			-- declaring all nodes
			
			
			Timed(OneStep) {
				--	Rule: behaviours(Node)
				--  Note that FDR has problems with efficiently compiling the process below
				-- 	if using a different recursion pattern.
				D__(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
				dbisim(let
					-- IMPLEMENTATION NOTE: 
					-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
					-- however FDR struggles with that form in certain cases. So we use the exception operator
					-- instead to 'terminate'.
					
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(get_modelRanking?modelRanking -> true&(if (length(modelRanking)>0) then (share__choice(share__choice(get_modelRanking?modelRanking -> true & (share__choice(set_modelRanking!sequence_toolkit_tail(modelRanking) -> SKIP))))) else (share__choice(true & (share__choice(set_modelRanking!<const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL> -> SKIP)))))) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
					
				VS_O__(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
				dbisim(let
					Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
					
					Termination = terminate -> SKIP
					
					Active 		= share__choice(get_modelRanking?modelRanking -> true&(if (length(modelRanking)>0) then (share__choice(share__choice(get_modelRanking?modelRanking -> true & (share__choice(set_modelRanking!sequence_toolkit_tail(modelRanking) -> SKIP))))) else (share__choice(true & (share__choice(set_modelRanking!<const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL> -> SKIP)))))) ; 
							 	  Behaviour ; 
							 	  share__choice(exit -> SKIP) ; SKIP ; 
							 	  share__choice(exited -> SKIP) ; Inactive
				
					Behaviour 	= entered -> During
					During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
				within
					Inactive [| {terminate} |> SKIP)
				
				
				-- Clocks
				
				StateClocks(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
				
				stateClockSync = {||}
			}
		
		endmodule
		----------------------------------------------------------------------
		
		-- END of Nodes --
		
		Timed(OneStep) {
		-- Operation calls --
		-- Only the undefined operations are declared here.
		-- If the state machine is in isolation, all required operations will be undefined.
		-- If it is in the context of a controller, the required operations not provided by the
		-- controller will be declared here, and the defined operations will be defined in the
		-- context of the Controller module, and therefore within scope of the state machine module.
		
		-- END of Operation calls --
	
		-- STM processes
		STM(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
		( 
			(
				(
					(IteratedStateful(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) \ {terminate} ; share__choice(terminate -> SKIP))
				 	[[ share__ <- x__ | x__ <- {||} ]]
				)
			[| {share__} |]
			SKIP
			)
			[| union(sharedVarSync,{terminate}) |]
			dbisim(sharedVarMemory(id__,
					    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
					    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
					    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		)\sharedVarHide
		
		STM_VS_O(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
		( 
			(
				(
					(IteratedStateful_VS_O(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) \ {terminate} ; share__choice(terminate -> SKIP))
				 	[[ share__ <- x__ | x__ <- {||} ]]
				)
			[| {share__} |]
			SKIP
			)
			[| union(sharedVarSync,{terminate}) |]
			dbisim(sharedVarMemory(id__,
					    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
					    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
					    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		)\sharedVarHide
		
		-- Transitions
		Transitions(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = ((let
			Trans = TimeOut_1(
				 (share__ -> SKIP
				 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; Initialise::enter -> SKIP))))
				 [] dbisim((true)&(internal__!NID_Initialise -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForSignal::enter -> SKIP)))
				 [] dbisim((true)&(requestPlan__!NID_WaitForSignal.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; MakePlan::enter -> SKIP)))
				 [] dbisim((true)&(internal__!NID_MakePlan -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; PlanMade::enter -> SKIP)))
				 [] dbisim((true)&(internal__!NID_PlanMade -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(planningCompleted.out -> SKIP)) ; WaitForVerification::enter -> SKIP)))
				 [] dbisim((true)&(requestPlan__!NID_WaitForVerification.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; MakePlan::enter -> SKIP)))
				 [] dbisim((true)&(planRejected__!NID_WaitForVerification.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Replan::enter -> SKIP)))
				 [] dbisim((true)&(internal__!NID_Replan -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; PlanMade::enter -> SKIP)))
				 []
				 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
				 []
				 terminate -> SKIP
				 )
			,SKIP);Trans
		within
			Trans [|{terminate}|> SKIP
		)
		)
		
		-- Stateful
		-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
		
		-- Named process definitions
		MachineBody(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
			dbisim((
			let
				finalNodesEntered = {||}
			within
				(dbisim((dbisim((let
					-- IMPLEMENTATION NOTE:
					-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
					-- modules for defining the semantics of each node.
					enterSS = {|
					i0::enter,
					Initialise::enter,
					WaitForSignal::enter,
					MakePlan::enter,
					PlanMade::enter,
					WaitForVerification::enter,
					Replan::enter
					|}
					hideSet = union(enterSS,{|exit,exited,internal__|})
				within 
					((let
						-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						-- because CSPM modules are used for the semantics of Node.
						flowevts = union(enterSS,{|exit,exited,interrupt|})
						transSync = {|internal__.NID_i0,internal__.NID_Initialise,requestPlan__.NID_WaitForSignal.in,internal__.NID_MakePlan,internal__.NID_PlanMade,requestPlan__.NID_WaitForVerification.in,planRejected__.NID_WaitForVerification.in,internal__.NID_Replan|}
					within
						((
						 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						   i0::D__(id__,
						   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						   [| { share__, terminate } |] (
						   Initialise::D__(id__,
						   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						   [| { share__, terminate } |] (
						   WaitForSignal::D__(id__,
						   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						   [| { share__, terminate } |] (
						   MakePlan::D__(id__,
						   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						   [| { share__, terminate } |] (
						   PlanMade::D__(id__,
						   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						   [| { share__, terminate } |] (
						   WaitForVerification::D__(id__,
						   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						   [| { share__, terminate } |] (
						   Replan::D__(id__,
						   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						   )
						   )
						   )
						   )
						   )
						   )
						 )
						 [[Initialise::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialise|}]]
						 [[WaitForSignal::interrupt <- x__ | x__ <- {|interrupt,requestPlan__.NID_WaitForSignal.in|}]]
						 [[MakePlan::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_MakePlan|}]]
						 [[PlanMade::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_PlanMade|}]]
						 [[WaitForVerification::interrupt <- x__ | x__ <- {|interrupt,requestPlan__.NID_WaitForVerification.in,planRejected__.NID_WaitForVerification.in|}]]
						 [[Replan::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Replan|}]]
						 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
						 )
						  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 )
						 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						|}) |]
						 ((i0::enter -> Transitions(id__,
						 		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
						  [[ share__ <- x__ | x__ <- {| share__ |} ]]
						 )
						)
						)
					)
					 \ hideSet)
					[[
						planningCompleted__.x____ <- planningCompleted,
						planRejected__.x____ <- planRejected,
						requestPlan__.x____ <- requestPlan,
						newModel__.x____ <- newModel,
						get_newModel__.x____ <- get_newModel,
						set_newModel__.x____ <- set_newModel,
						imagesWithLight__.x____ <- imagesWithLight,
						get_imagesWithLight__.x____ <- get_imagesWithLight,
						newConfidences__.x____ <- newConfidences,
						get_newConfidences__.x____ <- get_newConfidences,
						imagesWithPoorLight__.x____ <- imagesWithPoorLight,
						get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight
						| x____ <- NIDS
					]]
				)
				)
				 [| union(stateClockSync,{terminate}) |]
				 StateClocks(id__,
				 		          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				 		          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				 		          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				)\diff(stateClockSync,enteredSS))
				 [| {| interrupt |} |] SKIP)
			)
			)
		
		Behaviour(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
			dbisim((let
				stateClockSync = {|get_CLID_PlanMade,PlanMade::entered,get_CLID_Replan,Replan::entered,get_CLID_MakePlan,MakePlan::entered,get_CLID_WaitForSignal,WaitForSignal::entered,get_CLID_Initialise,Initialise::entered,get_CLID_WaitForVerification,WaitForVerification::entered|}
			 within
				(MachineBody(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)) \ union(stateClockSync,enteredSS)
			)
			)
		
		IteratedBehaviour(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
			dbisim((let
				stateClockSync = {|get_CLID_PlanMade,PlanMade::entered,get_CLID_Replan,Replan::entered,get_CLID_MakePlan,MakePlan::entered,get_CLID_WaitForSignal,WaitForSignal::entered,get_CLID_Initialise,Initialise::entered,get_CLID_WaitForVerification,WaitForVerification::entered|}
			 within
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																MachineBody(id__,
																		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
																[| {|get_CLID_WaitForVerification,WaitForVerification::entered,terminate|} |]
																dbisim(Clock_CLID_WaitForVerification(id__,0,
																		          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																		          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																		          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
															)\{|get_CLID_WaitForVerification|}
														)
														[| {|get_CLID_Initialise,Initialise::entered,terminate|} |]
														dbisim(Clock_CLID_Initialise(id__,0,
																          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
													)\{|get_CLID_Initialise|}
												)
												[| {|get_CLID_WaitForSignal,WaitForSignal::entered,terminate|} |]
												dbisim(Clock_CLID_WaitForSignal(id__,0,
														          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
														          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
														          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
											)\{|get_CLID_WaitForSignal|}
										)
										[| {|get_CLID_MakePlan,MakePlan::entered,terminate|} |]
										dbisim(Clock_CLID_MakePlan(id__,0,
												          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
												          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
												          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
									)\{|get_CLID_MakePlan|}
								)
								[| {|get_CLID_Replan,Replan::entered,terminate|} |]
								dbisim(Clock_CLID_Replan(id__,0,
										          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
							)\{|get_CLID_Replan|}
						)
						[| {|get_CLID_PlanMade,PlanMade::entered,terminate|} |]
						dbisim(Clock_CLID_PlanMade(id__,0,
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					)\{|get_CLID_PlanMade|}
				)
				) \ union(stateClockSync,enteredSS)
			)
			)
		
		Stateful(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
			((let
				getsetLocalChannels = {|get_modelScore,set_modelScore,
				get_modelRanking,set_modelRanking,
				get_model,set_model,
				get_image,set_image,
				get_pos,set_pos,
				get_imagesWithLight_var,set_imagesWithLight_var,
				get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
				clockSync = {||}
			within
				(Behaviour(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) 
				 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
				 (varMemory(id__,
				 		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				 		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				 		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) [| {terminate} |] Clocks(id__,
				 		          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				 		          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				 		          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
			 	)\union(getsetLocalChannels,clockSync)
			)
			)
		
		IteratedStateful(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) =
			(dbisim(
				sbisim(
					dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	IteratedBehaviour(id__,
																			    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																			    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																			    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
																	[| {|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,terminate|} |]
																	Memory_imagesWithPoorLight_var(<>)
																)\{|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
															)
															[| {|get_imagesWithLight_var,set_imagesWithLight_var,terminate|} |]
															Memory_imagesWithLight_var(<>)
														)\{|get_imagesWithLight_var,set_imagesWithLight_var|}
													)
													[| {|get_pos,set_pos,terminate|} |]
													Memory_pos(0)
												)\{|get_pos,set_pos|}
											)
											[| {|get_image,set_image,terminate|} |]
											Memory_image(0)
										)\{|get_image,set_image|}
									)
									[| {|get_model,set_model,terminate|} |]
									Memory_model(0)
								)\{|get_model,set_model|}
							)
							[| {|get_modelRanking,set_modelRanking,terminate|} |]
							Memory_modelRanking(<>)
						)\{|get_modelRanking,set_modelRanking|}
					)
					[| {|get_modelScore,set_modelScore,terminate|} |]
					Memory_modelScore(<>)
				)\{|get_modelScore,set_modelScore|}
			)
			)
		
		-- Visible counterparts
		MachineBody_VS_O(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
			dbisim((
			let
				finalNodesEntered = {||}
			within
				(dbisim((dbisim((let
					-- IMPLEMENTATION NOTE:
					-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
					-- modules for defining the semantics of each node.
					enterSS = {|
					i0::enter,
					Initialise::enter,
					WaitForSignal::enter,
					MakePlan::enter,
					PlanMade::enter,
					WaitForVerification::enter,
					Replan::enter
					|}
					hideSet = union(enterSS,{|exit,exited,internal__|})
				within 
					((let
						-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
						-- because CSPM modules are used for the semantics of Node.
						flowevts = union(enterSS,{|exit,exited,interrupt|})
						transSync = {|internal__.NID_i0,internal__.NID_Initialise,requestPlan__.NID_WaitForSignal.in,internal__.NID_MakePlan,internal__.NID_PlanMade,requestPlan__.NID_WaitForVerification.in,planRejected__.NID_WaitForVerification.in,internal__.NID_Replan|}
					within
						((
						 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
						   i0::VS_O__(id__,
						   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						   [| { share__, terminate } |] (
						   Initialise::VS_O__(id__,
						   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						   [| { share__, terminate } |] (
						   WaitForSignal::VS_O__(id__,
						   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						   [| { share__, terminate } |] (
						   MakePlan::VS_O__(id__,
						   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						   [| { share__, terminate } |] (
						   PlanMade::VS_O__(id__,
						   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						   [| { share__, terminate } |] (
						   WaitForVerification::VS_O__(id__,
						   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						   [| { share__, terminate } |] (
						   Replan::VS_O__(id__,
						   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						   )
						   )
						   )
						   )
						   )
						   )
						 )
						 [[Initialise::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialise|}]]
						 [[WaitForSignal::interrupt <- x__ | x__ <- {|interrupt,requestPlan__.NID_WaitForSignal.in|}]]
						 [[MakePlan::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_MakePlan|}]]
						 [[PlanMade::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_PlanMade|}]]
						 [[WaitForVerification::interrupt <- x__ | x__ <- {|interrupt,requestPlan__.NID_WaitForVerification.in,planRejected__.NID_WaitForVerification.in|}]]
						 [[Replan::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Replan|}]]
						 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
						 )
						  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
						 )
						 [| union(union(union(flowevts,transSync),{terminate}),{|share__
						|}) |]
						 ((i0::enter -> Transitions(id__,
						 		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						 		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						 		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
						  [[ share__ <- x__ | x__ <- {| share__ |} ]]
						 )
						)
						)
					)
					 \ hideSet)
					[[
						planningCompleted__.x____ <- planningCompleted,
						planRejected__.x____ <- planRejected,
						requestPlan__.x____ <- requestPlan,
						newModel__.x____ <- newModel,
						get_newModel__.x____ <- get_newModel,
						set_newModel__.x____ <- set_newModel,
						imagesWithLight__.x____ <- imagesWithLight,
						get_imagesWithLight__.x____ <- get_imagesWithLight,
						newConfidences__.x____ <- newConfidences,
						get_newConfidences__.x____ <- get_newConfidences,
						imagesWithPoorLight__.x____ <- imagesWithPoorLight,
						get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight
						| x____ <- NIDS
					]]
				)
				)
				 [| union(stateClockSync,{terminate}) |]
				 StateClocks(id__,
				 		          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				 		          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				 		          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				)\diff(stateClockSync,enteredSS))
				 [| {| interrupt |} |] SKIP)
			)
			)
		
		Behaviour_VS_O(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
			dbisim((let
				stateClockSync = {|get_CLID_PlanMade,PlanMade::entered,get_CLID_Replan,Replan::entered,get_CLID_MakePlan,MakePlan::entered,get_CLID_WaitForSignal,WaitForSignal::entered,get_CLID_Initialise,Initialise::entered,get_CLID_WaitForVerification,WaitForVerification::entered|}
			 within
				(MachineBody_VS_O(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)) \ diff(union(stateClockSync,enteredSS),enteredSS)
			)
			)
		
		IteratedBehaviour_VS_O(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
			dbisim((let
				stateClockSync = {|get_CLID_PlanMade,PlanMade::entered,get_CLID_Replan,Replan::entered,get_CLID_MakePlan,MakePlan::entered,get_CLID_WaitForSignal,WaitForSignal::entered,get_CLID_Initialise,Initialise::entered,get_CLID_WaitForVerification,WaitForVerification::entered|}
			 within
				(dbisim(
					sbisim(
						dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																MachineBody_VS_O(id__,
																		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
																[| {|get_CLID_WaitForVerification,WaitForVerification::entered,terminate|} |]
																dbisim(Clock_CLID_WaitForVerification(id__,0,
																		          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																		          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																		          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
															)\{|get_CLID_WaitForVerification|}
														)
														[| {|get_CLID_Initialise,Initialise::entered,terminate|} |]
														dbisim(Clock_CLID_Initialise(id__,0,
																          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
													)\{|get_CLID_Initialise|}
												)
												[| {|get_CLID_WaitForSignal,WaitForSignal::entered,terminate|} |]
												dbisim(Clock_CLID_WaitForSignal(id__,0,
														          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
														          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
														          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
											)\{|get_CLID_WaitForSignal|}
										)
										[| {|get_CLID_MakePlan,MakePlan::entered,terminate|} |]
										dbisim(Clock_CLID_MakePlan(id__,0,
												          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
												          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
												          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
									)\{|get_CLID_MakePlan|}
								)
								[| {|get_CLID_Replan,Replan::entered,terminate|} |]
								dbisim(Clock_CLID_Replan(id__,0,
										          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
							)\{|get_CLID_Replan|}
						)
						[| {|get_CLID_PlanMade,PlanMade::entered,terminate|} |]
						dbisim(Clock_CLID_PlanMade(id__,0,
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					)\{|get_CLID_PlanMade|}
				)
				) \ diff(union(stateClockSync,enteredSS),enteredSS)
			)
			)
		
		Stateful_VS_O(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
			dbisim((let
				getsetLocalChannels = {|get_modelScore,set_modelScore,
				get_modelRanking,set_modelRanking,
				get_model,set_model,
				get_image,set_image,
				get_pos,set_pos,
				get_imagesWithLight_var,set_imagesWithLight_var,
				get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
				clockSync = {||}
			within
				(Behaviour_VS_O(id__,
						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) 
				 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
				 (varMemory(id__,
				 		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				 		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				 		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) [| {terminate} |] Clocks(id__,
				 		          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				 		          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				 		          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
			 	)\union(getsetLocalChannels,clockSync)
			)
			)
		
		IteratedStateful_VS_O(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) =
			(dbisim(
				sbisim(
					dbisim(
						sbisim(
							dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	IteratedBehaviour_VS_O(id__,
																			    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																			    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																			    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
																	[| {|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,terminate|} |]
																	Memory_imagesWithPoorLight_var(<>)
																)\{|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
															)
															[| {|get_imagesWithLight_var,set_imagesWithLight_var,terminate|} |]
															Memory_imagesWithLight_var(<>)
														)\{|get_imagesWithLight_var,set_imagesWithLight_var|}
													)
													[| {|get_pos,set_pos,terminate|} |]
													Memory_pos(0)
												)\{|get_pos,set_pos|}
											)
											[| {|get_image,set_image,terminate|} |]
											Memory_image(0)
										)\{|get_image,set_image|}
									)
									[| {|get_model,set_model,terminate|} |]
									Memory_model(0)
								)\{|get_model,set_model|}
							)
							[| {|get_modelRanking,set_modelRanking,terminate|} |]
							Memory_modelRanking(<>)
						)\{|get_modelRanking,set_modelRanking|}
					)
					[| {|get_modelScore,set_modelScore,terminate|} |]
					Memory_modelScore(<>)
				)\{|get_modelScore,set_modelScore|}
			)
			)
		
		-- END
		
		-- Memory
		-- Memory variables
		Memory_modelScore(modelScore) =
			get_modelScore!modelScore -> Memory_modelScore(modelScore)
			[]
			set_modelScore?x__ -> Memory_modelScore(x__)
			[]
			terminate -> SKIP
		Memory_modelRanking(modelRanking) =
			get_modelRanking!modelRanking -> Memory_modelRanking(modelRanking)
			[]
			set_modelRanking?x__ -> Memory_modelRanking(x__)
			[]
			terminate -> SKIP
		Memory_model(model) =
			get_model!model -> Memory_model(model)
			[]
			set_model?x__ -> Memory_model(x__)
			[]
			terminate -> SKIP
		Memory_image(image) =
			get_image!image -> Memory_image(image)
			[]
			set_image?x__ -> Memory_image(x__)
			[]
			terminate -> SKIP
		Memory_pos(pos) =
			get_pos!pos -> Memory_pos(pos)
			[]
			set_pos?x__ -> Memory_pos(x__)
			[]
			terminate -> SKIP
		Memory_imagesWithLight_var(imagesWithLight_var) =
			get_imagesWithLight_var!imagesWithLight_var -> Memory_imagesWithLight_var(imagesWithLight_var)
			[]
			set_imagesWithLight_var?x__ -> Memory_imagesWithLight_var(x__)
			[]
			terminate -> SKIP
		Memory_imagesWithPoorLight_var(imagesWithPoorLight_var) =
			get_imagesWithPoorLight_var!imagesWithPoorLight_var -> Memory_imagesWithPoorLight_var(imagesWithPoorLight_var)
			[]
			set_imagesWithPoorLight_var?x__ -> Memory_imagesWithPoorLight_var(x__)
			[]
			terminate -> SKIP
		
		-- varMemory process
		varMemory(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = Memory_modelScore(<>)
		[| { terminate } |] (
		Memory_modelRanking(<>)
		[| { terminate } |] (
		Memory_model(0)
		[| { terminate } |] (
		Memory_image(0)
		[| { terminate } |] (
		Memory_pos(0)
		[| { terminate } |] (
		Memory_imagesWithLight_var(<>)
		[| { terminate } |] (
		Memory_imagesWithPoorLight_var(<>)
		)
		)
		)
		)
		)
		)
		
		getsetLocalChannels = {|get_modelScore,set_modelScore,get_modelRanking,set_modelRanking,get_model,set_model,get_image,set_image,get_pos,set_pos,get_imagesWithLight_var,set_imagesWithLight_var,get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
		
		-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
		FVS__(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = STM_VS_O(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) \ localClockResets
		D__(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = timed_priority(STM(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) \ union(internal_events,localClockResets))
		O__(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = dbisim(D__(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		VS__(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = FVS__(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
		VS_O__(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = dbisim(FVS__(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		HEXT__(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = O__(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) [|shared_variable_events|] SKIP
		FVS_C__(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = dbisim(timed_priority(STM(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) \ internal_events))
		HUP__(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = timed_priority(O__(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) [|{share__}|] SKIP)
		
		-- Clocks
		
		Clocks(id__,
				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
		
		clockSync = {||}
		
		Clock_CLID_PlanMade(id__,x__,
				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
			TimeOut_1(
				PlanMade::entered -> Clock_CLID_PlanMade(id__,0,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				[]
				get_CLID_PlanMade!x__ -> Clock_CLID_PlanMade(id__,x__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				[]
				terminate -> SKIP,Clock_CLID_PlanMade(id__,clock_type_plus(x__,1,CLID_PlanMade_clock_type(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		Clock_CLID_Replan(id__,x__,
				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
			TimeOut_1(
				Replan::entered -> Clock_CLID_Replan(id__,0,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				[]
				get_CLID_Replan!x__ -> Clock_CLID_Replan(id__,x__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				[]
				terminate -> SKIP,Clock_CLID_Replan(id__,clock_type_plus(x__,1,CLID_Replan_clock_type(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		Clock_CLID_MakePlan(id__,x__,
				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
			TimeOut_1(
				MakePlan::entered -> Clock_CLID_MakePlan(id__,0,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				[]
				get_CLID_MakePlan!x__ -> Clock_CLID_MakePlan(id__,x__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				[]
				terminate -> SKIP,Clock_CLID_MakePlan(id__,clock_type_plus(x__,1,CLID_MakePlan_clock_type(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		Clock_CLID_WaitForSignal(id__,x__,
				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
			TimeOut_1(
				WaitForSignal::entered -> Clock_CLID_WaitForSignal(id__,0,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				[]
				get_CLID_WaitForSignal!x__ -> Clock_CLID_WaitForSignal(id__,x__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				[]
				terminate -> SKIP,Clock_CLID_WaitForSignal(id__,clock_type_plus(x__,1,CLID_WaitForSignal_clock_type(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		Clock_CLID_Initialise(id__,x__,
				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
			TimeOut_1(
				Initialise::entered -> Clock_CLID_Initialise(id__,0,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				[]
				get_CLID_Initialise!x__ -> Clock_CLID_Initialise(id__,x__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				[]
				terminate -> SKIP,Clock_CLID_Initialise(id__,clock_type_plus(x__,1,CLID_Initialise_clock_type(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		Clock_CLID_WaitForVerification(id__,x__,
				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
			TimeOut_1(
				WaitForVerification::entered -> Clock_CLID_WaitForVerification(id__,0,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				[]
				get_CLID_WaitForVerification!x__ -> Clock_CLID_WaitForVerification(id__,x__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
				[]
				terminate -> SKIP,Clock_CLID_WaitForVerification(id__,clock_type_plus(x__,1,CLID_WaitForVerification_clock_type(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		
		StateClocks(id__,
				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = dbisim(Clock_CLID_PlanMade(id__,0,
				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		[| { terminate } |] (
		dbisim(Clock_CLID_Replan(id__,0,
				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		[| { terminate } |] (
		dbisim(Clock_CLID_MakePlan(id__,0,
				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		[| { terminate } |] (
		dbisim(Clock_CLID_WaitForSignal(id__,0,
				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		[| { terminate } |] (
		dbisim(Clock_CLID_Initialise(id__,0,
				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		[| { terminate } |] (
		dbisim(Clock_CLID_WaitForVerification(id__,0,
				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
		)
		)
		)
		)
		)
		
		stateClockSync = {|get_CLID_PlanMade,PlanMade::entered,get_CLID_Replan,Replan::entered,get_CLID_MakePlan,MakePlan::entered,get_CLID_WaitForSignal,WaitForSignal::entered,get_CLID_Initialise,Initialise::entered,get_CLID_WaitForVerification,WaitForVerification::entered|}
		
		-- Shared memory
		-- Shared memory variables
		
		-- sharedVarMemory process
		sharedVarMemory(id__,
				    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
				    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
				    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
		
		sharedVarSync = {||}
		
		sharedVarHide = {||}
		}
endmodule


--
-- RoboChart generator version 3.0.0.qualifier
-- Automatically generated on 06-01-2026 10:12:27
--
-- Iterated compression status: true
-- Assertions compression status: false
--

module ScrewDetection_ScrewDetection
	exports
	
	transparent diamond
	transparent sbisim
	transparent dbisim
	transparent chase
	
	-- declaring channels
	-- declaring robotic platform events
	channel getImage: InOut.Types_ImageData
	channel lightLevel: InOut.core_real
	channel forceTorque: InOut.{(x0__,x1__,x2__,x3__,x4__,x5__) | x0__ <- core_real,x1__ <- core_real,x2__ <- core_real,x3__ <- core_real,x4__ <- core_real,x5__ <- core_real}
	channel positionOrientation: InOut.{(x0__,x1__,x2__,x3__,x4__,x5__) | x0__ <- core_real,x1__ <- core_real,x2__ <- core_real,x3__ <- core_real,x4__ <- core_real,x5__ <- core_real}
	
	channel moveCall: {(x0__,x1__,x2__) | x0__ <- core_real,x1__ <- core_real,x2__ <- core_real}.{(x0__,x1__,x2__) | x0__ <- core_real,x1__ <- core_real,x2__ <- core_real}
	channel gripCall
	channel releaseCall
	channel activateToolCall
	channel deactivateToolCall
	
	-- declaring module termination channel
	channel terminate
	
	-- declaring robotic platform variables
	
	-- channel set with all visible events
	sem__events = {|
		getImage,
		lightLevel,
		forceTorque,
		positionOrientation
	,	moveCall,
		gripCall,
		releaseCall,
		activateToolCall,
		deactivateToolCall
	|}
	
	-- declaring controller
		module ctrl_ref0
			shared_variable_events = {|
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel switchModel: InOut.core_nat
			channel imageTaken: InOut.Types_ScrewImageData
			channel ambientLight: InOut.core_real
			channel currentModel: InOut.core_nat
			channel forceTorque: InOut.{(x0__,x1__,x2__,x3__,x4__,x5__) | x0__ <- core_real,x1__ <- core_real,x2__ <- core_real,x3__ <- core_real,x4__ <- core_real,x5__ <- core_real}
			channel positionOrientation: InOut.{(x0__,x1__,x2__,x3__,x4__,x5__) | x0__ <- core_real,x1__ <- core_real,x2__ <- core_real,x3__ <- core_real,x4__ <- core_real,x5__ <- core_real}
			channel getImage: InOut.Types_ImageData
			channel lightLevel: InOut.core_real
			
			
			
			-- declaring call and ret events for undefined operations
			channel moveCall: {(x0__,x1__,x2__) | x0__ <- core_real,x1__ <- core_real,x2__ <- core_real}.{(x0__,x1__,x2__) | x0__ <- core_real,x1__ <- core_real,x2__ <- core_real}
			
			-- declaring controller termination channel
			channel terminate
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	switchModel,
				imageTaken,
				ambientLight,
				currentModel,
				forceTorque,
				positionOrientation,
				getImage,
				lightLevel
			,	moveCall
			|}
			
			-- set of visible memory events
			visibleMemoryEvents = {||}
	
			-- defined operations
		
			-- declaring machines
			module stm0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_s0
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				s0::enter
				|}
				
				enteredSS = 	{|
				s0::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_s0 : core_clock_type 
				--channel increment__
				
				CLID_s0_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: s0
					module s0
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					
					STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					
					-- Transitions
					Transitions(id__) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; s0::enter -> SKIP))))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								s0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__)
									   [| { share__, terminate } |] (
									   s0::D__(id__)
									   )
									 )
									 [[s0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_s0,s0::entered|}
						 within
							(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_s0,s0::entered|}
						 within
							(dbisim(
								sbisim(
									MachineBody(id__)
									[| {|get_CLID_s0,s0::entered,terminate|} |]
									dbisim(Clock_CLID_s0(id__,0))
								)\{|get_CLID_s0|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__) = 
						((let
							getsetLocalChannels = {||}
							clockSync = {||}
						within
							(Behaviour(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__) =
						(IteratedBehaviour(id__))
					
					-- Visible counterparts
					MachineBody_VS_O(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								s0::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__)
									   [| { share__, terminate } |] (
									   s0::VS_O__(id__)
									   )
									 )
									 [[s0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_s0,s0::entered|}
						 within
							(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_s0,s0::entered|}
						 within
							(dbisim(
								sbisim(
									MachineBody_VS_O(id__)
									[| {|get_CLID_s0,s0::entered,terminate|} |]
									dbisim(Clock_CLID_s0(id__,0))
								)\{|get_CLID_s0|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__) = 
						dbisim((let
							getsetLocalChannels = {||}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__) =
						(IteratedBehaviour_VS_O(id__))
					
					-- END
					
					-- Memory
					-- Memory variables
					
					-- varMemory process
					varMemory(id__) = terminate -> SKIP
					
					getsetLocalChannels = {||}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__) = STM_VS_O(id__) \ localClockResets
					D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
					O__(id__) = dbisim(D__(id__))
					VS__(id__) = FVS__(id__)
					VS_O__(id__) = dbisim(FVS__(id__))
					HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
					FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
					HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_s0(id__,x__) = 
						TimeOut_1(
							s0::entered -> Clock_CLID_s0(id__,0)
							[]
							get_CLID_s0!x__ -> Clock_CLID_s0(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_s0(id__,clock_type_plus(x__,1,CLID_s0_clock_type(id__))))
					
					StateClocks(id__) = dbisim(Clock_CLID_s0(id__,0))
					
					stateClockSync = {|get_CLID_s0,s0::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			
			Timed(OneStep) {
					-- undefined operations
					CALL__move(id__,
							    param_position,
							    param_orientation) 	= moveCall.param_position.param_orientation -> SKIP
					
					-- declaring controller memory
					Memory(id__) = SKIP
					
					D__(id__) = prioritise(	((
							stm0::D__(id__)[[
								stm0::terminate <- terminate
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>)
					
					-- VS version
					VS__(id__) = prioritise(	((
							stm0::VS__(id__)[[
								stm0::terminate <- terminate
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>)
				
					-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
					O__(id__) = dbisim(prioritise(	((
							stm0::O__(id__)[[
								stm0::terminate <- terminate
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>))
									
					-- VS_O version
					VS_O__(id__) = dbisim(prioritise(	((
							stm0::VS_O__(id__)[[
								stm0::terminate <- terminate
							]]
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>))
				
					HEXT(id__) = O__(id__) [|shared_variable_events|] SKIP			
			}
	
		endmodule
		module ctrl_ref1
			shared_variable_events = {|
			|}
			
		exports
			transparent diamond
			transparent sbisim
			transparent dbisim
			transparent chase
	
			-- declaring controller events
			channel imageTaken: InOut.Types_ScrewImageData
			channel ambientLight: InOut.core_real
			channel currentModel: InOut.core_nat
			channel switchModel: InOut.core_nat
			
			
			
			-- declaring call and ret events for undefined operations
			
			-- declaring controller termination channel
			channel terminate
			
			-- channel set with all visible events
			sem__events = {|
				terminate
			,	imageTaken,
				ambientLight,
				currentModel,
				switchModel
			|}
			
			-- set of visible memory events
			visibleMemoryEvents = {||}
	
			-- defined operations
		
			-- declaring machines
			module stm_ref0
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Initialise|
				              NID_ReadInput|
				              NID_ProcessData|
				              NID_RecordData|
				              NID_j0|
				              NID_SendData
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_outputData, set_outputData, setL_outputData, setR_outputData: {(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat}
				channel get_dataToSend, set_dataToSend, setL_dataToSend, setR_dataToSend: core_boolean
				channel get_imageTaken_data, set_imageTaken_data, setL_imageTaken_data, setR_imageTaken_data: Types_ScrewImageData
				channel get_ambientLight_data, set_ambientLight_data, setL_ambientLight_data, setR_ambientLight_data: core_real
				channel get_currentModel_data, set_currentModel_data, setL_currentModel_data, setR_currentModel_data: core_nat
				channel get_imageTaken_flag, set_imageTaken_flag, setL_imageTaken_flag, setR_imageTaken_flag: core_boolean
				channel get_ambientLight_flag, set_ambientLight_flag, setL_ambientLight_flag, setR_ambientLight_flag: core_boolean
				channel get_currentModel_flag, set_currentModel_flag, setL_currentModel_flag, setR_currentModel_flag: core_boolean
				channel get_imagesWithLight_var, set_imagesWithLight_var, setL_imagesWithLight_var, setR_imagesWithLight_var: LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel processedData__: NIDS.InOut.{(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat}
				channel processedData: InOut.{(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat}
				channel imageTaken__: NIDS.InOut.Types_ScrewImageData
				channel imageTaken: InOut.Types_ScrewImageData
				channel ambientLight__: NIDS.InOut.core_real
				channel ambientLight: InOut.core_real
				channel currentModel__: NIDS.InOut.core_nat
				channel currentModel: InOut.core_nat
				channel imagesWithLight__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel imagesWithLight: InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel get_imagesWithLight__: NIDS.InOut
				channel get_imagesWithLight: InOut
				channel set_imagesWithLight__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel set_imagesWithLight: InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				Initialise::enter,
				ReadInput::enter,
				ProcessData::enter,
				RecordData::enter,
				j0::enter,
				SendData::enter
				|}
				
				enteredSS = 	{|
				Initialise::entered,
				ReadInput::entered,
				ProcessData::entered,
				RecordData::entered,
				SendData::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	processedData,
					imageTaken,
					ambientLight,
					currentModel,
					imagesWithLight,
					get_imagesWithLight,
					set_imagesWithLight
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_ReadInput : core_clock_type 
				channel get_CLID_RecordData : core_clock_type 
				channel get_CLID_SendData : core_clock_type 
				channel get_CLID_Initialise : core_clock_type 
				channel get_CLID_ProcessData : core_clock_type 
				--channel increment__
				
				CLID_ReadInput_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_RecordData_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_SendData_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Initialise_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_ProcessData_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Initialise
					module Initialise
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: ReadInput
					module ReadInput
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: ProcessData
					module ProcessData
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_ambientLight_flag?ambientLight_flag -> share__choice(get_currentModel_flag?currentModel_flag -> share__choice(get_imageTaken_flag?imageTaken_flag -> true & (share__choice(set_dataToSend!((currentModel_flag and imageTaken_flag) and ambientLight_flag) -> SKIP)))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(share__choice(get_ambientLight_flag?ambientLight_flag -> share__choice(get_currentModel_flag?currentModel_flag -> share__choice(get_imageTaken_flag?imageTaken_flag -> true & (share__choice(set_dataToSend!((currentModel_flag and imageTaken_flag) and ambientLight_flag) -> SKIP)))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: RecordData
					module RecordData
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_dataToSend?dataToSend -> true&(if dataToSend then (true&(share__choice(get_imagesWithLight.out -> SKIP));true&(share__choice(imagesWithLight.in?imagesWithLight_var -> (SStop /\ set_imagesWithLight_var!imagesWithLight_var -> SKIP)));share__choice(get_ambientLight_data?ambientLight_data -> share__choice(get_imagesWithLight_var?imagesWithLight_var -> share__choice(get_currentModel_data?currentModel_data -> share__choice(get_imageTaken_data?imageTaken_data -> true&(share__choice(set_imagesWithLight.out!((imagesWithLight_var ^ <(imageTaken_data,ambientLight_data,currentModel_data)>)) -> SKIP)))))))else SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_dataToSend?dataToSend -> true&(if dataToSend then (true&(share__choice(get_imagesWithLight.out -> SKIP));true&(share__choice(imagesWithLight.in?imagesWithLight_var -> (SStop /\ set_imagesWithLight_var!imagesWithLight_var -> SKIP)));share__choice(get_ambientLight_data?ambientLight_data -> share__choice(get_imagesWithLight_var?imagesWithLight_var -> share__choice(get_currentModel_data?currentModel_data -> share__choice(get_imageTaken_data?imageTaken_data -> true&(share__choice(set_imagesWithLight.out!((imagesWithLight_var ^ <(imageTaken_data,ambientLight_data,currentModel_data)>)) -> SKIP)))))))else SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- Junction: j0
					module j0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: SendData
					module SendData
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					
					STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					
					-- Transitions
					Transitions(id__) = ((let
						Trans = share__choice(get_dataToSend?dataToSend -> TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; Initialise::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_Initialise -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; ReadInput::enter -> SKIP)))
							 [] dbisim((true)&(imageTaken__!NID_ReadInput.in?imageTaken_data:{imageTaken_data|imageTaken_data <- Types_ScrewImageData, true} -> share__choice(set_imageTaken_data!imageTaken_data -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_imageTaken_flag!true -> SKIP))) ; ProcessData::enter -> SKIP)))
							 [] dbisim((true)&(ambientLight__!NID_ReadInput.in?ambientLight_data:{ambientLight_data|ambientLight_data <- core_real, true} -> share__choice(set_ambientLight_data!ambientLight_data -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_ambientLight_flag!true -> SKIP))) ; ProcessData::enter -> SKIP)))
							 [] dbisim((true)&(currentModel__!NID_ReadInput.in?currentModel_data:{currentModel_data|currentModel_data <- core_nat, true} -> share__choice(set_currentModel_data!currentModel_data -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_currentModel_flag!true -> SKIP))) ; ProcessData::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_ProcessData -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; RecordData::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_RecordData -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; j0::enter -> SKIP)))
							 [] dbisim((dataToSend)&(internal__!NID_j0 -> SKIP ;  ((SKIP ; SendData::enter -> SKIP))))
							 [] dbisim(((not (dataToSend)))&(internal__!NID_j0 -> SKIP ;  ((SKIP ; ReadInput::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_SendData -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_outputData?outputData -> true&(share__choice(processedData.out!outputData -> SKIP)));share__choice(true & (share__choice(set_dataToSend!false -> SKIP))) ; ReadInput::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
						)
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Initialise::enter,
								ReadInput::enter,
								ProcessData::enter,
								RecordData::enter,
								j0::enter,
								SendData::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_Initialise,imageTaken__.NID_ReadInput.in,ambientLight__.NID_ReadInput.in,currentModel__.NID_ReadInput.in,internal__.NID_ProcessData,internal__.NID_RecordData,internal__.NID_j0,internal__.NID_j0,internal__.NID_SendData|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__)
									   [| { share__, terminate } |] (
									   Initialise::D__(id__)
									   [| { share__, terminate } |] (
									   ReadInput::D__(id__)
									   [| { share__, terminate } |] (
									   ProcessData::D__(id__)
									   [| { share__, terminate } |] (
									   RecordData::D__(id__)
									   [| { share__, terminate } |] (
									   j0::D__(id__)
									   [| { share__, terminate } |] (
									   SendData::D__(id__)
									   )
									   )
									   )
									   )
									   )
									   )
									 )
									 [[Initialise::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialise|}]]
									 [[ReadInput::interrupt <- x__ | x__ <- {|interrupt,imageTaken__.NID_ReadInput.in,ambientLight__.NID_ReadInput.in,currentModel__.NID_ReadInput.in|}]]
									 [[ProcessData::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_ProcessData|}]]
									 [[RecordData::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_RecordData|}]]
									 [[SendData::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SendData|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 [[j0::interrupt <- x__ | x__ <- {|internal__.NID_j0,internal__.NID_j0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_ambientLight_data,setR_currentModel_data,setR_imageTaken_data |} ]] 
									  [[set_dataToSend <- setL_dataToSend]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_dataToSend
									 			,setR_ambientLight_data
									 			 			,setR_currentModel_data
									 			 			,setR_imageTaken_data
									 			|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__,setL_dataToSend |} ]]
									  [[set_ambientLight_data <- setR_ambientLight_data,set_currentModel_data <- setR_currentModel_data,set_imageTaken_data <- setR_imageTaken_data]]
									 )
									)[[setL_dataToSend <- set_dataToSend]]
									 [[setR_ambientLight_data <- set_ambientLight_data,setR_currentModel_data <- set_currentModel_data,setR_imageTaken_data <- set_imageTaken_data]]
									)
								)
								 \ hideSet)
								[[
									processedData__.x____ <- processedData,
									imageTaken__.x____ <- imageTaken,
									ambientLight__.x____ <- ambientLight,
									currentModel__.x____ <- currentModel,
									imagesWithLight__.x____ <- imagesWithLight,
									get_imagesWithLight__.x____ <- get_imagesWithLight,
									set_imagesWithLight__.x____ <- set_imagesWithLight
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_ReadInput,ReadInput::entered,get_CLID_RecordData,RecordData::entered,get_CLID_SendData,SendData::entered,get_CLID_Initialise,Initialise::entered,get_CLID_ProcessData,ProcessData::entered|}
						 within
							(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_ReadInput,ReadInput::entered,get_CLID_RecordData,RecordData::entered,get_CLID_SendData,SendData::entered,get_CLID_Initialise,Initialise::entered,get_CLID_ProcessData,ProcessData::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	MachineBody(id__)
																	[| {|get_CLID_ProcessData,ProcessData::entered,terminate|} |]
																	dbisim(Clock_CLID_ProcessData(id__,0))
																)\{|get_CLID_ProcessData|}
															)
															[| {|get_CLID_Initialise,Initialise::entered,terminate|} |]
															dbisim(Clock_CLID_Initialise(id__,0))
														)\{|get_CLID_Initialise|}
													)
													[| {|get_CLID_SendData,SendData::entered,terminate|} |]
													dbisim(Clock_CLID_SendData(id__,0))
												)\{|get_CLID_SendData|}
											)
											[| {|get_CLID_RecordData,RecordData::entered,terminate|} |]
											dbisim(Clock_CLID_RecordData(id__,0))
										)\{|get_CLID_RecordData|}
									)
									[| {|get_CLID_ReadInput,ReadInput::entered,terminate|} |]
									dbisim(Clock_CLID_ReadInput(id__,0))
								)\{|get_CLID_ReadInput|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__) = 
						((let
							getsetLocalChannels = {|get_outputData,set_outputData,
							get_dataToSend,set_dataToSend,
							get_imageTaken_data,set_imageTaken_data,
							get_ambientLight_data,set_ambientLight_data,
							get_currentModel_data,set_currentModel_data,
							get_imageTaken_flag,set_imageTaken_flag,
							get_ambientLight_flag,set_ambientLight_flag,
							get_currentModel_flag,set_currentModel_flag,
							get_imagesWithLight_var,set_imagesWithLight_var|}
							clockSync = {||}
						within
							(Behaviour(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				dbisim(
																					sbisim(
																						dbisim(
																							sbisim(
																								IteratedBehaviour(id__)
																								[| {|get_imagesWithLight_var,set_imagesWithLight_var,terminate|} |]
																								Memory_imagesWithLight_var(<>)
																							)\{|get_imagesWithLight_var,set_imagesWithLight_var|}
																						)
																						[| {|get_currentModel_flag,set_currentModel_flag,terminate|} |]
																						Memory_currentModel_flag(true)
																					)\{|get_currentModel_flag,set_currentModel_flag|}
																				)
																				[| {|get_ambientLight_flag,set_ambientLight_flag,terminate|} |]
																				Memory_ambientLight_flag(true)
																			)\{|get_ambientLight_flag,set_ambientLight_flag|}
																		)
																		[| {|get_imageTaken_flag,set_imageTaken_flag,terminate|} |]
																		Memory_imageTaken_flag(true)
																	)\{|get_imageTaken_flag,set_imageTaken_flag|}
																)
																[| {|get_currentModel_data,set_currentModel_data,terminate|} |]
																Memory_currentModel_data(0)
															)\{|get_currentModel_data,set_currentModel_data|}
														)
														[| {|get_ambientLight_data,set_ambientLight_data,terminate|} |]
														Memory_ambientLight_data(0)
													)\{|get_ambientLight_data,set_ambientLight_data|}
												)
												[| {|get_imageTaken_data,set_imageTaken_data,terminate|} |]
												Memory_imageTaken_data(((0,0,0),(0,0,0),(<>,0,0),<>))
											)\{|get_imageTaken_data,set_imageTaken_data|}
										)
										[| {|get_dataToSend,set_dataToSend,terminate|} |]
										Memory_dataToSend(true)
									)\{|get_dataToSend,set_dataToSend|}
								)
								[| {|get_outputData,set_outputData,terminate|} |]
								Memory_outputData((((0,0,0),(0,0,0),(<>,0,0),<>),0,0))
							)\{|get_outputData,set_outputData|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Initialise::enter,
								ReadInput::enter,
								ProcessData::enter,
								RecordData::enter,
								j0::enter,
								SendData::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_Initialise,imageTaken__.NID_ReadInput.in,ambientLight__.NID_ReadInput.in,currentModel__.NID_ReadInput.in,internal__.NID_ProcessData,internal__.NID_RecordData,internal__.NID_j0,internal__.NID_j0,internal__.NID_SendData|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__)
									   [| { share__, terminate } |] (
									   Initialise::VS_O__(id__)
									   [| { share__, terminate } |] (
									   ReadInput::VS_O__(id__)
									   [| { share__, terminate } |] (
									   ProcessData::VS_O__(id__)
									   [| { share__, terminate } |] (
									   RecordData::VS_O__(id__)
									   [| { share__, terminate } |] (
									   j0::VS_O__(id__)
									   [| { share__, terminate } |] (
									   SendData::VS_O__(id__)
									   )
									   )
									   )
									   )
									   )
									   )
									 )
									 [[Initialise::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialise|}]]
									 [[ReadInput::interrupt <- x__ | x__ <- {|interrupt,imageTaken__.NID_ReadInput.in,ambientLight__.NID_ReadInput.in,currentModel__.NID_ReadInput.in|}]]
									 [[ProcessData::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_ProcessData|}]]
									 [[RecordData::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_RecordData|}]]
									 [[SendData::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SendData|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 [[j0::interrupt <- x__ | x__ <- {|internal__.NID_j0,internal__.NID_j0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_ambientLight_data,setR_currentModel_data,setR_imageTaken_data |} ]] 
									  [[set_dataToSend <- setL_dataToSend]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_dataToSend
									 			,setR_ambientLight_data
									 			 			,setR_currentModel_data
									 			 			,setR_imageTaken_data
									 			|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__,setL_dataToSend |} ]]
									  [[set_ambientLight_data <- setR_ambientLight_data,set_currentModel_data <- setR_currentModel_data,set_imageTaken_data <- setR_imageTaken_data]]
									 )
									)[[setL_dataToSend <- set_dataToSend]]
									 [[setR_ambientLight_data <- set_ambientLight_data,setR_currentModel_data <- set_currentModel_data,setR_imageTaken_data <- set_imageTaken_data]]
									)
								)
								 \ hideSet)
								[[
									processedData__.x____ <- processedData,
									imageTaken__.x____ <- imageTaken,
									ambientLight__.x____ <- ambientLight,
									currentModel__.x____ <- currentModel,
									imagesWithLight__.x____ <- imagesWithLight,
									get_imagesWithLight__.x____ <- get_imagesWithLight,
									set_imagesWithLight__.x____ <- set_imagesWithLight
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_ReadInput,ReadInput::entered,get_CLID_RecordData,RecordData::entered,get_CLID_SendData,SendData::entered,get_CLID_Initialise,Initialise::entered,get_CLID_ProcessData,ProcessData::entered|}
						 within
							(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_ReadInput,ReadInput::entered,get_CLID_RecordData,RecordData::entered,get_CLID_SendData,SendData::entered,get_CLID_Initialise,Initialise::entered,get_CLID_ProcessData,ProcessData::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	MachineBody_VS_O(id__)
																	[| {|get_CLID_ProcessData,ProcessData::entered,terminate|} |]
																	dbisim(Clock_CLID_ProcessData(id__,0))
																)\{|get_CLID_ProcessData|}
															)
															[| {|get_CLID_Initialise,Initialise::entered,terminate|} |]
															dbisim(Clock_CLID_Initialise(id__,0))
														)\{|get_CLID_Initialise|}
													)
													[| {|get_CLID_SendData,SendData::entered,terminate|} |]
													dbisim(Clock_CLID_SendData(id__,0))
												)\{|get_CLID_SendData|}
											)
											[| {|get_CLID_RecordData,RecordData::entered,terminate|} |]
											dbisim(Clock_CLID_RecordData(id__,0))
										)\{|get_CLID_RecordData|}
									)
									[| {|get_CLID_ReadInput,ReadInput::entered,terminate|} |]
									dbisim(Clock_CLID_ReadInput(id__,0))
								)\{|get_CLID_ReadInput|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__) = 
						dbisim((let
							getsetLocalChannels = {|get_outputData,set_outputData,
							get_dataToSend,set_dataToSend,
							get_imageTaken_data,set_imageTaken_data,
							get_ambientLight_data,set_ambientLight_data,
							get_currentModel_data,set_currentModel_data,
							get_imageTaken_flag,set_imageTaken_flag,
							get_ambientLight_flag,set_ambientLight_flag,
							get_currentModel_flag,set_currentModel_flag,
							get_imagesWithLight_var,set_imagesWithLight_var|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				dbisim(
																					sbisim(
																						dbisim(
																							sbisim(
																								IteratedBehaviour_VS_O(id__)
																								[| {|get_imagesWithLight_var,set_imagesWithLight_var,terminate|} |]
																								Memory_imagesWithLight_var(<>)
																							)\{|get_imagesWithLight_var,set_imagesWithLight_var|}
																						)
																						[| {|get_currentModel_flag,set_currentModel_flag,terminate|} |]
																						Memory_currentModel_flag(true)
																					)\{|get_currentModel_flag,set_currentModel_flag|}
																				)
																				[| {|get_ambientLight_flag,set_ambientLight_flag,terminate|} |]
																				Memory_ambientLight_flag(true)
																			)\{|get_ambientLight_flag,set_ambientLight_flag|}
																		)
																		[| {|get_imageTaken_flag,set_imageTaken_flag,terminate|} |]
																		Memory_imageTaken_flag(true)
																	)\{|get_imageTaken_flag,set_imageTaken_flag|}
																)
																[| {|get_currentModel_data,set_currentModel_data,terminate|} |]
																Memory_currentModel_data(0)
															)\{|get_currentModel_data,set_currentModel_data|}
														)
														[| {|get_ambientLight_data,set_ambientLight_data,terminate|} |]
														Memory_ambientLight_data(0)
													)\{|get_ambientLight_data,set_ambientLight_data|}
												)
												[| {|get_imageTaken_data,set_imageTaken_data,terminate|} |]
												Memory_imageTaken_data(((0,0,0),(0,0,0),(<>,0,0),<>))
											)\{|get_imageTaken_data,set_imageTaken_data|}
										)
										[| {|get_dataToSend,set_dataToSend,terminate|} |]
										Memory_dataToSend(true)
									)\{|get_dataToSend,set_dataToSend|}
								)
								[| {|get_outputData,set_outputData,terminate|} |]
								Memory_outputData((((0,0,0),(0,0,0),(<>,0,0),<>),0,0))
							)\{|get_outputData,set_outputData|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_outputData(outputData) =
						get_outputData!outputData -> Memory_outputData(outputData)
						[]
						set_outputData?x__ -> Memory_outputData(x__)
						[]
						terminate -> SKIP
					Memory_dataToSend(dataToSend) =
						get_dataToSend!dataToSend -> Memory_dataToSend(dataToSend)
						[]
						set_dataToSend?x__ -> Memory_dataToSend(x__)
						[]
						terminate -> SKIP
					Memory_imageTaken_data(imageTaken_data) =
						get_imageTaken_data!imageTaken_data -> Memory_imageTaken_data(imageTaken_data)
						[]
						set_imageTaken_data?x__ -> Memory_imageTaken_data(x__)
						[]
						terminate -> SKIP
					Memory_ambientLight_data(ambientLight_data) =
						get_ambientLight_data!ambientLight_data -> Memory_ambientLight_data(ambientLight_data)
						[]
						set_ambientLight_data?x__ -> Memory_ambientLight_data(x__)
						[]
						terminate -> SKIP
					Memory_currentModel_data(currentModel_data) =
						get_currentModel_data!currentModel_data -> Memory_currentModel_data(currentModel_data)
						[]
						set_currentModel_data?x__ -> Memory_currentModel_data(x__)
						[]
						terminate -> SKIP
					Memory_imageTaken_flag(imageTaken_flag) =
						get_imageTaken_flag!imageTaken_flag -> Memory_imageTaken_flag(imageTaken_flag)
						[]
						set_imageTaken_flag?x__ -> Memory_imageTaken_flag(x__)
						[]
						terminate -> SKIP
					Memory_ambientLight_flag(ambientLight_flag) =
						get_ambientLight_flag!ambientLight_flag -> Memory_ambientLight_flag(ambientLight_flag)
						[]
						set_ambientLight_flag?x__ -> Memory_ambientLight_flag(x__)
						[]
						terminate -> SKIP
					Memory_currentModel_flag(currentModel_flag) =
						get_currentModel_flag!currentModel_flag -> Memory_currentModel_flag(currentModel_flag)
						[]
						set_currentModel_flag?x__ -> Memory_currentModel_flag(x__)
						[]
						terminate -> SKIP
					Memory_imagesWithLight_var(imagesWithLight_var) =
						get_imagesWithLight_var!imagesWithLight_var -> Memory_imagesWithLight_var(imagesWithLight_var)
						[]
						set_imagesWithLight_var?x__ -> Memory_imagesWithLight_var(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__) = Memory_outputData((((0,0,0),(0,0,0),(<>,0,0),<>),0,0))
					[| { terminate } |] (
					Memory_dataToSend(true)
					[| { terminate } |] (
					Memory_imageTaken_data(((0,0,0),(0,0,0),(<>,0,0),<>))
					[| { terminate } |] (
					Memory_ambientLight_data(0)
					[| { terminate } |] (
					Memory_currentModel_data(0)
					[| { terminate } |] (
					Memory_imageTaken_flag(true)
					[| { terminate } |] (
					Memory_ambientLight_flag(true)
					[| { terminate } |] (
					Memory_currentModel_flag(true)
					[| { terminate } |] (
					Memory_imagesWithLight_var(<>)
					)
					)
					)
					)
					)
					)
					)
					)
					
					getsetLocalChannels = {|get_outputData,set_outputData,get_dataToSend,set_dataToSend,get_imageTaken_data,set_imageTaken_data,get_ambientLight_data,set_ambientLight_data,get_currentModel_data,set_currentModel_data,get_imageTaken_flag,set_imageTaken_flag,get_ambientLight_flag,set_ambientLight_flag,get_currentModel_flag,set_currentModel_flag,get_imagesWithLight_var,set_imagesWithLight_var|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__) = STM_VS_O(id__) \ localClockResets
					D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
					O__(id__) = dbisim(D__(id__))
					VS__(id__) = FVS__(id__)
					VS_O__(id__) = dbisim(FVS__(id__))
					HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
					FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
					HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_ReadInput(id__,x__) = 
						TimeOut_1(
							ReadInput::entered -> Clock_CLID_ReadInput(id__,0)
							[]
							get_CLID_ReadInput!x__ -> Clock_CLID_ReadInput(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_ReadInput(id__,clock_type_plus(x__,1,CLID_ReadInput_clock_type(id__))))
					Clock_CLID_RecordData(id__,x__) = 
						TimeOut_1(
							RecordData::entered -> Clock_CLID_RecordData(id__,0)
							[]
							get_CLID_RecordData!x__ -> Clock_CLID_RecordData(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_RecordData(id__,clock_type_plus(x__,1,CLID_RecordData_clock_type(id__))))
					Clock_CLID_SendData(id__,x__) = 
						TimeOut_1(
							SendData::entered -> Clock_CLID_SendData(id__,0)
							[]
							get_CLID_SendData!x__ -> Clock_CLID_SendData(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_SendData(id__,clock_type_plus(x__,1,CLID_SendData_clock_type(id__))))
					Clock_CLID_Initialise(id__,x__) = 
						TimeOut_1(
							Initialise::entered -> Clock_CLID_Initialise(id__,0)
							[]
							get_CLID_Initialise!x__ -> Clock_CLID_Initialise(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_Initialise(id__,clock_type_plus(x__,1,CLID_Initialise_clock_type(id__))))
					Clock_CLID_ProcessData(id__,x__) = 
						TimeOut_1(
							ProcessData::entered -> Clock_CLID_ProcessData(id__,0)
							[]
							get_CLID_ProcessData!x__ -> Clock_CLID_ProcessData(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_ProcessData(id__,clock_type_plus(x__,1,CLID_ProcessData_clock_type(id__))))
					
					StateClocks(id__) = dbisim(Clock_CLID_ReadInput(id__,0))
					[| { terminate } |] (
					dbisim(Clock_CLID_RecordData(id__,0))
					[| { terminate } |] (
					dbisim(Clock_CLID_SendData(id__,0))
					[| { terminate } |] (
					dbisim(Clock_CLID_Initialise(id__,0))
					[| { terminate } |] (
					dbisim(Clock_CLID_ProcessData(id__,0))
					)
					)
					)
					)
					
					stateClockSync = {|get_CLID_ReadInput,ReadInput::entered,get_CLID_RecordData,RecordData::entered,get_CLID_SendData,SendData::entered,get_CLID_Initialise,Initialise::entered,get_CLID_ProcessData,ProcessData::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref1
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Initialise|
				              NID_WaitForData|
				              NID_AnalyseAnomaly|
				              NID_AnalysisComplete
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_data, set_data, setL_data, setR_data: {(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat}
				channel get_anomalyDetected, set_anomalyDetected, setL_anomalyDetected, setR_anomalyDetected: core_boolean
				channel get_awaitingAdaptation, set_awaitingAdaptation, setL_awaitingAdaptation, setR_awaitingAdaptation: core_boolean
				channel get_currentModel, set_currentModel, setL_currentModel, setR_currentModel: core_nat
				channel get_i, set_i, setL_i, setR_i: core_nat
				channel get_image, set_image, setL_image, setR_image: Types_ScrewImageData
				channel get_light, set_light, setL_light, setR_light: core_real
				channel get_model, set_model, setL_model, setR_model: core_nat
				channel get_imagesWithPoorLight_var, set_imagesWithPoorLight_var, setL_imagesWithPoorLight_var, setR_imagesWithPoorLight_var: LSeq(core_nat,2)
				channel get_imagesWithLight_var, set_imagesWithLight_var, setL_imagesWithLight_var, setR_imagesWithLight_var: LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel anomalyFound__: NIDS.InOut
				channel anomalyFound: InOut
				channel processedData__: NIDS.InOut.{(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat}
				channel processedData: InOut.{(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat}
				channel adaptationCompleted__: NIDS.InOut
				channel adaptationCompleted: InOut
				channel imagesWithPoorLight__: NIDS.InOut.LSeq(core_nat,2)
				channel imagesWithPoorLight: InOut.LSeq(core_nat,2)
				channel get_imagesWithPoorLight__: NIDS.InOut
				channel get_imagesWithPoorLight: InOut
				channel set_imagesWithPoorLight__: NIDS.InOut.LSeq(core_nat,2)
				channel set_imagesWithPoorLight: InOut.LSeq(core_nat,2)
				channel imagesWithLight__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel imagesWithLight: InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel get_imagesWithLight__: NIDS.InOut
				channel get_imagesWithLight: InOut
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				Initialise::enter,
				WaitForData::enter,
				AnalyseAnomaly::enter,
				AnalysisComplete::enter
				|}
				
				enteredSS = 	{|
				Initialise::entered,
				WaitForData::entered,
				AnalyseAnomaly::entered,
				AnalysisComplete::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	anomalyFound,
					processedData,
					adaptationCompleted,
					imagesWithPoorLight,
					get_imagesWithPoorLight,
					set_imagesWithPoorLight,
					imagesWithLight,
					get_imagesWithLight
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_AnalyseAnomaly : core_clock_type 
				channel get_CLID_AnalysisComplete : core_clock_type 
				channel get_CLID_WaitForData : core_clock_type 
				channel get_CLID_Initialise : core_clock_type 
				--channel increment__
				
				CLID_AnalyseAnomaly_clock_type(id__,
						          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
						          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
						          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_AnalysisComplete_clock_type(id__,
						          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
						          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
						          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_WaitForData_clock_type(id__,
						          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
						          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
						          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Initialise_clock_type(id__,
						          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
						          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
						          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = D__(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Initialise
					module Initialise
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: WaitForData
					module WaitForData
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: AnalyseAnomaly
					module AnalyseAnomaly
					
					enterSS = 
							{|			i0::enter,
								CheckConfidence::enter,
								f0::enter
							|}
					enteredSS = 
							{|			CheckConfidence::entered,
								f0::entered
							|}
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						-- declaring identifiers of transitions
						datatype NIDS = 
						              NID_i0|
						              NID_CheckConfidence|
						              NID_f0
						
						channel internal__ : NIDS
						channel anomalyFound__: NIDS.InOut
						channel processedData__: NIDS.InOut.{(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat}
						channel adaptationCompleted__: NIDS.InOut
						channel imagesWithPoorLight__: NIDS.InOut.LSeq(core_nat,2)
						channel get_imagesWithPoorLight__: NIDS.InOut
						channel set_imagesWithPoorLight__: NIDS.InOut.LSeq(core_nat,2)
						channel imagesWithLight__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
						channel get_imagesWithLight__: NIDS.InOut
						
						channel get_CLID_CheckConfidence : core_clock_type 
						--channel increment__
						
						CLID_CheckConfidence_clock_type(id__,
								          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
								          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
								          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
							let
								max = (clock_type_max(Union({
						{}
						}))+1)
							ctype = {0..max}
						within
							if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
						
						
						--	Nodes
						-- declaring all nodes
						
						----------------------------------------------------------------------
						-- Initial: i0
						module i0
						exports
						
							channel enter, interrupt
							
							Timed(OneStep) {
								D__(id__,
										    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
										    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
									dbisim(let
										Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
										
										Termination = terminate -> SKIP
										
										Active 		= share__choice(interrupt -> SKIP) ; Inactive
									within
										Inactive [| {terminate} |> SKIP)
								
								VS_O__(id__,
										    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
										    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = D__(id__,
										    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
										    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- State: CheckConfidence
						module CheckConfidence
						
						enterSS = {}
						
						enteredSS = {}
						
						exports
						
							--  Declarations
							
							channel enter, entered, interrupt
							channel enteredL, enteredR
							
											
							
							--channel increment__
							
							
							--	Nodes
							-- declaring all nodes
							
							
							Timed(OneStep) {
								--	Rule: behaviours(Node)
								--  Note that FDR has problems with efficiently compiling the process below
								-- 	if using a different recursion pattern.
								D__(id__,
										    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
										    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
								dbisim(let
									-- IMPLEMENTATION NOTE: 
									-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
									-- however FDR struggles with that form in certain cases. So we use the exception operator
									-- instead to 'terminate'.
									
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(get_i?i -> true&(if (i>0) then (share__choice(share__choice(get_imagesWithLight_var?imagesWithLight_var -> share__choice(get_i?i -> true & (share__choice(set_image!tuple3_1((access_(imagesWithLight_var, i))) -> SKIP)))));share__choice(share__choice(get_imagesWithLight_var?imagesWithLight_var -> share__choice(get_i?i -> true & (share__choice(set_light!tuple3_2((access_(imagesWithLight_var, i))) -> SKIP)))));share__choice(share__choice(get_imagesWithLight_var?imagesWithLight_var -> share__choice(get_i?i -> true & (share__choice(set_model!tuple3_3((access_(imagesWithLight_var, i))) -> SKIP)))));share__choice(get_currentModel?currentModel -> share__choice(get_model?model -> true&(if (model==currentModel) then (share__choice(get_light?light -> share__choice(get_screw?screw -> share__choice(get_model?model -> share__choice(get_image?image -> true&(if ((sequence_toolkit_filter(Types_ScrewImageData_screwsDetected(image),{screw | screw <- Types_EstimatedPosition, (Types_EstimatedPosition_confidence(screw)>=const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD)})==<>) and (((light<tuple2_1(((callFunc((IDEAL_LIGHTING), (model)))))) or (light>tuple2_2(((callFunc((IDEAL_LIGHTING), (model))))))))) then (share__choice(share__choice(get_i?i -> share__choice(get_imagesWithPoorLight_var?imagesWithPoorLight_var -> true & (share__choice(set_imagesWithPoorLight_var!(<i> ^ imagesWithPoorLight_var) -> SKIP)))));share__choice(share__choice(get_i?i -> true & (share__choice(set_i!Adaptation_Analyse_predecessor(i) -> SKIP))))) else (share__choice(get_i?i -> share__choice(get_imagesWithPoorLight_var?imagesWithPoorLight_var -> true&(if (Plus(i, 1, core_nat)<sequence_toolkit_head(imagesWithPoorLight_var)) then (share__choice(true & (share__choice(set_i!0 -> SKIP)))) else (share__choice(share__choice(get_i?i -> true & (share__choice(set_i!Adaptation_Analyse_predecessor(i) -> SKIP))))))))))))))) else (share__choice(true & (share__choice(set_i!0 -> SKIP))))))))else SKIP)) ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
									
								VS_O__(id__,
										    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
										    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(get_i?i -> true&(if (i>0) then (share__choice(share__choice(get_imagesWithLight_var?imagesWithLight_var -> share__choice(get_i?i -> true & (share__choice(set_image!tuple3_1((access_(imagesWithLight_var, i))) -> SKIP)))));share__choice(share__choice(get_imagesWithLight_var?imagesWithLight_var -> share__choice(get_i?i -> true & (share__choice(set_light!tuple3_2((access_(imagesWithLight_var, i))) -> SKIP)))));share__choice(share__choice(get_imagesWithLight_var?imagesWithLight_var -> share__choice(get_i?i -> true & (share__choice(set_model!tuple3_3((access_(imagesWithLight_var, i))) -> SKIP)))));share__choice(get_currentModel?currentModel -> share__choice(get_model?model -> true&(if (model==currentModel) then (share__choice(get_light?light -> share__choice(get_screw?screw -> share__choice(get_model?model -> share__choice(get_image?image -> true&(if ((sequence_toolkit_filter(Types_ScrewImageData_screwsDetected(image),{screw | screw <- Types_EstimatedPosition, (Types_EstimatedPosition_confidence(screw)>=const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD)})==<>) and (((light<tuple2_1(((callFunc((IDEAL_LIGHTING), (model)))))) or (light>tuple2_2(((callFunc((IDEAL_LIGHTING), (model))))))))) then (share__choice(share__choice(get_i?i -> share__choice(get_imagesWithPoorLight_var?imagesWithPoorLight_var -> true & (share__choice(set_imagesWithPoorLight_var!(<i> ^ imagesWithPoorLight_var) -> SKIP)))));share__choice(share__choice(get_i?i -> true & (share__choice(set_i!Adaptation_Analyse_predecessor(i) -> SKIP))))) else (share__choice(get_i?i -> share__choice(get_imagesWithPoorLight_var?imagesWithPoorLight_var -> true&(if (Plus(i, 1, core_nat)<sequence_toolkit_head(imagesWithPoorLight_var)) then (share__choice(true & (share__choice(set_i!0 -> SKIP)))) else (share__choice(share__choice(get_i?i -> true & (share__choice(set_i!Adaptation_Analyse_predecessor(i) -> SKIP))))))))))))))) else (share__choice(true & (share__choice(set_i!0 -> SKIP))))))))else SKIP)) ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
								
								
								-- Clocks
								
								StateClocks(id__,
										          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
										          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
										          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = terminate -> SKIP
								
								stateClockSync = {||}
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- Final state: f0
						module f0
						
						exports
						
							channel enter, entered, interrupt
							channel enteredL, enteredR
							
							Timed(OneStep) {
								--	Rule: behaviours(Node)
								D__(id__,
										    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
										    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
									dbisim(let
										Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
										
										Entering 	= entered -> SKIP ; Active
										Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
										Interrupted	= share__choice(exit -> exited -> Inactive)
									within
										Inactive [| {terminate} |> SKIP)
									
								VS_O__(id__,
										    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
										    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = D__(id__,
										    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
										    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(get_imagesWithLight.out -> SKIP));true&(share__choice(imagesWithLight.in?imagesWithLight_var -> (SStop /\ set_imagesWithLight_var!imagesWithLight_var -> SKIP)));share__choice(share__choice(get_data?data -> true & (share__choice(set_currentModel!tuple3_3(data) -> SKIP))));share__choice(true & (share__choice(set_imagesWithPoorLight_var!<> -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
							
								Behaviour 	= dbisim(
									((
									 (((dbisim(
									 	sbisim(
									 		(let
									 			-- IMPLEMENTATION NOTE:
									 			-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
									 			-- modules for defining the semantics of each node.
									 			enterSS = {|
									 			i0::enter,
									 			CheckConfidence::enter,
									 			f0::enter
									 			|}
									 			hideSet = union(enterSS,{|exit,exited,internal__|})
									 		within 
									 			((let
									 				-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									 				-- because CSPM modules are used for the semantics of Node.
									 				flowevts = union(enterSS,{|exit,exited,interrupt|})
									 				transSync = {|internal__.NID_i0,internal__.NID_CheckConfidence,internal__.NID_CheckConfidence|}
									 			within
									 				((
									 				 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									 				   i0::D__(id__,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									 				   [| { share__, terminate } |] (
									 				   CheckConfidence::D__(id__,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									 				   [| { share__, terminate } |] (
									 				   f0::D__(id__,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									 				   )
									 				   )
									 				 )
									 				 [[CheckConfidence::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CheckConfidence,internal__.NID_CheckConfidence|}]]
									 				 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 				 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 				 )
									 				  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 				  [[set_i <- setL_i]]
									 				 )
									 				 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 				 			,setL_i
									 				|}) |]
									 				 ((i0::enter -> Transitions(id__,
									 				 		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									 				 		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									 				 		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
									 				  [[ share__ <- x__ | x__ <- {| share__,setL_i |} ]]
									 				 )
									 				)[[setL_i <- set_i]]
									 				)
									 			)
									 			 \ hideSet)
									 			[[
									 				anomalyFound__.x____ <- anomalyFound,
									 				processedData__.x____ <- processedData,
									 				adaptationCompleted__.x____ <- adaptationCompleted,
									 				imagesWithPoorLight__.x____ <- imagesWithPoorLight,
									 				get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight,
									 				set_imagesWithPoorLight__.x____ <- set_imagesWithPoorLight,
									 				imagesWithLight__.x____ <- imagesWithLight,
									 				get_imagesWithLight__.x____ <- get_imagesWithLight
									 				| x____ <- NIDS
									 			]]
									 		)
									 		[| {|get_CLID_CheckConfidence,CheckConfidence::entered,terminate|} |]
									 		dbisim(Clock_CLID_CheckConfidence(id__,0,
									 				          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									 				          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									 				          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
									 	)\{|get_CLID_CheckConfidence|}
									 )
									 ))
									  [[ share__ <- x__ | x__ <- {| share__,setR_light,setR_imagesWithLight_var,setR_currentModel,setR_i,setR_anomalyDetected,setR_data,setR_awaitingAdaptation,setR_model,setR_imagesWithPoorLight_var,setR_image |} ]] 
									  [[set_light <- setL_light,set_imagesWithLight_var <- setL_imagesWithLight_var,set_currentModel <- setL_currentModel,set_i <- setL_i,set_anomalyDetected <- setL_anomalyDetected,set_data <- setL_data,set_awaitingAdaptation <- setL_awaitingAdaptation,set_model <- setL_model,set_imagesWithPoorLight_var <- setL_imagesWithPoorLight_var,set_image <- setL_image]]
									 )
									 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
									 			,setL_light
									 			,setL_imagesWithLight_var
									 			,setL_currentModel
									 			,setL_i
									 			,setL_anomalyDetected
									 			,setL_data
									 			,setL_awaitingAdaptation
									 			,setL_model
									 			,setL_imagesWithPoorLight_var
									 			,setL_image
									 			,setR_light
									 			 			,setR_imagesWithLight_var
									 			 			,setR_currentModel
									 			 			,setR_i
									 			 			,setR_anomalyDetected
									 			 			,setR_data
									 			 			,setR_awaitingAdaptation
									 			 			,setR_model
									 			 			,setR_imagesWithPoorLight_var
									 			 			,setR_image
									 			|}) |]
									 ((During)
									  [[ share__ <- x__ | x__ <- {| share__,setL_light,setL_imagesWithLight_var,setL_currentModel,setL_i,setL_anomalyDetected,setL_data,setL_awaitingAdaptation,setL_model,setL_imagesWithPoorLight_var,setL_image |} ]]
									  [[set_light <- setR_light,set_imagesWithLight_var <- setR_imagesWithLight_var,set_currentModel <- setR_currentModel,set_i <- setR_i,set_anomalyDetected <- setR_anomalyDetected,set_data <- setR_data,set_awaitingAdaptation <- setR_awaitingAdaptation,set_model <- setR_model,set_imagesWithPoorLight_var <- setR_imagesWithPoorLight_var,set_image <- setR_image]]
									 )
									)[[setL_light <- set_light,setL_imagesWithLight_var <- set_imagesWithLight_var,setL_currentModel <- set_currentModel,setL_i <- set_i,setL_anomalyDetected <- set_anomalyDetected,setL_data <- set_data,setL_awaitingAdaptation <- set_awaitingAdaptation,setL_model <- set_model,setL_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setL_image <- set_image]]
									 [[setR_light <- set_light,setR_imagesWithLight_var <- set_imagesWithLight_var,setR_currentModel <- set_currentModel,setR_i <- set_i,setR_anomalyDetected <- set_anomalyDetected,setR_data <- set_data,setR_awaitingAdaptation <- set_awaitingAdaptation,setR_model <- set_model,setR_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setR_image <- set_image]]
									)\union(enteredSS,{terminate}) 
								)
								During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
										 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(get_imagesWithLight.out -> SKIP));true&(share__choice(imagesWithLight.in?imagesWithLight_var -> (SStop /\ set_imagesWithLight_var!imagesWithLight_var -> SKIP)));share__choice(share__choice(get_data?data -> true & (share__choice(set_currentModel!tuple3_3(data) -> SKIP))));share__choice(true & (share__choice(set_imagesWithPoorLight_var!<> -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
							
								Behaviour 	= dbisim(
									((
									 (((dbisim(
									 	sbisim(
									 		(let
									 			-- IMPLEMENTATION NOTE:
									 			-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
									 			-- modules for defining the semantics of each node.
									 			enterSS = {|
									 			i0::enter,
									 			CheckConfidence::enter,
									 			f0::enter
									 			|}
									 			hideSet = union(enterSS,{|exit,exited,internal__|})
									 		within 
									 			((let
									 				-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									 				-- because CSPM modules are used for the semantics of Node.
									 				flowevts = union(enterSS,{|exit,exited,interrupt|})
									 				transSync = {|internal__.NID_i0,internal__.NID_CheckConfidence,internal__.NID_CheckConfidence|}
									 			within
									 				((
									 				 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									 				   i0::VS_O__(id__,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									 				   [| { share__, terminate } |] (
									 				   CheckConfidence::VS_O__(id__,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									 				   [| { share__, terminate } |] (
									 				   f0::VS_O__(id__,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									 				   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									 				   )
									 				   )
									 				 )
									 				 [[CheckConfidence::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CheckConfidence,internal__.NID_CheckConfidence|}]]
									 				 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 				 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 				 )
									 				  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 				  [[set_i <- setL_i]]
									 				 )
									 				 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 				 			,setL_i
									 				|}) |]
									 				 ((i0::enter -> Transitions(id__,
									 				 		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									 				 		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									 				 		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
									 				  [[ share__ <- x__ | x__ <- {| share__,setL_i |} ]]
									 				 )
									 				)[[setL_i <- set_i]]
									 				)
									 			)
									 			 \ hideSet)
									 			[[
									 				anomalyFound__.x____ <- anomalyFound,
									 				processedData__.x____ <- processedData,
									 				adaptationCompleted__.x____ <- adaptationCompleted,
									 				imagesWithPoorLight__.x____ <- imagesWithPoorLight,
									 				get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight,
									 				set_imagesWithPoorLight__.x____ <- set_imagesWithPoorLight,
									 				imagesWithLight__.x____ <- imagesWithLight,
									 				get_imagesWithLight__.x____ <- get_imagesWithLight
									 				| x____ <- NIDS
									 			]]
									 		)
									 		[| {|get_CLID_CheckConfidence,CheckConfidence::entered,terminate|} |]
									 		dbisim(Clock_CLID_CheckConfidence(id__,0,
									 				          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									 				          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									 				          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
									 	)\{|get_CLID_CheckConfidence|}
									 )
									 ))
									  [[ share__ <- x__ | x__ <- {| share__,setR_light,setR_imagesWithLight_var,setR_currentModel,setR_i,setR_anomalyDetected,setR_data,setR_awaitingAdaptation,setR_model,setR_imagesWithPoorLight_var,setR_image |} ]] 
									  [[set_light <- setL_light,set_imagesWithLight_var <- setL_imagesWithLight_var,set_currentModel <- setL_currentModel,set_i <- setL_i,set_anomalyDetected <- setL_anomalyDetected,set_data <- setL_data,set_awaitingAdaptation <- setL_awaitingAdaptation,set_model <- setL_model,set_imagesWithPoorLight_var <- setL_imagesWithPoorLight_var,set_image <- setL_image]]
									 )
									 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
									 			,setL_light
									 			,setL_imagesWithLight_var
									 			,setL_currentModel
									 			,setL_i
									 			,setL_anomalyDetected
									 			,setL_data
									 			,setL_awaitingAdaptation
									 			,setL_model
									 			,setL_imagesWithPoorLight_var
									 			,setL_image
									 			,setR_light
									 			 			,setR_imagesWithLight_var
									 			 			,setR_currentModel
									 			 			,setR_i
									 			 			,setR_anomalyDetected
									 			 			,setR_data
									 			 			,setR_awaitingAdaptation
									 			 			,setR_model
									 			 			,setR_imagesWithPoorLight_var
									 			 			,setR_image
									 			|}) |]
									 ((During)
									  [[ share__ <- x__ | x__ <- {| share__,setL_light,setL_imagesWithLight_var,setL_currentModel,setL_i,setL_anomalyDetected,setL_data,setL_awaitingAdaptation,setL_model,setL_imagesWithPoorLight_var,setL_image |} ]]
									  [[set_light <- setR_light,set_imagesWithLight_var <- setR_imagesWithLight_var,set_currentModel <- setR_currentModel,set_i <- setR_i,set_anomalyDetected <- setR_anomalyDetected,set_data <- setR_data,set_awaitingAdaptation <- setR_awaitingAdaptation,set_model <- setR_model,set_imagesWithPoorLight_var <- setR_imagesWithPoorLight_var,set_image <- setR_image]]
									 )
									)[[setL_light <- set_light,setL_imagesWithLight_var <- set_imagesWithLight_var,setL_currentModel <- set_currentModel,setL_i <- set_i,setL_anomalyDetected <- set_anomalyDetected,setL_data <- set_data,setL_awaitingAdaptation <- set_awaitingAdaptation,setL_model <- set_model,setL_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setL_image <- set_image]]
									 [[setR_light <- set_light,setR_imagesWithLight_var <- set_imagesWithLight_var,setR_currentModel <- set_currentModel,setR_i <- set_i,setR_anomalyDetected <- set_anomalyDetected,setR_data <- set_data,setR_awaitingAdaptation <- set_awaitingAdaptation,setR_model <- set_model,setR_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setR_image <- set_image]]
									)\{terminate} 
								)
								During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
										 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
							within
								Inactive [| {terminate} |> SKIP)
							
							Transitions(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = ((let
								Trans = share__choice(get_i?i -> TimeOut_1(
									 (share__ -> SKIP
									 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(share__choice(get_imagesWithLight_var?imagesWithLight_var -> pre_sequence_toolkit_size(imagesWithLight_var) & (share__choice(set_i!length(imagesWithLight_var) -> SKIP)))) ; CheckConfidence::enter -> SKIP))))
									 [] dbisim(((i>0))&(internal__!NID_CheckConfidence -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; CheckConfidence::enter -> SKIP)))
									 [] dbisim(((i<=0))&(internal__!NID_CheckConfidence -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; f0::enter -> SKIP)))
									 []
									 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
									 []
									 terminate -> SKIP
									 )
								,SKIP);Trans
								)
							within
								Trans [|{terminate}|> SKIP
							)
							)
							
							
							-- Clocks
							Clock_CLID_CheckConfidence(id__,x__,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
								TimeOut_1(
									CheckConfidence::entered -> Clock_CLID_CheckConfidence(id__,0,
											          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
											          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
											          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									[]
									get_CLID_CheckConfidence!x__ -> Clock_CLID_CheckConfidence(id__,x__,
											          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
											          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
											          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									[]
									terminate -> SKIP,Clock_CLID_CheckConfidence(id__,clock_type_plus(x__,1,CLID_CheckConfidence_clock_type(id__,
											          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
											          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
											          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)),
											          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
											          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
											          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
							
							StateClocks(id__,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = dbisim(Clock_CLID_CheckConfidence(id__,0,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
							
							stateClockSync = {|get_CLID_CheckConfidence,CheckConfidence::entered|}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: AnalysisComplete
					module AnalysisComplete
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_imagesWithPoorLight_var?imagesWithPoorLight_var -> true&(if (length(imagesWithPoorLight_var)>0) then (share__choice(true & (share__choice(set_anomalyDetected!true -> SKIP)));share__choice(get_imagesWithPoorLight_var?imagesWithPoorLight_var -> true&(share__choice(set_imagesWithPoorLight.out!imagesWithPoorLight_var -> SKIP))))else SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_imagesWithPoorLight_var?imagesWithPoorLight_var -> true&(if (length(imagesWithPoorLight_var)>0) then (share__choice(true & (share__choice(set_anomalyDetected!true -> SKIP)));share__choice(get_imagesWithPoorLight_var?imagesWithPoorLight_var -> true&(share__choice(set_imagesWithPoorLight.out!imagesWithPoorLight_var -> SKIP))))else SKIP)) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
										    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
								    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
								    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
					)\sharedVarHide
					
					STM_VS_O(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
										    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
								    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
								    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
					)\sharedVarHide
					
					-- Transitions
					Transitions(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = ((let
						Trans = share__choice(get_anomalyDetected?anomalyDetected -> TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; Initialise::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_Initialise -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForData::enter -> SKIP)))
							 [] dbisim((true)&(adaptationCompleted__!NID_WaitForData.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_awaitingAdaptation!false -> SKIP))) ; WaitForData::enter -> SKIP)))
							 [] dbisim((true)&(processedData__!NID_WaitForData.in?data:{data|data <- {(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat}, true} -> share__choice(set_data!data -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; AnalyseAnomaly::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_AnalyseAnomaly -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; AnalysisComplete::enter -> SKIP)))
							 [] dbisim((anomalyDetected)&(internal__!NID_AnalysisComplete -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(anomalyFound.out -> SKIP));share__choice(true & (share__choice(set_awaitingAdaptation!true -> SKIP))) ; WaitForData::enter -> SKIP)))
							 [] dbisim(((not (anomalyDetected)))&(internal__!NID_AnalysisComplete -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForData::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
						)
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Initialise::enter,
								WaitForData::enter,
								AnalyseAnomaly::enter,
								AnalysisComplete::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_Initialise,adaptationCompleted__.NID_WaitForData.in,processedData__.NID_WaitForData.in,internal__.NID_AnalyseAnomaly,internal__.NID_AnalysisComplete,internal__.NID_AnalysisComplete|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									   [| { share__, terminate } |] (
									   Initialise::D__(id__,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									   [| { share__, terminate } |] (
									   WaitForData::D__(id__,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									   [| { share__, terminate } |] (
									   AnalyseAnomaly::D__(id__,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									   [| { share__, terminate } |] (
									   AnalysisComplete::D__(id__,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									   )
									   )
									   )
									   )
									 )
									 [[Initialise::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialise|}]]
									 [[WaitForData::interrupt <- x__ | x__ <- {|interrupt,adaptationCompleted__.NID_WaitForData.in,processedData__.NID_WaitForData.in|}]]
									 [[AnalyseAnomaly::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_AnalyseAnomaly|}]]
									 [[AnalysisComplete::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_AnalysisComplete,internal__.NID_AnalysisComplete|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_data |} ]] 
									  [[set_anomalyDetected <- setL_anomalyDetected]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_anomalyDetected
									 			,setR_data
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									 		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									 		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
									  [[ share__ <- x__ | x__ <- {| share__,setL_anomalyDetected |} ]]
									  [[set_data <- setR_data]]
									 )
									)[[setL_anomalyDetected <- set_anomalyDetected]]
									 [[setR_data <- set_data]]
									)
								)
								 \ hideSet)
								[[
									anomalyFound__.x____ <- anomalyFound,
									processedData__.x____ <- processedData,
									adaptationCompleted__.x____ <- adaptationCompleted,
									imagesWithPoorLight__.x____ <- imagesWithPoorLight,
									get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight,
									set_imagesWithPoorLight__.x____ <- set_imagesWithPoorLight,
									imagesWithLight__.x____ <- imagesWithLight,
									get_imagesWithLight__.x____ <- get_imagesWithLight
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							 		          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							 		          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
						dbisim((let
							stateClockSync = {|get_CLID_AnalyseAnomaly,AnalyseAnomaly::entered,get_CLID_AnalysisComplete,AnalysisComplete::entered,get_CLID_WaitForData,WaitForData::entered,get_CLID_Initialise,Initialise::entered|}
						 within
							(MachineBody(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
						dbisim((let
							stateClockSync = {|get_CLID_AnalyseAnomaly,AnalyseAnomaly::entered,get_CLID_AnalysisComplete,AnalysisComplete::entered,get_CLID_WaitForData,WaitForData::entered,get_CLID_Initialise,Initialise::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody(id__,
																	    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
																	    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
																	    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
															[| {|get_CLID_Initialise,Initialise::entered,terminate|} |]
															dbisim(Clock_CLID_Initialise(id__,0,
																	          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
																	          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
																	          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
														)\{|get_CLID_Initialise|}
													)
													[| {|get_CLID_WaitForData,WaitForData::entered,terminate|} |]
													dbisim(Clock_CLID_WaitForData(id__,0,
															          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
															          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
															          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
												)\{|get_CLID_WaitForData|}
											)
											[| {|get_CLID_AnalysisComplete,AnalysisComplete::entered,terminate|} |]
											dbisim(Clock_CLID_AnalysisComplete(id__,0,
													          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
													          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
													          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
										)\{|get_CLID_AnalysisComplete|}
									)
									[| {|get_CLID_AnalyseAnomaly,AnalyseAnomaly::entered,terminate|} |]
									dbisim(Clock_CLID_AnalyseAnomaly(id__,0,
											          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
											          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
											          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
								)\{|get_CLID_AnalyseAnomaly|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
						((let
							getsetLocalChannels = {|get_data,set_data,
							get_anomalyDetected,set_anomalyDetected,
							get_awaitingAdaptation,set_awaitingAdaptation,
							get_currentModel,set_currentModel,
							get_i,set_i,
							get_image,set_image,
							get_light,set_light,
							get_model,set_model,
							get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,
							get_imagesWithLight_var,set_imagesWithLight_var|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							 		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							 		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) [| {terminate} |] Clocks(id__,
							 		          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							 		          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							 		          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				dbisim(
																					sbisim(
																						dbisim(
																							sbisim(
																								dbisim(
																									sbisim(
																										IteratedBehaviour(id__,
																												    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
																												    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
																												    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
																										[| {|get_imagesWithLight_var,set_imagesWithLight_var,terminate|} |]
																										Memory_imagesWithLight_var(<>)
																									)\{|get_imagesWithLight_var,set_imagesWithLight_var|}
																								)
																								[| {|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,terminate|} |]
																								Memory_imagesWithPoorLight_var(<>)
																							)\{|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
																						)
																						[| {|get_model,set_model,terminate|} |]
																						Memory_model(0)
																					)\{|get_model,set_model|}
																				)
																				[| {|get_light,set_light,terminate|} |]
																				Memory_light(0)
																			)\{|get_light,set_light|}
																		)
																		[| {|get_image,set_image,terminate|} |]
																		Memory_image(((0,0,0),(0,0,0),(<>,0,0),<>))
																	)\{|get_image,set_image|}
																)
																[| {|get_i,set_i,terminate|} |]
																Memory_i(0)
															)\{|get_i,set_i|}
														)
														[| {|get_currentModel,set_currentModel,terminate|} |]
														Memory_currentModel(0)
													)\{|get_currentModel,set_currentModel|}
												)
												[| {|get_awaitingAdaptation,set_awaitingAdaptation,terminate|} |]
												Memory_awaitingAdaptation(true)
											)\{|get_awaitingAdaptation,set_awaitingAdaptation|}
										)
										[| {|get_anomalyDetected,set_anomalyDetected,terminate|} |]
										Memory_anomalyDetected(true)
									)\{|get_anomalyDetected,set_anomalyDetected|}
								)
								[| {|get_data,set_data,terminate|} |]
								Memory_data((((0,0,0),(0,0,0),(<>,0,0),<>),0,0))
							)\{|get_data,set_data|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Initialise::enter,
								WaitForData::enter,
								AnalyseAnomaly::enter,
								AnalysisComplete::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_Initialise,adaptationCompleted__.NID_WaitForData.in,processedData__.NID_WaitForData.in,internal__.NID_AnalyseAnomaly,internal__.NID_AnalysisComplete,internal__.NID_AnalysisComplete|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									   [| { share__, terminate } |] (
									   Initialise::VS_O__(id__,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									   [| { share__, terminate } |] (
									   WaitForData::VS_O__(id__,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									   [| { share__, terminate } |] (
									   AnalyseAnomaly::VS_O__(id__,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									   [| { share__, terminate } |] (
									   AnalysisComplete::VS_O__(id__,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									   		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
									   )
									   )
									   )
									   )
									 )
									 [[Initialise::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialise|}]]
									 [[WaitForData::interrupt <- x__ | x__ <- {|interrupt,adaptationCompleted__.NID_WaitForData.in,processedData__.NID_WaitForData.in|}]]
									 [[AnalyseAnomaly::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_AnalyseAnomaly|}]]
									 [[AnalysisComplete::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_AnalysisComplete,internal__.NID_AnalysisComplete|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_data |} ]] 
									  [[set_anomalyDetected <- setL_anomalyDetected]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_anomalyDetected
									 			,setR_data
									 			|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									 		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									 		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
									  [[ share__ <- x__ | x__ <- {| share__,setL_anomalyDetected |} ]]
									  [[set_data <- setR_data]]
									 )
									)[[setL_anomalyDetected <- set_anomalyDetected]]
									 [[setR_data <- set_data]]
									)
								)
								 \ hideSet)
								[[
									anomalyFound__.x____ <- anomalyFound,
									processedData__.x____ <- processedData,
									adaptationCompleted__.x____ <- adaptationCompleted,
									imagesWithPoorLight__.x____ <- imagesWithPoorLight,
									get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight,
									set_imagesWithPoorLight__.x____ <- set_imagesWithPoorLight,
									imagesWithLight__.x____ <- imagesWithLight,
									get_imagesWithLight__.x____ <- get_imagesWithLight
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							 		          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							 		          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
						dbisim((let
							stateClockSync = {|get_CLID_AnalyseAnomaly,AnalyseAnomaly::entered,get_CLID_AnalysisComplete,AnalysisComplete::entered,get_CLID_WaitForData,WaitForData::entered,get_CLID_Initialise,Initialise::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
						dbisim((let
							stateClockSync = {|get_CLID_AnalyseAnomaly,AnalyseAnomaly::entered,get_CLID_AnalysisComplete,AnalysisComplete::entered,get_CLID_WaitForData,WaitForData::entered,get_CLID_Initialise,Initialise::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody_VS_O(id__,
																	    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
																	    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
																	    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
															[| {|get_CLID_Initialise,Initialise::entered,terminate|} |]
															dbisim(Clock_CLID_Initialise(id__,0,
																	          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
																	          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
																	          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
														)\{|get_CLID_Initialise|}
													)
													[| {|get_CLID_WaitForData,WaitForData::entered,terminate|} |]
													dbisim(Clock_CLID_WaitForData(id__,0,
															          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
															          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
															          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
												)\{|get_CLID_WaitForData|}
											)
											[| {|get_CLID_AnalysisComplete,AnalysisComplete::entered,terminate|} |]
											dbisim(Clock_CLID_AnalysisComplete(id__,0,
													          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
													          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
													          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
										)\{|get_CLID_AnalysisComplete|}
									)
									[| {|get_CLID_AnalyseAnomaly,AnalyseAnomaly::entered,terminate|} |]
									dbisim(Clock_CLID_AnalyseAnomaly(id__,0,
											          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
											          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
											          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
								)\{|get_CLID_AnalyseAnomaly|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
						dbisim((let
							getsetLocalChannels = {|get_data,set_data,
							get_anomalyDetected,set_anomalyDetected,
							get_awaitingAdaptation,set_awaitingAdaptation,
							get_currentModel,set_currentModel,
							get_i,set_i,
							get_image,set_image,
							get_light,set_light,
							get_model,set_model,
							get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,
							get_imagesWithLight_var,set_imagesWithLight_var|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							 		    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							 		    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) [| {terminate} |] Clocks(id__,
							 		          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							 		          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							 		          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				dbisim(
																					sbisim(
																						dbisim(
																							sbisim(
																								dbisim(
																									sbisim(
																										IteratedBehaviour_VS_O(id__,
																												    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
																												    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
																												    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
																										[| {|get_imagesWithLight_var,set_imagesWithLight_var,terminate|} |]
																										Memory_imagesWithLight_var(<>)
																									)\{|get_imagesWithLight_var,set_imagesWithLight_var|}
																								)
																								[| {|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,terminate|} |]
																								Memory_imagesWithPoorLight_var(<>)
																							)\{|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
																						)
																						[| {|get_model,set_model,terminate|} |]
																						Memory_model(0)
																					)\{|get_model,set_model|}
																				)
																				[| {|get_light,set_light,terminate|} |]
																				Memory_light(0)
																			)\{|get_light,set_light|}
																		)
																		[| {|get_image,set_image,terminate|} |]
																		Memory_image(((0,0,0),(0,0,0),(<>,0,0),<>))
																	)\{|get_image,set_image|}
																)
																[| {|get_i,set_i,terminate|} |]
																Memory_i(0)
															)\{|get_i,set_i|}
														)
														[| {|get_currentModel,set_currentModel,terminate|} |]
														Memory_currentModel(0)
													)\{|get_currentModel,set_currentModel|}
												)
												[| {|get_awaitingAdaptation,set_awaitingAdaptation,terminate|} |]
												Memory_awaitingAdaptation(true)
											)\{|get_awaitingAdaptation,set_awaitingAdaptation|}
										)
										[| {|get_anomalyDetected,set_anomalyDetected,terminate|} |]
										Memory_anomalyDetected(true)
									)\{|get_anomalyDetected,set_anomalyDetected|}
								)
								[| {|get_data,set_data,terminate|} |]
								Memory_data((((0,0,0),(0,0,0),(<>,0,0),<>),0,0))
							)\{|get_data,set_data|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_data(data) =
						get_data!data -> Memory_data(data)
						[]
						set_data?x__ -> Memory_data(x__)
						[]
						terminate -> SKIP
					Memory_anomalyDetected(anomalyDetected) =
						get_anomalyDetected!anomalyDetected -> Memory_anomalyDetected(anomalyDetected)
						[]
						set_anomalyDetected?x__ -> Memory_anomalyDetected(x__)
						[]
						terminate -> SKIP
					Memory_awaitingAdaptation(awaitingAdaptation) =
						get_awaitingAdaptation!awaitingAdaptation -> Memory_awaitingAdaptation(awaitingAdaptation)
						[]
						set_awaitingAdaptation?x__ -> Memory_awaitingAdaptation(x__)
						[]
						terminate -> SKIP
					Memory_currentModel(currentModel) =
						get_currentModel!currentModel -> Memory_currentModel(currentModel)
						[]
						set_currentModel?x__ -> Memory_currentModel(x__)
						[]
						terminate -> SKIP
					Memory_i(i) =
						get_i!i -> Memory_i(i)
						[]
						set_i?x__ -> Memory_i(x__)
						[]
						terminate -> SKIP
					Memory_image(image) =
						get_image!image -> Memory_image(image)
						[]
						set_image?x__ -> Memory_image(x__)
						[]
						terminate -> SKIP
					Memory_light(light) =
						get_light!light -> Memory_light(light)
						[]
						set_light?x__ -> Memory_light(x__)
						[]
						terminate -> SKIP
					Memory_model(model) =
						get_model!model -> Memory_model(model)
						[]
						set_model?x__ -> Memory_model(x__)
						[]
						terminate -> SKIP
					Memory_imagesWithPoorLight_var(imagesWithPoorLight_var) =
						get_imagesWithPoorLight_var!imagesWithPoorLight_var -> Memory_imagesWithPoorLight_var(imagesWithPoorLight_var)
						[]
						set_imagesWithPoorLight_var?x__ -> Memory_imagesWithPoorLight_var(x__)
						[]
						terminate -> SKIP
					Memory_imagesWithLight_var(imagesWithLight_var) =
						get_imagesWithLight_var!imagesWithLight_var -> Memory_imagesWithLight_var(imagesWithLight_var)
						[]
						set_imagesWithLight_var?x__ -> Memory_imagesWithLight_var(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = Memory_data((((0,0,0),(0,0,0),(<>,0,0),<>),0,0))
					[| { terminate } |] (
					Memory_anomalyDetected(true)
					[| { terminate } |] (
					Memory_awaitingAdaptation(true)
					[| { terminate } |] (
					Memory_currentModel(0)
					[| { terminate } |] (
					Memory_i(0)
					[| { terminate } |] (
					Memory_image(((0,0,0),(0,0,0),(<>,0,0),<>))
					[| { terminate } |] (
					Memory_light(0)
					[| { terminate } |] (
					Memory_model(0)
					[| { terminate } |] (
					Memory_imagesWithPoorLight_var(<>)
					[| { terminate } |] (
					Memory_imagesWithLight_var(<>)
					)
					)
					)
					)
					)
					)
					)
					)
					)
					
					getsetLocalChannels = {|get_data,set_data,get_anomalyDetected,set_anomalyDetected,get_awaitingAdaptation,set_awaitingAdaptation,get_currentModel,set_currentModel,get_i,set_i,get_image,set_image,get_light,set_light,get_model,set_model,get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,get_imagesWithLight_var,set_imagesWithLight_var|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = STM_VS_O(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) \ localClockResets
					D__(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = timed_priority(STM(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) \ union(internal_events,localClockResets))
					O__(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = dbisim(D__(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
					VS__(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = FVS__(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
					VS_O__(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = dbisim(FVS__(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
					HEXT__(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = O__(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = dbisim(timed_priority(STM(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) \ internal_events))
					HUP__(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = timed_priority(O__(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_AnalyseAnomaly(id__,x__,
							          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
						TimeOut_1(
							AnalyseAnomaly::entered -> Clock_CLID_AnalyseAnomaly(id__,0,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
							[]
							get_CLID_AnalyseAnomaly!x__ -> Clock_CLID_AnalyseAnomaly(id__,x__,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
							[]
							terminate -> SKIP,Clock_CLID_AnalyseAnomaly(id__,clock_type_plus(x__,1,CLID_AnalyseAnomaly_clock_type(id__,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)),
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
					Clock_CLID_AnalysisComplete(id__,x__,
							          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
						TimeOut_1(
							AnalysisComplete::entered -> Clock_CLID_AnalysisComplete(id__,0,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
							[]
							get_CLID_AnalysisComplete!x__ -> Clock_CLID_AnalysisComplete(id__,x__,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
							[]
							terminate -> SKIP,Clock_CLID_AnalysisComplete(id__,clock_type_plus(x__,1,CLID_AnalysisComplete_clock_type(id__,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)),
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
					Clock_CLID_WaitForData(id__,x__,
							          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
						TimeOut_1(
							WaitForData::entered -> Clock_CLID_WaitForData(id__,0,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
							[]
							get_CLID_WaitForData!x__ -> Clock_CLID_WaitForData(id__,x__,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
							[]
							terminate -> SKIP,Clock_CLID_WaitForData(id__,clock_type_plus(x__,1,CLID_WaitForData_clock_type(id__,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)),
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
					Clock_CLID_Initialise(id__,x__,
							          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = 
						TimeOut_1(
							Initialise::entered -> Clock_CLID_Initialise(id__,0,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
							[]
							get_CLID_Initialise!x__ -> Clock_CLID_Initialise(id__,x__,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)
							[]
							terminate -> SKIP,Clock_CLID_Initialise(id__,clock_type_plus(x__,1,CLID_Initialise_clock_type(id__,
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)),
									          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
									          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
									          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
					
					StateClocks(id__,
							          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = dbisim(Clock_CLID_AnalyseAnomaly(id__,0,
							          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
					[| { terminate } |] (
					dbisim(Clock_CLID_AnalysisComplete(id__,0,
							          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
					[| { terminate } |] (
					dbisim(Clock_CLID_WaitForData(id__,0,
							          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
					[| { terminate } |] (
					dbisim(Clock_CLID_Initialise(id__,0,
							          const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							          const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							          const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD))
					)
					)
					)
					
					stateClockSync = {|get_CLID_AnalyseAnomaly,AnalyseAnomaly::entered,get_CLID_AnalysisComplete,AnalysisComplete::entered,get_CLID_WaitForData,WaitForData::entered,get_CLID_Initialise,Initialise::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
							    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref3
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Initialise|
				              NID_WaitForSignal|
				              NID_PerformVerification
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_planLegitimated, set_planLegitimated, setL_planLegitimated, setR_planLegitimated: core_boolean
				channel get_i, set_i, setL_i, setR_i: core_nat
				channel get_imagesWithLight_var, set_imagesWithLight_var, setL_imagesWithLight_var, setR_imagesWithLight_var: LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel get_imagesWithPoorLight_var, set_imagesWithPoorLight_var, setL_imagesWithPoorLight_var, setR_imagesWithPoorLight_var: LSeq(core_nat,2)
				channel get_newModel_var, set_newModel_var, setL_newModel_var, setR_newModel_var: core_nat
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel verifyPlan__: NIDS.InOut
				channel verifyPlan: InOut
				channel planAccepted__: NIDS.InOut
				channel planAccepted: InOut
				channel planRejected__: NIDS.InOut
				channel planRejected: InOut
				channel newConfidences__: NIDS.InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
				channel newConfidences: InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
				channel get_newConfidences__: NIDS.InOut
				channel get_newConfidences: InOut
				channel set_newConfidences__: NIDS.InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
				channel set_newConfidences: InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
				channel imagesWithLight__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel imagesWithLight: InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel get_imagesWithLight__: NIDS.InOut
				channel get_imagesWithLight: InOut
				channel imagesWithPoorLight__: NIDS.InOut.LSeq(core_nat,2)
				channel imagesWithPoorLight: InOut.LSeq(core_nat,2)
				channel get_imagesWithPoorLight__: NIDS.InOut
				channel get_imagesWithPoorLight: InOut
				channel newModel__: NIDS.InOut.core_nat
				channel newModel: InOut.core_nat
				channel get_newModel__: NIDS.InOut
				channel get_newModel: InOut
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				Initialise::enter,
				WaitForSignal::enter,
				PerformVerification::enter
				|}
				
				enteredSS = 	{|
				Initialise::entered,
				WaitForSignal::entered,
				PerformVerification::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	verifyPlan,
					planAccepted,
					planRejected,
					newConfidences,
					get_newConfidences,
					set_newConfidences,
					imagesWithLight,
					get_imagesWithLight,
					imagesWithPoorLight,
					get_imagesWithPoorLight,
					newModel,
					get_newModel
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_Initialise : core_clock_type 
				channel get_CLID_PerformVerification : core_clock_type 
				channel get_CLID_WaitForSignal : core_clock_type 
				--channel increment__
				
				CLID_Initialise_clock_type(id__,
						          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_PerformVerification_clock_type(id__,
						          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_WaitForSignal_clock_type(id__,
						          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = D__(id__,
									    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Initialise
					module Initialise
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: WaitForSignal
					module WaitForSignal
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: PerformVerification
					module PerformVerification
					
					enterSS = 
							{|			i0::enter,
								CheckImages::enter,
								f0::enter
							|}
					enteredSS = 
							{|			CheckImages::entered,
								f0::entered
							|}
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						-- declaring identifiers of transitions
						datatype NIDS = 
						              NID_i0|
						              NID_CheckImages|
						              NID_f0
						
						channel internal__ : NIDS
						channel verifyPlan__: NIDS.InOut
						channel planAccepted__: NIDS.InOut
						channel planRejected__: NIDS.InOut
						channel newConfidences__: NIDS.InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
						channel get_newConfidences__: NIDS.InOut
						channel set_newConfidences__: NIDS.InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
						channel imagesWithLight__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
						channel get_imagesWithLight__: NIDS.InOut
						channel imagesWithPoorLight__: NIDS.InOut.LSeq(core_nat,2)
						channel get_imagesWithPoorLight__: NIDS.InOut
						channel newModel__: NIDS.InOut.core_nat
						channel get_newModel__: NIDS.InOut
						
						channel get_CLID_CheckImages : core_clock_type 
						--channel increment__
						
						CLID_CheckImages_clock_type(id__,
								          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
							let
								max = (clock_type_max(Union({
						{}
						}))+1)
							ctype = {0..max}
						within
							if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
						
						
						--	Nodes
						-- declaring all nodes
						
						----------------------------------------------------------------------
						-- Initial: i0
						module i0
						exports
						
							channel enter, interrupt
							
							Timed(OneStep) {
								D__(id__,
										    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
									dbisim(let
										Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
										
										Termination = terminate -> SKIP
										
										Active 		= share__choice(interrupt -> SKIP) ; Inactive
									within
										Inactive [| {terminate} |> SKIP)
								
								VS_O__(id__,
										    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = D__(id__,
										    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- State: CheckImages
						module CheckImages
						
						enterSS = {}
						
						enteredSS = {}
						
						exports
						
							--  Declarations
							
							channel enter, entered, interrupt
							channel enteredL, enteredR
							
											
							
							--channel increment__
							
							
							--	Nodes
							-- declaring all nodes
							
							
							Timed(OneStep) {
								--	Rule: behaviours(Node)
								--  Note that FDR has problems with efficiently compiling the process below
								-- 	if using a different recursion pattern.
								D__(id__,
										    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
								dbisim(let
									-- IMPLEMENTATION NOTE: 
									-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
									-- however FDR struggles with that form in certain cases. So we use the exception operator
									-- instead to 'terminate'.
									
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= SKIP ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
									
								VS_O__(id__,
										    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= SKIP ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
								
								
								-- Clocks
								
								StateClocks(id__,
										          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = terminate -> SKIP
								
								stateClockSync = {||}
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- Final state: f0
						module f0
						
						exports
						
							channel enter, entered, interrupt
							channel enteredL, enteredR
							
							Timed(OneStep) {
								--	Rule: behaviours(Node)
								D__(id__,
										    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
									dbisim(let
										Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
										
										Entering 	= entered -> SKIP ; Active
										Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
										Interrupted	= share__choice(exit -> exited -> Inactive)
									within
										Inactive [| {terminate} |> SKIP)
									
								VS_O__(id__,
										    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = D__(id__,
										    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(get_imagesWithLight.out -> SKIP));true&(share__choice(imagesWithLight.in?imagesWithLight_var -> (SStop /\ set_imagesWithLight_var!imagesWithLight_var -> SKIP)));true&(share__choice(get_imagesWithPoorLight.out -> SKIP));true&(share__choice(imagesWithPoorLight.in?imagesWithPoorLight_var -> (SStop /\ set_imagesWithPoorLight_var!imagesWithPoorLight_var -> SKIP)));true&(share__choice(get_newModel.out -> SKIP));true&(share__choice(newModel.in?newModel_var -> (SStop /\ set_newModel_var!newModel_var -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
							
								Behaviour 	= dbisim(
									((
									 (((dbisim(
									 	sbisim(
									 		(let
									 			-- IMPLEMENTATION NOTE:
									 			-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
									 			-- modules for defining the semantics of each node.
									 			enterSS = {|
									 			i0::enter,
									 			CheckImages::enter,
									 			f0::enter
									 			|}
									 			hideSet = union(enterSS,{|exit,exited,internal__|})
									 		within 
									 			((let
									 				-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									 				-- because CSPM modules are used for the semantics of Node.
									 				flowevts = union(enterSS,{|exit,exited,interrupt|})
									 				transSync = {|internal__.NID_i0,internal__.NID_CheckImages,internal__.NID_CheckImages|}
									 			within
									 				((
									 				 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									 				   i0::D__(id__,
									 				   		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									 				   [| { share__, terminate } |] (
									 				   CheckImages::D__(id__,
									 				   		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									 				   [| { share__, terminate } |] (
									 				   f0::D__(id__,
									 				   		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									 				   )
									 				   )
									 				 )
									 				 [[CheckImages::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CheckImages,internal__.NID_CheckImages|}]]
									 				 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 				 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 				 )
									 				  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 				  [[set_i <- setL_i,set_imagesWithPoorLight_var <- setL_imagesWithPoorLight_var]]
									 				 )
									 				 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 				 			,setL_i
									 				 			,setL_imagesWithPoorLight_var
									 				|}) |]
									 				 ((i0::enter -> Transitions(id__,
									 				 		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
									 				  [[ share__ <- x__ | x__ <- {| share__,setL_i,setL_imagesWithPoorLight_var |} ]]
									 				 )
									 				)[[setL_i <- set_i,setL_imagesWithPoorLight_var <- set_imagesWithPoorLight_var]]
									 				)
									 			)
									 			 \ hideSet)
									 			[[
									 				verifyPlan__.x____ <- verifyPlan,
									 				planAccepted__.x____ <- planAccepted,
									 				planRejected__.x____ <- planRejected,
									 				newConfidences__.x____ <- newConfidences,
									 				get_newConfidences__.x____ <- get_newConfidences,
									 				set_newConfidences__.x____ <- set_newConfidences,
									 				imagesWithLight__.x____ <- imagesWithLight,
									 				get_imagesWithLight__.x____ <- get_imagesWithLight,
									 				imagesWithPoorLight__.x____ <- imagesWithPoorLight,
									 				get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight,
									 				newModel__.x____ <- newModel,
									 				get_newModel__.x____ <- get_newModel
									 				| x____ <- NIDS
									 			]]
									 		)
									 		[| {|get_CLID_CheckImages,CheckImages::entered,terminate|} |]
									 		dbisim(Clock_CLID_CheckImages(id__,0,
									 				          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
									 	)\{|get_CLID_CheckImages|}
									 )
									 ))
									  [[ share__ <- x__ | x__ <- {| share__,setR_imagesWithLight_var,setR_planLegitimated,setR_i,setR_imagesWithPoorLight_var,setR_newModel_var |} ]] 
									  [[set_imagesWithLight_var <- setL_imagesWithLight_var,set_planLegitimated <- setL_planLegitimated,set_i <- setL_i,set_imagesWithPoorLight_var <- setL_imagesWithPoorLight_var,set_newModel_var <- setL_newModel_var]]
									 )
									 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
									 			,setL_imagesWithLight_var
									 			,setL_planLegitimated
									 			,setL_i
									 			,setL_imagesWithPoorLight_var
									 			,setL_newModel_var
									 			,setR_imagesWithLight_var
									 			 			,setR_planLegitimated
									 			 			,setR_i
									 			 			,setR_imagesWithPoorLight_var
									 			 			,setR_newModel_var
									 			|}) |]
									 ((During)
									  [[ share__ <- x__ | x__ <- {| share__,setL_imagesWithLight_var,setL_planLegitimated,setL_i,setL_imagesWithPoorLight_var,setL_newModel_var |} ]]
									  [[set_imagesWithLight_var <- setR_imagesWithLight_var,set_planLegitimated <- setR_planLegitimated,set_i <- setR_i,set_imagesWithPoorLight_var <- setR_imagesWithPoorLight_var,set_newModel_var <- setR_newModel_var]]
									 )
									)[[setL_imagesWithLight_var <- set_imagesWithLight_var,setL_planLegitimated <- set_planLegitimated,setL_i <- set_i,setL_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setL_newModel_var <- set_newModel_var]]
									 [[setR_imagesWithLight_var <- set_imagesWithLight_var,setR_planLegitimated <- set_planLegitimated,setR_i <- set_i,setR_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setR_newModel_var <- set_newModel_var]]
									)\union(enteredSS,{terminate}) 
								)
								During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
										 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(get_imagesWithLight.out -> SKIP));true&(share__choice(imagesWithLight.in?imagesWithLight_var -> (SStop /\ set_imagesWithLight_var!imagesWithLight_var -> SKIP)));true&(share__choice(get_imagesWithPoorLight.out -> SKIP));true&(share__choice(imagesWithPoorLight.in?imagesWithPoorLight_var -> (SStop /\ set_imagesWithPoorLight_var!imagesWithPoorLight_var -> SKIP)));true&(share__choice(get_newModel.out -> SKIP));true&(share__choice(newModel.in?newModel_var -> (SStop /\ set_newModel_var!newModel_var -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
							
								Behaviour 	= dbisim(
									((
									 (((dbisim(
									 	sbisim(
									 		(let
									 			-- IMPLEMENTATION NOTE:
									 			-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
									 			-- modules for defining the semantics of each node.
									 			enterSS = {|
									 			i0::enter,
									 			CheckImages::enter,
									 			f0::enter
									 			|}
									 			hideSet = union(enterSS,{|exit,exited,internal__|})
									 		within 
									 			((let
									 				-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									 				-- because CSPM modules are used for the semantics of Node.
									 				flowevts = union(enterSS,{|exit,exited,interrupt|})
									 				transSync = {|internal__.NID_i0,internal__.NID_CheckImages,internal__.NID_CheckImages|}
									 			within
									 				((
									 				 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									 				   i0::VS_O__(id__,
									 				   		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									 				   [| { share__, terminate } |] (
									 				   CheckImages::VS_O__(id__,
									 				   		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									 				   [| { share__, terminate } |] (
									 				   f0::VS_O__(id__,
									 				   		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									 				   )
									 				   )
									 				 )
									 				 [[CheckImages::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CheckImages,internal__.NID_CheckImages|}]]
									 				 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 				 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 				 )
									 				  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 				  [[set_i <- setL_i,set_imagesWithPoorLight_var <- setL_imagesWithPoorLight_var]]
									 				 )
									 				 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 				 			,setL_i
									 				 			,setL_imagesWithPoorLight_var
									 				|}) |]
									 				 ((i0::enter -> Transitions(id__,
									 				 		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
									 				  [[ share__ <- x__ | x__ <- {| share__,setL_i,setL_imagesWithPoorLight_var |} ]]
									 				 )
									 				)[[setL_i <- set_i,setL_imagesWithPoorLight_var <- set_imagesWithPoorLight_var]]
									 				)
									 			)
									 			 \ hideSet)
									 			[[
									 				verifyPlan__.x____ <- verifyPlan,
									 				planAccepted__.x____ <- planAccepted,
									 				planRejected__.x____ <- planRejected,
									 				newConfidences__.x____ <- newConfidences,
									 				get_newConfidences__.x____ <- get_newConfidences,
									 				set_newConfidences__.x____ <- set_newConfidences,
									 				imagesWithLight__.x____ <- imagesWithLight,
									 				get_imagesWithLight__.x____ <- get_imagesWithLight,
									 				imagesWithPoorLight__.x____ <- imagesWithPoorLight,
									 				get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight,
									 				newModel__.x____ <- newModel,
									 				get_newModel__.x____ <- get_newModel
									 				| x____ <- NIDS
									 			]]
									 		)
									 		[| {|get_CLID_CheckImages,CheckImages::entered,terminate|} |]
									 		dbisim(Clock_CLID_CheckImages(id__,0,
									 				          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
									 	)\{|get_CLID_CheckImages|}
									 )
									 ))
									  [[ share__ <- x__ | x__ <- {| share__,setR_imagesWithLight_var,setR_planLegitimated,setR_i,setR_imagesWithPoorLight_var,setR_newModel_var |} ]] 
									  [[set_imagesWithLight_var <- setL_imagesWithLight_var,set_planLegitimated <- setL_planLegitimated,set_i <- setL_i,set_imagesWithPoorLight_var <- setL_imagesWithPoorLight_var,set_newModel_var <- setL_newModel_var]]
									 )
									 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
									 			,setL_imagesWithLight_var
									 			,setL_planLegitimated
									 			,setL_i
									 			,setL_imagesWithPoorLight_var
									 			,setL_newModel_var
									 			,setR_imagesWithLight_var
									 			 			,setR_planLegitimated
									 			 			,setR_i
									 			 			,setR_imagesWithPoorLight_var
									 			 			,setR_newModel_var
									 			|}) |]
									 ((During)
									  [[ share__ <- x__ | x__ <- {| share__,setL_imagesWithLight_var,setL_planLegitimated,setL_i,setL_imagesWithPoorLight_var,setL_newModel_var |} ]]
									  [[set_imagesWithLight_var <- setR_imagesWithLight_var,set_planLegitimated <- setR_planLegitimated,set_i <- setR_i,set_imagesWithPoorLight_var <- setR_imagesWithPoorLight_var,set_newModel_var <- setR_newModel_var]]
									 )
									)[[setL_imagesWithLight_var <- set_imagesWithLight_var,setL_planLegitimated <- set_planLegitimated,setL_i <- set_i,setL_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setL_newModel_var <- set_newModel_var]]
									 [[setR_imagesWithLight_var <- set_imagesWithLight_var,setR_planLegitimated <- set_planLegitimated,setR_i <- set_i,setR_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setR_newModel_var <- set_newModel_var]]
									)\{terminate} 
								)
								During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
										 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
							within
								Inactive [| {terminate} |> SKIP)
							
							Transitions(id__,
									    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = ((let
								Trans = share__choice(get_i?i -> get_imagesWithPoorLight_var?imagesWithPoorLight_var -> TimeOut_1(
									 (share__ -> SKIP
									 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((share__choice(true & (share__choice(set_i!1 -> SKIP)));share__choice(true & (share__choice(set_planLegitimated!true -> SKIP))) ; CheckImages::enter -> SKIP))))
									 [] dbisim(((i<=length(imagesWithPoorLight_var)))&(internal__!NID_CheckImages -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_imagesWithLight_var?imagesWithLight_var -> share__choice(get_planLegitimated?planLegitimated -> share__choice(get_screw?screw -> share__choice(get_i?i -> share__choice(get_imagesWithPoorLight_var?imagesWithPoorLight_var -> share__choice(get_newModel_var?newModel_var -> true & (share__choice(set_planLegitimated!(let
									 			image = tuple3_1((access_(imagesWithLight_var, access_(imagesWithPoorLight_var, i))))
									 			newPositions = Adaptation_Legitimate_checkImage(Types_ScrewImageData_image(image),newModel_var)
									 			confidenceCheck = {screw | screw <- Types_EstimatedPosition, (Types_EstimatedPosition_confidence(screw)>=const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)}
									 			within
									 				(if (sequence_toolkit_filter(newPositions,confidenceCheck)==<>) then false else planLegitimated)
									 			) -> SKIP))))))))) ; CheckImages::enter -> SKIP)))
									 [] dbisim(((i>length(imagesWithPoorLight_var)))&(internal__!NID_CheckImages -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; f0::enter -> SKIP)))
									 []
									 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
									 []
									 terminate -> SKIP
									 )
								,SKIP);Trans
								)
							within
								Trans [|{terminate}|> SKIP
							)
							)
							
							
							-- Clocks
							Clock_CLID_CheckImages(id__,x__,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
								TimeOut_1(
									CheckImages::entered -> Clock_CLID_CheckImages(id__,0,
											          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									[]
									get_CLID_CheckImages!x__ -> Clock_CLID_CheckImages(id__,x__,
											          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									[]
									terminate -> SKIP,Clock_CLID_CheckImages(id__,clock_type_plus(x__,1,CLID_CheckImages_clock_type(id__,
											          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)),
											          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
							
							StateClocks(id__,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = dbisim(Clock_CLID_CheckImages(id__,0,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
							
							stateClockSync = {|get_CLID_CheckImages,CheckImages::entered|}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
					)\sharedVarHide
					
					STM_VS_O(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
					)\sharedVarHide
					
					-- Transitions
					Transitions(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = ((let
						Trans = share__choice(get_planLegitimated?planLegitimated -> TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; Initialise::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_Initialise -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForSignal::enter -> SKIP)))
							 [] dbisim((true)&(verifyPlan__!NID_WaitForSignal.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; PerformVerification::enter -> SKIP)))
							 [] dbisim((planLegitimated)&(internal__!NID_PerformVerification -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(planAccepted.out -> SKIP)) ; WaitForSignal::enter -> SKIP)))
							 [] dbisim(((not (planLegitimated)))&(internal__!NID_PerformVerification -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(planRejected.out -> SKIP)) ; WaitForSignal::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
						)
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Initialise::enter,
								WaitForSignal::enter,
								PerformVerification::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_Initialise,verifyPlan__.NID_WaitForSignal.in,internal__.NID_PerformVerification,internal__.NID_PerformVerification|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									   [| { share__, terminate } |] (
									   Initialise::D__(id__,
									   		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									   [| { share__, terminate } |] (
									   WaitForSignal::D__(id__,
									   		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									   [| { share__, terminate } |] (
									   PerformVerification::D__(id__,
									   		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									   )
									   )
									   )
									 )
									 [[Initialise::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialise|}]]
									 [[WaitForSignal::interrupt <- x__ | x__ <- {|interrupt,verifyPlan__.NID_WaitForSignal.in|}]]
									 [[PerformVerification::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_PerformVerification,internal__.NID_PerformVerification|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									  [[set_planLegitimated <- setL_planLegitimated]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_planLegitimated
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
									  [[ share__ <- x__ | x__ <- {| share__,setL_planLegitimated |} ]]
									 )
									)[[setL_planLegitimated <- set_planLegitimated]]
									)
								)
								 \ hideSet)
								[[
									verifyPlan__.x____ <- verifyPlan,
									planAccepted__.x____ <- planAccepted,
									planRejected__.x____ <- planRejected,
									newConfidences__.x____ <- newConfidences,
									get_newConfidences__.x____ <- get_newConfidences,
									set_newConfidences__.x____ <- set_newConfidences,
									imagesWithLight__.x____ <- imagesWithLight,
									get_imagesWithLight__.x____ <- get_imagesWithLight,
									imagesWithPoorLight__.x____ <- imagesWithPoorLight,
									get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight,
									newModel__.x____ <- newModel,
									get_newModel__.x____ <- get_newModel
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
						dbisim((let
							stateClockSync = {|get_CLID_Initialise,Initialise::entered,get_CLID_PerformVerification,PerformVerification::entered,get_CLID_WaitForSignal,WaitForSignal::entered|}
						 within
							(MachineBody(id__,
									    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
						dbisim((let
							stateClockSync = {|get_CLID_Initialise,Initialise::entered,get_CLID_PerformVerification,PerformVerification::entered,get_CLID_WaitForSignal,WaitForSignal::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													MachineBody(id__,
															    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
													[| {|get_CLID_WaitForSignal,WaitForSignal::entered,terminate|} |]
													dbisim(Clock_CLID_WaitForSignal(id__,0,
															          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
												)\{|get_CLID_WaitForSignal|}
											)
											[| {|get_CLID_PerformVerification,PerformVerification::entered,terminate|} |]
											dbisim(Clock_CLID_PerformVerification(id__,0,
													          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
										)\{|get_CLID_PerformVerification|}
									)
									[| {|get_CLID_Initialise,Initialise::entered,terminate|} |]
									dbisim(Clock_CLID_Initialise(id__,0,
											          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
								)\{|get_CLID_Initialise|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
						((let
							getsetLocalChannels = {|get_planLegitimated,set_planLegitimated,
							get_i,set_i,
							get_imagesWithLight_var,set_imagesWithLight_var,
							get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,
							get_newModel_var,set_newModel_var|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) [| {terminate} |] Clocks(id__,
							 		          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																IteratedBehaviour(id__,
																		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
																[| {|get_newModel_var,set_newModel_var,terminate|} |]
																Memory_newModel_var(0)
															)\{|get_newModel_var,set_newModel_var|}
														)
														[| {|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,terminate|} |]
														Memory_imagesWithPoorLight_var(<>)
													)\{|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
												)
												[| {|get_imagesWithLight_var,set_imagesWithLight_var,terminate|} |]
												Memory_imagesWithLight_var(<>)
											)\{|get_imagesWithLight_var,set_imagesWithLight_var|}
										)
										[| {|get_i,set_i,terminate|} |]
										Memory_i(0)
									)\{|get_i,set_i|}
								)
								[| {|get_planLegitimated,set_planLegitimated,terminate|} |]
								Memory_planLegitimated(true)
							)\{|get_planLegitimated,set_planLegitimated|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Initialise::enter,
								WaitForSignal::enter,
								PerformVerification::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_Initialise,verifyPlan__.NID_WaitForSignal.in,internal__.NID_PerformVerification,internal__.NID_PerformVerification|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									   [| { share__, terminate } |] (
									   Initialise::VS_O__(id__,
									   		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									   [| { share__, terminate } |] (
									   WaitForSignal::VS_O__(id__,
									   		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									   [| { share__, terminate } |] (
									   PerformVerification::VS_O__(id__,
									   		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
									   )
									   )
									   )
									 )
									 [[Initialise::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialise|}]]
									 [[WaitForSignal::interrupt <- x__ | x__ <- {|interrupt,verifyPlan__.NID_WaitForSignal.in|}]]
									 [[PerformVerification::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_PerformVerification,internal__.NID_PerformVerification|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									  [[set_planLegitimated <- setL_planLegitimated]]
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setL_planLegitimated
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
									  [[ share__ <- x__ | x__ <- {| share__,setL_planLegitimated |} ]]
									 )
									)[[setL_planLegitimated <- set_planLegitimated]]
									)
								)
								 \ hideSet)
								[[
									verifyPlan__.x____ <- verifyPlan,
									planAccepted__.x____ <- planAccepted,
									planRejected__.x____ <- planRejected,
									newConfidences__.x____ <- newConfidences,
									get_newConfidences__.x____ <- get_newConfidences,
									set_newConfidences__.x____ <- set_newConfidences,
									imagesWithLight__.x____ <- imagesWithLight,
									get_imagesWithLight__.x____ <- get_imagesWithLight,
									imagesWithPoorLight__.x____ <- imagesWithPoorLight,
									get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight,
									newModel__.x____ <- newModel,
									get_newModel__.x____ <- get_newModel
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
						dbisim((let
							stateClockSync = {|get_CLID_Initialise,Initialise::entered,get_CLID_PerformVerification,PerformVerification::entered,get_CLID_WaitForSignal,WaitForSignal::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
						dbisim((let
							stateClockSync = {|get_CLID_Initialise,Initialise::entered,get_CLID_PerformVerification,PerformVerification::entered,get_CLID_WaitForSignal,WaitForSignal::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													MachineBody_VS_O(id__,
															    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
													[| {|get_CLID_WaitForSignal,WaitForSignal::entered,terminate|} |]
													dbisim(Clock_CLID_WaitForSignal(id__,0,
															          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
												)\{|get_CLID_WaitForSignal|}
											)
											[| {|get_CLID_PerformVerification,PerformVerification::entered,terminate|} |]
											dbisim(Clock_CLID_PerformVerification(id__,0,
													          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
										)\{|get_CLID_PerformVerification|}
									)
									[| {|get_CLID_Initialise,Initialise::entered,terminate|} |]
									dbisim(Clock_CLID_Initialise(id__,0,
											          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
								)\{|get_CLID_Initialise|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
						dbisim((let
							getsetLocalChannels = {|get_planLegitimated,set_planLegitimated,
							get_i,set_i,
							get_imagesWithLight_var,set_imagesWithLight_var,
							get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,
							get_newModel_var,set_newModel_var|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) [| {terminate} |] Clocks(id__,
							 		          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																IteratedBehaviour_VS_O(id__,
																		    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
																[| {|get_newModel_var,set_newModel_var,terminate|} |]
																Memory_newModel_var(0)
															)\{|get_newModel_var,set_newModel_var|}
														)
														[| {|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,terminate|} |]
														Memory_imagesWithPoorLight_var(<>)
													)\{|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
												)
												[| {|get_imagesWithLight_var,set_imagesWithLight_var,terminate|} |]
												Memory_imagesWithLight_var(<>)
											)\{|get_imagesWithLight_var,set_imagesWithLight_var|}
										)
										[| {|get_i,set_i,terminate|} |]
										Memory_i(0)
									)\{|get_i,set_i|}
								)
								[| {|get_planLegitimated,set_planLegitimated,terminate|} |]
								Memory_planLegitimated(true)
							)\{|get_planLegitimated,set_planLegitimated|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_planLegitimated(planLegitimated) =
						get_planLegitimated!planLegitimated -> Memory_planLegitimated(planLegitimated)
						[]
						set_planLegitimated?x__ -> Memory_planLegitimated(x__)
						[]
						terminate -> SKIP
					Memory_i(i) =
						get_i!i -> Memory_i(i)
						[]
						set_i?x__ -> Memory_i(x__)
						[]
						terminate -> SKIP
					Memory_imagesWithLight_var(imagesWithLight_var) =
						get_imagesWithLight_var!imagesWithLight_var -> Memory_imagesWithLight_var(imagesWithLight_var)
						[]
						set_imagesWithLight_var?x__ -> Memory_imagesWithLight_var(x__)
						[]
						terminate -> SKIP
					Memory_imagesWithPoorLight_var(imagesWithPoorLight_var) =
						get_imagesWithPoorLight_var!imagesWithPoorLight_var -> Memory_imagesWithPoorLight_var(imagesWithPoorLight_var)
						[]
						set_imagesWithPoorLight_var?x__ -> Memory_imagesWithPoorLight_var(x__)
						[]
						terminate -> SKIP
					Memory_newModel_var(newModel_var) =
						get_newModel_var!newModel_var -> Memory_newModel_var(newModel_var)
						[]
						set_newModel_var?x__ -> Memory_newModel_var(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = Memory_planLegitimated(true)
					[| { terminate } |] (
					Memory_i(0)
					[| { terminate } |] (
					Memory_imagesWithLight_var(<>)
					[| { terminate } |] (
					Memory_imagesWithPoorLight_var(<>)
					[| { terminate } |] (
					Memory_newModel_var(0)
					)
					)
					)
					)
					
					getsetLocalChannels = {|get_planLegitimated,set_planLegitimated,get_i,set_i,get_imagesWithLight_var,set_imagesWithLight_var,get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,get_newModel_var,set_newModel_var|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = STM_VS_O(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) \ localClockResets
					D__(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = timed_priority(STM(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) \ union(internal_events,localClockResets))
					O__(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = dbisim(D__(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
					VS__(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = FVS__(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
					VS_O__(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = dbisim(FVS__(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
					HEXT__(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = O__(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = dbisim(timed_priority(STM(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) \ internal_events))
					HUP__(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = timed_priority(O__(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_Initialise(id__,x__,
							          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
						TimeOut_1(
							Initialise::entered -> Clock_CLID_Initialise(id__,0,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
							[]
							get_CLID_Initialise!x__ -> Clock_CLID_Initialise(id__,x__,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
							[]
							terminate -> SKIP,Clock_CLID_Initialise(id__,clock_type_plus(x__,1,CLID_Initialise_clock_type(id__,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)),
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
					Clock_CLID_PerformVerification(id__,x__,
							          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
						TimeOut_1(
							PerformVerification::entered -> Clock_CLID_PerformVerification(id__,0,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
							[]
							get_CLID_PerformVerification!x__ -> Clock_CLID_PerformVerification(id__,x__,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
							[]
							terminate -> SKIP,Clock_CLID_PerformVerification(id__,clock_type_plus(x__,1,CLID_PerformVerification_clock_type(id__,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)),
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
					Clock_CLID_WaitForSignal(id__,x__,
							          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = 
						TimeOut_1(
							WaitForSignal::entered -> Clock_CLID_WaitForSignal(id__,0,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
							[]
							get_CLID_WaitForSignal!x__ -> Clock_CLID_WaitForSignal(id__,x__,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)
							[]
							terminate -> SKIP,Clock_CLID_WaitForSignal(id__,clock_type_plus(x__,1,CLID_WaitForSignal_clock_type(id__,
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)),
									          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
					
					StateClocks(id__,
							          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = dbisim(Clock_CLID_Initialise(id__,0,
							          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
					[| { terminate } |] (
					dbisim(Clock_CLID_PerformVerification(id__,0,
							          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
					[| { terminate } |] (
					dbisim(Clock_CLID_WaitForSignal(id__,0,
							          const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD))
					)
					)
					
					stateClockSync = {|get_CLID_Initialise,Initialise::entered,get_CLID_PerformVerification,PerformVerification::entered,get_CLID_WaitForSignal,WaitForSignal::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref5
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Knowledge
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_imagesWithLight_var, set_imagesWithLight_var, setL_imagesWithLight_var, setR_imagesWithLight_var: LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel get_imagesWithPoorLight_var, set_imagesWithPoorLight_var, setL_imagesWithPoorLight_var, setR_imagesWithPoorLight_var: LSeq(core_nat,2)
				channel get_newModel_var, set_newModel_var, setL_newModel_var, setR_newModel_var: core_nat
				channel get_newConfidences_var, set_newConfidences_var, setL_newConfidences_var, setR_newConfidences_var: LSeq(LSeq(Types_EstimatedPosition,2),2)
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel imagesWithLight__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel imagesWithLight: InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel get_imagesWithLight__: NIDS.InOut
				channel get_imagesWithLight: InOut
				channel set_imagesWithLight__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel set_imagesWithLight: InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel imagesWithLight_ext__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel imagesWithLight_ext: InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel get_imagesWithLight_ext__: NIDS.InOut
				channel get_imagesWithLight_ext: InOut
				channel imagesWithLight_Analyse__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel imagesWithLight_Analyse: InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel get_imagesWithLight_Analyse__: NIDS.InOut
				channel get_imagesWithLight_Analyse: InOut
				channel imagesWithLight_Plan__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel imagesWithLight_Plan: InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel get_imagesWithLight_Plan__: NIDS.InOut
				channel get_imagesWithLight_Plan: InOut
				channel imagesWithLight_Legitimate__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel imagesWithLight_Legitimate: InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel get_imagesWithLight_Legitimate__: NIDS.InOut
				channel get_imagesWithLight_Legitimate: InOut
				channel imagesWithPoorLight__: NIDS.InOut.LSeq(core_nat,2)
				channel imagesWithPoorLight: InOut.LSeq(core_nat,2)
				channel get_imagesWithPoorLight__: NIDS.InOut
				channel get_imagesWithPoorLight: InOut
				channel set_imagesWithPoorLight__: NIDS.InOut.LSeq(core_nat,2)
				channel set_imagesWithPoorLight: InOut.LSeq(core_nat,2)
				channel imagesWithPoorLight_ext__: NIDS.InOut.LSeq(core_nat,2)
				channel imagesWithPoorLight_ext: InOut.LSeq(core_nat,2)
				channel get_imagesWithPoorLight_ext__: NIDS.InOut
				channel get_imagesWithPoorLight_ext: InOut
				channel imagesWithPoorLight_Plan__: NIDS.InOut.LSeq(core_nat,2)
				channel imagesWithPoorLight_Plan: InOut.LSeq(core_nat,2)
				channel get_imagesWithPoorLight_Plan__: NIDS.InOut
				channel get_imagesWithPoorLight_Plan: InOut
				channel imagesWithPoorLight_Legitimate__: NIDS.InOut.LSeq(core_nat,2)
				channel imagesWithPoorLight_Legitimate: InOut.LSeq(core_nat,2)
				channel get_imagesWithPoorLight_Legitimate__: NIDS.InOut
				channel get_imagesWithPoorLight_Legitimate: InOut
				channel newModel__: NIDS.InOut.core_nat
				channel newModel: InOut.core_nat
				channel get_newModel__: NIDS.InOut
				channel get_newModel: InOut
				channel set_newModel__: NIDS.InOut.core_nat
				channel set_newModel: InOut.core_nat
				channel newModel_ext__: NIDS.InOut.core_nat
				channel newModel_ext: InOut.core_nat
				channel get_newModel_ext__: NIDS.InOut
				channel get_newModel_ext: InOut
				channel newModel_Legitimate__: NIDS.InOut.core_nat
				channel newModel_Legitimate: InOut.core_nat
				channel get_newModel_Legitimate__: NIDS.InOut
				channel get_newModel_Legitimate: InOut
				channel newModel_Execute__: NIDS.InOut.core_nat
				channel newModel_Execute: InOut.core_nat
				channel get_newModel_Execute__: NIDS.InOut
				channel get_newModel_Execute: InOut
				channel newConfidences__: NIDS.InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
				channel newConfidences: InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
				channel get_newConfidences__: NIDS.InOut
				channel get_newConfidences: InOut
				channel set_newConfidences__: NIDS.InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
				channel set_newConfidences: InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
				channel newConfidences_ext__: NIDS.InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
				channel newConfidences_ext: InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
				channel get_newConfidences_ext__: NIDS.InOut
				channel get_newConfidences_ext: InOut
				channel newConfidences_Plan__: NIDS.InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
				channel newConfidences_Plan: InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
				channel get_newConfidences_Plan__: NIDS.InOut
				channel get_newConfidences_Plan: InOut
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				Knowledge::enter
				|}
				
				enteredSS = 	{|
				Knowledge::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	imagesWithLight,
					get_imagesWithLight,
					set_imagesWithLight,
					imagesWithLight_ext,
					get_imagesWithLight_ext,
					imagesWithLight_Analyse,
					get_imagesWithLight_Analyse,
					imagesWithLight_Plan,
					get_imagesWithLight_Plan,
					imagesWithLight_Legitimate,
					get_imagesWithLight_Legitimate,
					imagesWithPoorLight,
					get_imagesWithPoorLight,
					set_imagesWithPoorLight,
					imagesWithPoorLight_ext,
					get_imagesWithPoorLight_ext,
					imagesWithPoorLight_Plan,
					get_imagesWithPoorLight_Plan,
					imagesWithPoorLight_Legitimate,
					get_imagesWithPoorLight_Legitimate,
					newModel,
					get_newModel,
					set_newModel,
					newModel_ext,
					get_newModel_ext,
					newModel_Legitimate,
					get_newModel_Legitimate,
					newModel_Execute,
					get_newModel_Execute,
					newConfidences,
					get_newConfidences,
					set_newConfidences,
					newConfidences_ext,
					get_newConfidences_ext,
					newConfidences_Plan,
					get_newConfidences_Plan
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_Knowledge : core_clock_type 
				--channel increment__
				
				CLID_Knowledge_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Knowledge
					module Knowledge
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					
					STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					
					-- Transitions
					Transitions(id__) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; Knowledge::enter -> SKIP))))
							 [] dbisim((true)&(get_imagesWithLight__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_imagesWithLight_var?imagesWithLight_var -> true&(share__choice(imagesWithLight.out!imagesWithLight_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(set_imagesWithLight__!NID_Knowledge.in?imagesWithLight_var:{imagesWithLight_var|imagesWithLight_var <- LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2), true} -> share__choice(set_imagesWithLight_var!imagesWithLight_var -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(get_imagesWithLight_ext__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_imagesWithLight_var?imagesWithLight_var -> true&(share__choice(imagesWithLight_ext.out!imagesWithLight_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(get_imagesWithLight_Analyse__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_imagesWithLight_var?imagesWithLight_var -> true&(share__choice(imagesWithLight_Analyse.out!imagesWithLight_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(get_imagesWithLight_Plan__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_imagesWithLight_var?imagesWithLight_var -> true&(share__choice(imagesWithLight_Plan.out!imagesWithLight_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(get_imagesWithLight_Legitimate__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_imagesWithLight_var?imagesWithLight_var -> true&(share__choice(imagesWithLight_Legitimate.out!imagesWithLight_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(get_imagesWithPoorLight__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_imagesWithPoorLight_var?imagesWithPoorLight_var -> true&(share__choice(imagesWithPoorLight.out!imagesWithPoorLight_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(set_imagesWithPoorLight__!NID_Knowledge.in?imagesWithPoorLight_var:{imagesWithPoorLight_var|imagesWithPoorLight_var <- LSeq(core_nat,2), true} -> share__choice(set_imagesWithPoorLight_var!imagesWithPoorLight_var -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(get_imagesWithPoorLight_ext__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_imagesWithPoorLight_var?imagesWithPoorLight_var -> true&(share__choice(imagesWithPoorLight_ext.out!imagesWithPoorLight_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(get_imagesWithPoorLight_Plan__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_imagesWithPoorLight_var?imagesWithPoorLight_var -> true&(share__choice(imagesWithPoorLight_Plan.out!imagesWithPoorLight_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(get_imagesWithPoorLight_Legitimate__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_imagesWithPoorLight_var?imagesWithPoorLight_var -> true&(share__choice(imagesWithPoorLight_Legitimate.out!imagesWithPoorLight_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(get_newModel__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_newModel_var?newModel_var -> true&(share__choice(newModel.out!newModel_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(set_newModel__!NID_Knowledge.in?newModel_var:{newModel_var|newModel_var <- core_nat, true} -> share__choice(set_newModel_var!newModel_var -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(get_newModel_ext__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_newModel_var?newModel_var -> true&(share__choice(newModel_ext.out!newModel_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(get_newModel_Legitimate__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_newModel_var?newModel_var -> true&(share__choice(newModel_Legitimate.out!newModel_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(get_newModel_Execute__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_newModel_var?newModel_var -> true&(share__choice(newModel_Execute.out!newModel_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(get_newConfidences__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_newConfidences_var?newConfidences_var -> true&(share__choice(newConfidences.out!newConfidences_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(set_newConfidences__!NID_Knowledge.in?newConfidences_var:{newConfidences_var|newConfidences_var <- LSeq(LSeq(Types_EstimatedPosition,2),2), true} -> share__choice(set_newConfidences_var!newConfidences_var -> SKIP) ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(get_newConfidences_ext__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_newConfidences_var?newConfidences_var -> true&(share__choice(newConfidences_ext.out!newConfidences_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 [] dbisim((true)&(get_newConfidences_Plan__!NID_Knowledge.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(get_newConfidences_var?newConfidences_var -> true&(share__choice(newConfidences_Plan.out!newConfidences_var -> SKIP))) ; Knowledge::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Knowledge::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,get_imagesWithLight__.NID_Knowledge.in,set_imagesWithLight__.NID_Knowledge.in,get_imagesWithLight_ext__.NID_Knowledge.in,get_imagesWithLight_Analyse__.NID_Knowledge.in,get_imagesWithLight_Plan__.NID_Knowledge.in,get_imagesWithLight_Legitimate__.NID_Knowledge.in,get_imagesWithPoorLight__.NID_Knowledge.in,set_imagesWithPoorLight__.NID_Knowledge.in,get_imagesWithPoorLight_ext__.NID_Knowledge.in,get_imagesWithPoorLight_Plan__.NID_Knowledge.in,get_imagesWithPoorLight_Legitimate__.NID_Knowledge.in,get_newModel__.NID_Knowledge.in,set_newModel__.NID_Knowledge.in,get_newModel_ext__.NID_Knowledge.in,get_newModel_Legitimate__.NID_Knowledge.in,get_newModel_Execute__.NID_Knowledge.in,get_newConfidences__.NID_Knowledge.in,set_newConfidences__.NID_Knowledge.in,get_newConfidences_ext__.NID_Knowledge.in,get_newConfidences_Plan__.NID_Knowledge.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__)
									   [| { share__, terminate } |] (
									   Knowledge::D__(id__)
									   )
									 )
									 [[Knowledge::interrupt <- x__ | x__ <- {|interrupt,get_imagesWithLight__.NID_Knowledge.in,set_imagesWithLight__.NID_Knowledge.in,get_imagesWithLight_ext__.NID_Knowledge.in,get_imagesWithLight_Analyse__.NID_Knowledge.in,get_imagesWithLight_Plan__.NID_Knowledge.in,get_imagesWithLight_Legitimate__.NID_Knowledge.in,get_imagesWithPoorLight__.NID_Knowledge.in,set_imagesWithPoorLight__.NID_Knowledge.in,get_imagesWithPoorLight_ext__.NID_Knowledge.in,get_imagesWithPoorLight_Plan__.NID_Knowledge.in,get_imagesWithPoorLight_Legitimate__.NID_Knowledge.in,get_newModel__.NID_Knowledge.in,set_newModel__.NID_Knowledge.in,get_newModel_ext__.NID_Knowledge.in,get_newModel_Legitimate__.NID_Knowledge.in,get_newModel_Execute__.NID_Knowledge.in,get_newConfidences__.NID_Knowledge.in,set_newConfidences__.NID_Knowledge.in,get_newConfidences_ext__.NID_Knowledge.in,get_newConfidences_Plan__.NID_Knowledge.in|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_imagesWithLight_var,setR_newConfidences_var,setR_imagesWithPoorLight_var,setR_newModel_var |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_imagesWithLight_var
									 			 			,setR_newConfidences_var
									 			 			,setR_imagesWithPoorLight_var
									 			 			,setR_newModel_var
									 			|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_imagesWithLight_var <- setR_imagesWithLight_var,set_newConfidences_var <- setR_newConfidences_var,set_imagesWithPoorLight_var <- setR_imagesWithPoorLight_var,set_newModel_var <- setR_newModel_var]]
									 )
									)
									 [[setR_imagesWithLight_var <- set_imagesWithLight_var,setR_newConfidences_var <- set_newConfidences_var,setR_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setR_newModel_var <- set_newModel_var]]
									)
								)
								 \ hideSet)
								[[
									imagesWithLight__.x____ <- imagesWithLight,
									get_imagesWithLight__.x____ <- get_imagesWithLight,
									set_imagesWithLight__.x____ <- set_imagesWithLight,
									imagesWithLight_ext__.x____ <- imagesWithLight_ext,
									get_imagesWithLight_ext__.x____ <- get_imagesWithLight_ext,
									imagesWithLight_Analyse__.x____ <- imagesWithLight_Analyse,
									get_imagesWithLight_Analyse__.x____ <- get_imagesWithLight_Analyse,
									imagesWithLight_Plan__.x____ <- imagesWithLight_Plan,
									get_imagesWithLight_Plan__.x____ <- get_imagesWithLight_Plan,
									imagesWithLight_Legitimate__.x____ <- imagesWithLight_Legitimate,
									get_imagesWithLight_Legitimate__.x____ <- get_imagesWithLight_Legitimate,
									imagesWithPoorLight__.x____ <- imagesWithPoorLight,
									get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight,
									set_imagesWithPoorLight__.x____ <- set_imagesWithPoorLight,
									imagesWithPoorLight_ext__.x____ <- imagesWithPoorLight_ext,
									get_imagesWithPoorLight_ext__.x____ <- get_imagesWithPoorLight_ext,
									imagesWithPoorLight_Plan__.x____ <- imagesWithPoorLight_Plan,
									get_imagesWithPoorLight_Plan__.x____ <- get_imagesWithPoorLight_Plan,
									imagesWithPoorLight_Legitimate__.x____ <- imagesWithPoorLight_Legitimate,
									get_imagesWithPoorLight_Legitimate__.x____ <- get_imagesWithPoorLight_Legitimate,
									newModel__.x____ <- newModel,
									get_newModel__.x____ <- get_newModel,
									set_newModel__.x____ <- set_newModel,
									newModel_ext__.x____ <- newModel_ext,
									get_newModel_ext__.x____ <- get_newModel_ext,
									newModel_Legitimate__.x____ <- newModel_Legitimate,
									get_newModel_Legitimate__.x____ <- get_newModel_Legitimate,
									newModel_Execute__.x____ <- newModel_Execute,
									get_newModel_Execute__.x____ <- get_newModel_Execute,
									newConfidences__.x____ <- newConfidences,
									get_newConfidences__.x____ <- get_newConfidences,
									set_newConfidences__.x____ <- set_newConfidences,
									newConfidences_ext__.x____ <- newConfidences_ext,
									get_newConfidences_ext__.x____ <- get_newConfidences_ext,
									newConfidences_Plan__.x____ <- newConfidences_Plan,
									get_newConfidences_Plan__.x____ <- get_newConfidences_Plan
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_Knowledge,Knowledge::entered|}
						 within
							(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_Knowledge,Knowledge::entered|}
						 within
							(dbisim(
								sbisim(
									MachineBody(id__)
									[| {|get_CLID_Knowledge,Knowledge::entered,terminate|} |]
									dbisim(Clock_CLID_Knowledge(id__,0))
								)\{|get_CLID_Knowledge|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__) = 
						((let
							getsetLocalChannels = {|get_imagesWithLight_var,set_imagesWithLight_var,
							get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,
							get_newModel_var,set_newModel_var,
							get_newConfidences_var,set_newConfidences_var|}
							clockSync = {||}
						within
							(Behaviour(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														IteratedBehaviour(id__)
														[| {|get_newConfidences_var,set_newConfidences_var,terminate|} |]
														Memory_newConfidences_var(<>)
													)\{|get_newConfidences_var,set_newConfidences_var|}
												)
												[| {|get_newModel_var,set_newModel_var,terminate|} |]
												Memory_newModel_var(0)
											)\{|get_newModel_var,set_newModel_var|}
										)
										[| {|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,terminate|} |]
										Memory_imagesWithPoorLight_var(<>)
									)\{|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
								)
								[| {|get_imagesWithLight_var,set_imagesWithLight_var,terminate|} |]
								Memory_imagesWithLight_var(<>)
							)\{|get_imagesWithLight_var,set_imagesWithLight_var|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Knowledge::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,get_imagesWithLight__.NID_Knowledge.in,set_imagesWithLight__.NID_Knowledge.in,get_imagesWithLight_ext__.NID_Knowledge.in,get_imagesWithLight_Analyse__.NID_Knowledge.in,get_imagesWithLight_Plan__.NID_Knowledge.in,get_imagesWithLight_Legitimate__.NID_Knowledge.in,get_imagesWithPoorLight__.NID_Knowledge.in,set_imagesWithPoorLight__.NID_Knowledge.in,get_imagesWithPoorLight_ext__.NID_Knowledge.in,get_imagesWithPoorLight_Plan__.NID_Knowledge.in,get_imagesWithPoorLight_Legitimate__.NID_Knowledge.in,get_newModel__.NID_Knowledge.in,set_newModel__.NID_Knowledge.in,get_newModel_ext__.NID_Knowledge.in,get_newModel_Legitimate__.NID_Knowledge.in,get_newModel_Execute__.NID_Knowledge.in,get_newConfidences__.NID_Knowledge.in,set_newConfidences__.NID_Knowledge.in,get_newConfidences_ext__.NID_Knowledge.in,get_newConfidences_Plan__.NID_Knowledge.in|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__)
									   [| { share__, terminate } |] (
									   Knowledge::VS_O__(id__)
									   )
									 )
									 [[Knowledge::interrupt <- x__ | x__ <- {|interrupt,get_imagesWithLight__.NID_Knowledge.in,set_imagesWithLight__.NID_Knowledge.in,get_imagesWithLight_ext__.NID_Knowledge.in,get_imagesWithLight_Analyse__.NID_Knowledge.in,get_imagesWithLight_Plan__.NID_Knowledge.in,get_imagesWithLight_Legitimate__.NID_Knowledge.in,get_imagesWithPoorLight__.NID_Knowledge.in,set_imagesWithPoorLight__.NID_Knowledge.in,get_imagesWithPoorLight_ext__.NID_Knowledge.in,get_imagesWithPoorLight_Plan__.NID_Knowledge.in,get_imagesWithPoorLight_Legitimate__.NID_Knowledge.in,get_newModel__.NID_Knowledge.in,set_newModel__.NID_Knowledge.in,get_newModel_ext__.NID_Knowledge.in,get_newModel_Legitimate__.NID_Knowledge.in,get_newModel_Execute__.NID_Knowledge.in,get_newConfidences__.NID_Knowledge.in,set_newConfidences__.NID_Knowledge.in,get_newConfidences_ext__.NID_Knowledge.in,get_newConfidences_Plan__.NID_Knowledge.in|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__,setR_imagesWithLight_var,setR_newConfidences_var,setR_imagesWithPoorLight_var,setR_newModel_var |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 			,setR_imagesWithLight_var
									 			 			,setR_newConfidences_var
									 			 			,setR_imagesWithPoorLight_var
									 			 			,setR_newModel_var
									 			|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									  [[set_imagesWithLight_var <- setR_imagesWithLight_var,set_newConfidences_var <- setR_newConfidences_var,set_imagesWithPoorLight_var <- setR_imagesWithPoorLight_var,set_newModel_var <- setR_newModel_var]]
									 )
									)
									 [[setR_imagesWithLight_var <- set_imagesWithLight_var,setR_newConfidences_var <- set_newConfidences_var,setR_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setR_newModel_var <- set_newModel_var]]
									)
								)
								 \ hideSet)
								[[
									imagesWithLight__.x____ <- imagesWithLight,
									get_imagesWithLight__.x____ <- get_imagesWithLight,
									set_imagesWithLight__.x____ <- set_imagesWithLight,
									imagesWithLight_ext__.x____ <- imagesWithLight_ext,
									get_imagesWithLight_ext__.x____ <- get_imagesWithLight_ext,
									imagesWithLight_Analyse__.x____ <- imagesWithLight_Analyse,
									get_imagesWithLight_Analyse__.x____ <- get_imagesWithLight_Analyse,
									imagesWithLight_Plan__.x____ <- imagesWithLight_Plan,
									get_imagesWithLight_Plan__.x____ <- get_imagesWithLight_Plan,
									imagesWithLight_Legitimate__.x____ <- imagesWithLight_Legitimate,
									get_imagesWithLight_Legitimate__.x____ <- get_imagesWithLight_Legitimate,
									imagesWithPoorLight__.x____ <- imagesWithPoorLight,
									get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight,
									set_imagesWithPoorLight__.x____ <- set_imagesWithPoorLight,
									imagesWithPoorLight_ext__.x____ <- imagesWithPoorLight_ext,
									get_imagesWithPoorLight_ext__.x____ <- get_imagesWithPoorLight_ext,
									imagesWithPoorLight_Plan__.x____ <- imagesWithPoorLight_Plan,
									get_imagesWithPoorLight_Plan__.x____ <- get_imagesWithPoorLight_Plan,
									imagesWithPoorLight_Legitimate__.x____ <- imagesWithPoorLight_Legitimate,
									get_imagesWithPoorLight_Legitimate__.x____ <- get_imagesWithPoorLight_Legitimate,
									newModel__.x____ <- newModel,
									get_newModel__.x____ <- get_newModel,
									set_newModel__.x____ <- set_newModel,
									newModel_ext__.x____ <- newModel_ext,
									get_newModel_ext__.x____ <- get_newModel_ext,
									newModel_Legitimate__.x____ <- newModel_Legitimate,
									get_newModel_Legitimate__.x____ <- get_newModel_Legitimate,
									newModel_Execute__.x____ <- newModel_Execute,
									get_newModel_Execute__.x____ <- get_newModel_Execute,
									newConfidences__.x____ <- newConfidences,
									get_newConfidences__.x____ <- get_newConfidences,
									set_newConfidences__.x____ <- set_newConfidences,
									newConfidences_ext__.x____ <- newConfidences_ext,
									get_newConfidences_ext__.x____ <- get_newConfidences_ext,
									newConfidences_Plan__.x____ <- newConfidences_Plan,
									get_newConfidences_Plan__.x____ <- get_newConfidences_Plan
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_Knowledge,Knowledge::entered|}
						 within
							(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_Knowledge,Knowledge::entered|}
						 within
							(dbisim(
								sbisim(
									MachineBody_VS_O(id__)
									[| {|get_CLID_Knowledge,Knowledge::entered,terminate|} |]
									dbisim(Clock_CLID_Knowledge(id__,0))
								)\{|get_CLID_Knowledge|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__) = 
						dbisim((let
							getsetLocalChannels = {|get_imagesWithLight_var,set_imagesWithLight_var,
							get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,
							get_newModel_var,set_newModel_var,
							get_newConfidences_var,set_newConfidences_var|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														IteratedBehaviour_VS_O(id__)
														[| {|get_newConfidences_var,set_newConfidences_var,terminate|} |]
														Memory_newConfidences_var(<>)
													)\{|get_newConfidences_var,set_newConfidences_var|}
												)
												[| {|get_newModel_var,set_newModel_var,terminate|} |]
												Memory_newModel_var(0)
											)\{|get_newModel_var,set_newModel_var|}
										)
										[| {|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,terminate|} |]
										Memory_imagesWithPoorLight_var(<>)
									)\{|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
								)
								[| {|get_imagesWithLight_var,set_imagesWithLight_var,terminate|} |]
								Memory_imagesWithLight_var(<>)
							)\{|get_imagesWithLight_var,set_imagesWithLight_var|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_imagesWithLight_var(imagesWithLight_var) =
						get_imagesWithLight_var!imagesWithLight_var -> Memory_imagesWithLight_var(imagesWithLight_var)
						[]
						set_imagesWithLight_var?x__ -> Memory_imagesWithLight_var(x__)
						[]
						terminate -> SKIP
					Memory_imagesWithPoorLight_var(imagesWithPoorLight_var) =
						get_imagesWithPoorLight_var!imagesWithPoorLight_var -> Memory_imagesWithPoorLight_var(imagesWithPoorLight_var)
						[]
						set_imagesWithPoorLight_var?x__ -> Memory_imagesWithPoorLight_var(x__)
						[]
						terminate -> SKIP
					Memory_newModel_var(newModel_var) =
						get_newModel_var!newModel_var -> Memory_newModel_var(newModel_var)
						[]
						set_newModel_var?x__ -> Memory_newModel_var(x__)
						[]
						terminate -> SKIP
					Memory_newConfidences_var(newConfidences_var) =
						get_newConfidences_var!newConfidences_var -> Memory_newConfidences_var(newConfidences_var)
						[]
						set_newConfidences_var?x__ -> Memory_newConfidences_var(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__) = Memory_imagesWithLight_var(<>)
					[| { terminate } |] (
					Memory_imagesWithPoorLight_var(<>)
					[| { terminate } |] (
					Memory_newModel_var(0)
					[| { terminate } |] (
					Memory_newConfidences_var(<>)
					)
					)
					)
					
					getsetLocalChannels = {|get_imagesWithLight_var,set_imagesWithLight_var,get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,get_newModel_var,set_newModel_var,get_newConfidences_var,set_newConfidences_var|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__) = STM_VS_O(id__) \ localClockResets
					D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
					O__(id__) = dbisim(D__(id__))
					VS__(id__) = FVS__(id__)
					VS_O__(id__) = dbisim(FVS__(id__))
					HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
					FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
					HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_Knowledge(id__,x__) = 
						TimeOut_1(
							Knowledge::entered -> Clock_CLID_Knowledge(id__,0)
							[]
							get_CLID_Knowledge!x__ -> Clock_CLID_Knowledge(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_Knowledge(id__,clock_type_plus(x__,1,CLID_Knowledge_clock_type(id__))))
					
					StateClocks(id__) = dbisim(Clock_CLID_Knowledge(id__,0))
					
					stateClockSync = {|get_CLID_Knowledge,Knowledge::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref2
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Initialise|
				              NID_WaitForSignal|
				              NID_MakePlan|
				              NID_PlanMade|
				              NID_WaitForVerification|
				              NID_Replan
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_modelScore, set_modelScore, setL_modelScore, setR_modelScore: LSeq(core_nat,2)
				channel get_modelRanking, set_modelRanking, setL_modelRanking, setR_modelRanking: LSeq(core_nat,2)
				channel get_model, set_model, setL_model, setR_model: core_nat
				channel get_image, set_image, setL_image, setR_image: core_nat
				channel get_pos, set_pos, setL_pos, setR_pos: core_nat
				channel get_imagesWithLight_var, set_imagesWithLight_var, setL_imagesWithLight_var, setR_imagesWithLight_var: LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel get_imagesWithPoorLight_var, set_imagesWithPoorLight_var, setL_imagesWithPoorLight_var, setR_imagesWithPoorLight_var: LSeq(core_nat,2)
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel planningCompleted__: NIDS.InOut
				channel planningCompleted: InOut
				channel planRejected__: NIDS.InOut
				channel planRejected: InOut
				channel requestPlan__: NIDS.InOut
				channel requestPlan: InOut
				channel newModel__: NIDS.InOut.core_nat
				channel newModel: InOut.core_nat
				channel get_newModel__: NIDS.InOut
				channel get_newModel: InOut
				channel set_newModel__: NIDS.InOut.core_nat
				channel set_newModel: InOut.core_nat
				channel imagesWithLight__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel imagesWithLight: InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
				channel get_imagesWithLight__: NIDS.InOut
				channel get_imagesWithLight: InOut
				channel newConfidences__: NIDS.InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
				channel newConfidences: InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
				channel get_newConfidences__: NIDS.InOut
				channel get_newConfidences: InOut
				channel imagesWithPoorLight__: NIDS.InOut.LSeq(core_nat,2)
				channel imagesWithPoorLight: InOut.LSeq(core_nat,2)
				channel get_imagesWithPoorLight__: NIDS.InOut
				channel get_imagesWithPoorLight: InOut
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				Initialise::enter,
				WaitForSignal::enter,
				MakePlan::enter,
				PlanMade::enter,
				WaitForVerification::enter,
				Replan::enter
				|}
				
				enteredSS = 	{|
				Initialise::entered,
				WaitForSignal::entered,
				MakePlan::entered,
				PlanMade::entered,
				WaitForVerification::entered,
				Replan::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	planningCompleted,
					planRejected,
					requestPlan,
					newModel,
					get_newModel,
					set_newModel,
					imagesWithLight,
					get_imagesWithLight,
					newConfidences,
					get_newConfidences,
					imagesWithPoorLight,
					get_imagesWithPoorLight
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_PlanMade : core_clock_type 
				channel get_CLID_Replan : core_clock_type 
				channel get_CLID_MakePlan : core_clock_type 
				channel get_CLID_WaitForSignal : core_clock_type 
				channel get_CLID_Initialise : core_clock_type 
				channel get_CLID_WaitForVerification : core_clock_type 
				--channel increment__
				
				CLID_PlanMade_clock_type(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Replan_clock_type(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_MakePlan_clock_type(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_WaitForSignal_clock_type(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Initialise_clock_type(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_WaitForVerification_clock_type(id__,
						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
					let
						max = (clock_type_max(Union({
				{}
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = D__(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Initialise
					module Initialise
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: WaitForSignal
					module WaitForSignal
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: MakePlan
					module MakePlan
					
					enterSS = 
							{|			i0::enter,
								CheckModel::enter,
								CheckImage::enter,
								RankModel::enter,
								f0::enter
							|}
					enteredSS = 
							{|			CheckModel::entered,
								CheckImage::entered,
								RankModel::entered,
								f0::entered
							|}
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						-- declaring identifiers of transitions
						datatype NIDS = 
						              NID_i0|
						              NID_CheckModel|
						              NID_CheckImage|
						              NID_RankModel|
						              NID_f0
						
						channel internal__ : NIDS
						channel planningCompleted__: NIDS.InOut
						channel planRejected__: NIDS.InOut
						channel requestPlan__: NIDS.InOut
						channel newModel__: NIDS.InOut.core_nat
						channel get_newModel__: NIDS.InOut
						channel set_newModel__: NIDS.InOut.core_nat
						channel imagesWithLight__: NIDS.InOut.LSeq({(x0__,x1__,x2__) | x0__ <- Types_ScrewImageData,x1__ <- core_real,x2__ <- core_nat},2)
						channel get_imagesWithLight__: NIDS.InOut
						channel newConfidences__: NIDS.InOut.LSeq(LSeq(Types_EstimatedPosition,2),2)
						channel get_newConfidences__: NIDS.InOut
						channel imagesWithPoorLight__: NIDS.InOut.LSeq(core_nat,2)
						channel get_imagesWithPoorLight__: NIDS.InOut
						
						channel get_CLID_CheckModel : core_clock_type 
						channel get_CLID_CheckImage : core_clock_type 
						channel get_CLID_RankModel : core_clock_type 
						--channel increment__
						
						CLID_CheckModel_clock_type(id__,
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
							let
								max = (clock_type_max(Union({
						{}
						}))+1)
							ctype = {0..max}
						within
							if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
						
						CLID_CheckImage_clock_type(id__,
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
							let
								max = (clock_type_max(Union({
						{}
						}))+1)
							ctype = {0..max}
						within
							if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
						
						CLID_RankModel_clock_type(id__,
								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
							let
								max = (clock_type_max(Union({
						{}
						}))+1)
							ctype = {0..max}
						within
							if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
						
						
						--	Nodes
						-- declaring all nodes
						
						----------------------------------------------------------------------
						-- Initial: i0
						module i0
						exports
						
							channel enter, interrupt
							
							Timed(OneStep) {
								D__(id__,
										    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
									dbisim(let
										Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
										
										Termination = terminate -> SKIP
										
										Active 		= share__choice(interrupt -> SKIP) ; Inactive
									within
										Inactive [| {terminate} |> SKIP)
								
								VS_O__(id__,
										    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = D__(id__,
										    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- State: CheckModel
						module CheckModel
						
						enterSS = {}
						
						enteredSS = {}
						
						exports
						
							--  Declarations
							
							channel enter, entered, interrupt
							channel enteredL, enteredR
							
											
							
							--channel increment__
							
							
							--	Nodes
							-- declaring all nodes
							
							
							Timed(OneStep) {
								--	Rule: behaviours(Node)
								--  Note that FDR has problems with efficiently compiling the process below
								-- 	if using a different recursion pattern.
								D__(id__,
										    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
								dbisim(let
									-- IMPLEMENTATION NOTE: 
									-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
									-- however FDR struggles with that form in certain cases. So we use the exception operator
									-- instead to 'terminate'.
									
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= SKIP ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
									
								VS_O__(id__,
										    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= SKIP ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
								
								
								-- Clocks
								
								StateClocks(id__,
										          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
								
								stateClockSync = {||}
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- State: CheckImage
						module CheckImage
						
						enterSS = {}
						
						enteredSS = {}
						
						exports
						
							--  Declarations
							
							channel enter, entered, interrupt
							channel enteredL, enteredR
							
											
							
							--channel increment__
							
							
							--	Nodes
							-- declaring all nodes
							
							
							Timed(OneStep) {
								--	Rule: behaviours(Node)
								--  Note that FDR has problems with efficiently compiling the process below
								-- 	if using a different recursion pattern.
								D__(id__,
										    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
								dbisim(let
									-- IMPLEMENTATION NOTE: 
									-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
									-- however FDR struggles with that form in certain cases. So we use the exception operator
									-- instead to 'terminate'.
									
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= SKIP ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
									
								VS_O__(id__,
										    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= SKIP ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
								
								
								-- Clocks
								
								StateClocks(id__,
										          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
								
								stateClockSync = {||}
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- State: RankModel
						module RankModel
						
						enterSS = {}
						
						enteredSS = {}
						
						exports
						
							--  Declarations
							
							channel enter, entered, interrupt
							channel enteredL, enteredR
							
											
							
							--channel increment__
							
							
							--	Nodes
							-- declaring all nodes
							
							
							Timed(OneStep) {
								--	Rule: behaviours(Node)
								--  Note that FDR has problems with efficiently compiling the process below
								-- 	if using a different recursion pattern.
								D__(id__,
										    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
								dbisim(let
									-- IMPLEMENTATION NOTE: 
									-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
									-- however FDR struggles with that form in certain cases. So we use the exception operator
									-- instead to 'terminate'.
									
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= SKIP ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
									
								VS_O__(id__,
										    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= SKIP ; 
											 	  Behaviour ; 
											 	  share__choice(exit -> SKIP) ; SKIP ; 
											 	  share__choice(exited -> SKIP) ; Inactive
								
									Behaviour 	= entered -> During
									During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
								within
									Inactive [| {terminate} |> SKIP)
								
								
								-- Clocks
								
								StateClocks(id__,
										          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
								
								stateClockSync = {||}
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						----------------------------------------------------------------------
						-- Final state: f0
						module f0
						
						exports
						
							channel enter, entered, interrupt
							channel enteredL, enteredR
							
							Timed(OneStep) {
								--	Rule: behaviours(Node)
								D__(id__,
										    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
									dbisim(let
										Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Entering
										
										Entering 	= entered -> SKIP ; Active
										Active		= share__choice(terminate -> SKIP [] interrupt -> SKIP) ; Interrupted
										Interrupted	= share__choice(exit -> exited -> Inactive)
									within
										Inactive [| {terminate} |> SKIP)
									
								VS_O__(id__,
										    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = D__(id__,
										    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							}
						
						endmodule
						----------------------------------------------------------------------
						
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
							
								Behaviour 	= dbisim(
									((
									 (((dbisim(
									 	sbisim(
									 		dbisim(
									 			sbisim(
									 				dbisim(
									 					sbisim(
									 						(let
									 							-- IMPLEMENTATION NOTE:
									 							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
									 							-- modules for defining the semantics of each node.
									 							enterSS = {|
									 							i0::enter,
									 							CheckModel::enter,
									 							CheckImage::enter,
									 							RankModel::enter,
									 							f0::enter
									 							|}
									 							hideSet = union(enterSS,{|exit,exited,internal__|})
									 						within 
									 							((let
									 								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									 								-- because CSPM modules are used for the semantics of Node.
									 								flowevts = union(enterSS,{|exit,exited,interrupt|})
									 								transSync = {|internal__.NID_i0,internal__.NID_CheckModel,internal__.NID_CheckImage,internal__.NID_CheckImage,internal__.NID_RankModel,internal__.NID_RankModel,internal__.NID_CheckModel|}
									 							within
									 								((
									 								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									 								   i0::D__(id__,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									 								   [| { share__, terminate } |] (
									 								   CheckModel::D__(id__,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									 								   [| { share__, terminate } |] (
									 								   CheckImage::D__(id__,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									 								   [| { share__, terminate } |] (
									 								   RankModel::D__(id__,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									 								   [| { share__, terminate } |] (
									 								   f0::D__(id__,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									 								   )
									 								   )
									 								   )
									 								   )
									 								 )
									 								 [[CheckModel::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CheckModel,internal__.NID_CheckModel|}]]
									 								 [[CheckImage::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CheckImage,internal__.NID_CheckImage|}]]
									 								 [[RankModel::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_RankModel,internal__.NID_RankModel|}]]
									 								 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 								 )
									 								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 								  [[set_image <- setL_image,set_pos <- setL_pos,set_model <- setL_model,set_imagesWithPoorLight_var <- setL_imagesWithPoorLight_var,set_modelRanking <- setL_modelRanking,set_modelScore <- setL_modelScore]]
									 								 )
									 								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 								 			,setL_image
									 								 			,setL_pos
									 								 			,setL_model
									 								 			,setL_imagesWithPoorLight_var
									 								 			,setL_modelRanking
									 								 			,setL_modelScore
									 								|}) |]
									 								 ((i0::enter -> Transitions(id__,
									 								 		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 								 		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 								 		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
									 								  [[ share__ <- x__ | x__ <- {| share__,setL_image,setL_pos,setL_model,setL_imagesWithPoorLight_var,setL_modelRanking,setL_modelScore |} ]]
									 								 )
									 								)[[setL_image <- set_image,setL_pos <- set_pos,setL_model <- set_model,setL_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setL_modelRanking <- set_modelRanking,setL_modelScore <- set_modelScore]]
									 								)
									 							)
									 							 \ hideSet)
									 							[[
									 								planningCompleted__.x____ <- planningCompleted,
									 								planRejected__.x____ <- planRejected,
									 								requestPlan__.x____ <- requestPlan,
									 								newModel__.x____ <- newModel,
									 								get_newModel__.x____ <- get_newModel,
									 								set_newModel__.x____ <- set_newModel,
									 								imagesWithLight__.x____ <- imagesWithLight,
									 								get_imagesWithLight__.x____ <- get_imagesWithLight,
									 								newConfidences__.x____ <- newConfidences,
									 								get_newConfidences__.x____ <- get_newConfidences,
									 								imagesWithPoorLight__.x____ <- imagesWithPoorLight,
									 								get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight
									 								| x____ <- NIDS
									 							]]
									 						)
									 						[| {|get_CLID_RankModel,RankModel::entered,terminate|} |]
									 						dbisim(Clock_CLID_RankModel(id__,0,
									 								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
									 					)\{|get_CLID_RankModel|}
									 				)
									 				[| {|get_CLID_CheckImage,CheckImage::entered,terminate|} |]
									 				dbisim(Clock_CLID_CheckImage(id__,0,
									 						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
									 			)\{|get_CLID_CheckImage|}
									 		)
									 		[| {|get_CLID_CheckModel,CheckModel::entered,terminate|} |]
									 		dbisim(Clock_CLID_CheckModel(id__,0,
									 				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
									 	)\{|get_CLID_CheckModel|}
									 )
									 ))
									  [[ share__ <- x__ | x__ <- {| share__,setR_image,setR_pos,setR_imagesWithLight_var,setR_model,setR_modelRanking,setR_imagesWithPoorLight_var,setR_modelScore |} ]] 
									  [[set_image <- setL_image,set_pos <- setL_pos,set_imagesWithLight_var <- setL_imagesWithLight_var,set_model <- setL_model,set_modelRanking <- setL_modelRanking,set_imagesWithPoorLight_var <- setL_imagesWithPoorLight_var,set_modelScore <- setL_modelScore]]
									 )
									 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
									 			,setL_image
									 			,setL_pos
									 			,setL_imagesWithLight_var
									 			,setL_model
									 			,setL_modelRanking
									 			,setL_imagesWithPoorLight_var
									 			,setL_modelScore
									 			,setR_image
									 			 			,setR_pos
									 			 			,setR_imagesWithLight_var
									 			 			,setR_model
									 			 			,setR_modelRanking
									 			 			,setR_imagesWithPoorLight_var
									 			 			,setR_modelScore
									 			|}) |]
									 ((During)
									  [[ share__ <- x__ | x__ <- {| share__,setL_image,setL_pos,setL_imagesWithLight_var,setL_model,setL_modelRanking,setL_imagesWithPoorLight_var,setL_modelScore |} ]]
									  [[set_image <- setR_image,set_pos <- setR_pos,set_imagesWithLight_var <- setR_imagesWithLight_var,set_model <- setR_model,set_modelRanking <- setR_modelRanking,set_imagesWithPoorLight_var <- setR_imagesWithPoorLight_var,set_modelScore <- setR_modelScore]]
									 )
									)[[setL_image <- set_image,setL_pos <- set_pos,setL_imagesWithLight_var <- set_imagesWithLight_var,setL_model <- set_model,setL_modelRanking <- set_modelRanking,setL_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setL_modelScore <- set_modelScore]]
									 [[setR_image <- set_image,setR_pos <- set_pos,setR_imagesWithLight_var <- set_imagesWithLight_var,setR_model <- set_model,setR_modelRanking <- set_modelRanking,setR_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setR_modelScore <- set_modelScore]]
									)\union(enteredSS,{terminate}) 
								)
								During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
										 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
							
								Behaviour 	= dbisim(
									((
									 (((dbisim(
									 	sbisim(
									 		dbisim(
									 			sbisim(
									 				dbisim(
									 					sbisim(
									 						(let
									 							-- IMPLEMENTATION NOTE:
									 							-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
									 							-- modules for defining the semantics of each node.
									 							enterSS = {|
									 							i0::enter,
									 							CheckModel::enter,
									 							CheckImage::enter,
									 							RankModel::enter,
									 							f0::enter
									 							|}
									 							hideSet = union(enterSS,{|exit,exited,internal__|})
									 						within 
									 							((let
									 								-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									 								-- because CSPM modules are used for the semantics of Node.
									 								flowevts = union(enterSS,{|exit,exited,interrupt|})
									 								transSync = {|internal__.NID_i0,internal__.NID_CheckModel,internal__.NID_CheckImage,internal__.NID_CheckImage,internal__.NID_RankModel,internal__.NID_RankModel,internal__.NID_CheckModel|}
									 							within
									 								((
									 								 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									 								   i0::VS_O__(id__,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									 								   [| { share__, terminate } |] (
									 								   CheckModel::VS_O__(id__,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									 								   [| { share__, terminate } |] (
									 								   CheckImage::VS_O__(id__,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									 								   [| { share__, terminate } |] (
									 								   RankModel::VS_O__(id__,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									 								   [| { share__, terminate } |] (
									 								   f0::VS_O__(id__,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 								   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									 								   )
									 								   )
									 								   )
									 								   )
									 								 )
									 								 [[CheckModel::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CheckModel,internal__.NID_CheckModel|}]]
									 								 [[CheckImage::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_CheckImage,internal__.NID_CheckImage|}]]
									 								 [[RankModel::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_RankModel,internal__.NID_RankModel|}]]
									 								 [[f0::interrupt <- x__ | x__ <- {|interrupt|}]]
									 								 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 								 )
									 								  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 								  [[set_image <- setL_image,set_pos <- setL_pos,set_model <- setL_model,set_imagesWithPoorLight_var <- setL_imagesWithPoorLight_var,set_modelRanking <- setL_modelRanking,set_modelScore <- setL_modelScore]]
									 								 )
									 								 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									 								 			,setL_image
									 								 			,setL_pos
									 								 			,setL_model
									 								 			,setL_imagesWithPoorLight_var
									 								 			,setL_modelRanking
									 								 			,setL_modelScore
									 								|}) |]
									 								 ((i0::enter -> Transitions(id__,
									 								 		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 								 		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 								 		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
									 								  [[ share__ <- x__ | x__ <- {| share__,setL_image,setL_pos,setL_model,setL_imagesWithPoorLight_var,setL_modelRanking,setL_modelScore |} ]]
									 								 )
									 								)[[setL_image <- set_image,setL_pos <- set_pos,setL_model <- set_model,setL_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setL_modelRanking <- set_modelRanking,setL_modelScore <- set_modelScore]]
									 								)
									 							)
									 							 \ hideSet)
									 							[[
									 								planningCompleted__.x____ <- planningCompleted,
									 								planRejected__.x____ <- planRejected,
									 								requestPlan__.x____ <- requestPlan,
									 								newModel__.x____ <- newModel,
									 								get_newModel__.x____ <- get_newModel,
									 								set_newModel__.x____ <- set_newModel,
									 								imagesWithLight__.x____ <- imagesWithLight,
									 								get_imagesWithLight__.x____ <- get_imagesWithLight,
									 								newConfidences__.x____ <- newConfidences,
									 								get_newConfidences__.x____ <- get_newConfidences,
									 								imagesWithPoorLight__.x____ <- imagesWithPoorLight,
									 								get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight
									 								| x____ <- NIDS
									 							]]
									 						)
									 						[| {|get_CLID_RankModel,RankModel::entered,terminate|} |]
									 						dbisim(Clock_CLID_RankModel(id__,0,
									 								          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 								          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 								          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
									 					)\{|get_CLID_RankModel|}
									 				)
									 				[| {|get_CLID_CheckImage,CheckImage::entered,terminate|} |]
									 				dbisim(Clock_CLID_CheckImage(id__,0,
									 						          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 						          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 						          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
									 			)\{|get_CLID_CheckImage|}
									 		)
									 		[| {|get_CLID_CheckModel,CheckModel::entered,terminate|} |]
									 		dbisim(Clock_CLID_CheckModel(id__,0,
									 				          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 				          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 				          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
									 	)\{|get_CLID_CheckModel|}
									 )
									 ))
									  [[ share__ <- x__ | x__ <- {| share__,setR_image,setR_pos,setR_imagesWithLight_var,setR_model,setR_modelRanking,setR_imagesWithPoorLight_var,setR_modelScore |} ]] 
									  [[set_image <- setL_image,set_pos <- setL_pos,set_imagesWithLight_var <- setL_imagesWithLight_var,set_model <- setL_model,set_modelRanking <- setL_modelRanking,set_imagesWithPoorLight_var <- setL_imagesWithPoorLight_var,set_modelScore <- setL_modelScore]]
									 )
									 [| union(union(enteredSS,{| interrupt, terminate |}),{|share__
									 			,setL_image
									 			,setL_pos
									 			,setL_imagesWithLight_var
									 			,setL_model
									 			,setL_modelRanking
									 			,setL_imagesWithPoorLight_var
									 			,setL_modelScore
									 			,setR_image
									 			 			,setR_pos
									 			 			,setR_imagesWithLight_var
									 			 			,setR_model
									 			 			,setR_modelRanking
									 			 			,setR_imagesWithPoorLight_var
									 			 			,setR_modelScore
									 			|}) |]
									 ((During)
									  [[ share__ <- x__ | x__ <- {| share__,setL_image,setL_pos,setL_imagesWithLight_var,setL_model,setL_modelRanking,setL_imagesWithPoorLight_var,setL_modelScore |} ]]
									  [[set_image <- setR_image,set_pos <- setR_pos,set_imagesWithLight_var <- setR_imagesWithLight_var,set_model <- setR_model,set_modelRanking <- setR_modelRanking,set_imagesWithPoorLight_var <- setR_imagesWithPoorLight_var,set_modelScore <- setR_modelScore]]
									 )
									)[[setL_image <- set_image,setL_pos <- set_pos,setL_imagesWithLight_var <- set_imagesWithLight_var,setL_model <- set_model,setL_modelRanking <- set_modelRanking,setL_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setL_modelScore <- set_modelScore]]
									 [[setR_image <- set_image,setR_pos <- set_pos,setR_imagesWithLight_var <- set_imagesWithLight_var,setR_model <- set_model,setR_modelRanking <- set_modelRanking,setR_imagesWithPoorLight_var <- set_imagesWithPoorLight_var,setR_modelScore <- set_modelScore]]
									)\{terminate} 
								)
								During 		= share__choice(([] e__ : enteredSS @ e__ -> SKIP))
										 	  ; entered -> ((CRUN(enteredSS) ||| SKIP ; SStop) /\ interrupt -> share__choice(terminate -> SKIP))
							within
								Inactive [| {terminate} |> SKIP)
							
							Transitions(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = ((let
								Trans = share__choice(get_image?image -> get_pos?pos -> get_model?model -> get_imagesWithPoorLight_var?imagesWithPoorLight_var -> get_modelRanking?modelRanking -> get_modelScore?modelScore -> TimeOut_1(
									 (share__ -> SKIP
									 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((true&(share__choice(get_imagesWithLight.out -> SKIP));true&(share__choice(imagesWithLight.in?imagesWithLight_var -> (SStop /\ set_imagesWithLight_var!imagesWithLight_var -> SKIP)));true&(share__choice(get_imagesWithPoorLight.out -> SKIP));true&(share__choice(imagesWithPoorLight.in?imagesWithPoorLight_var -> (SStop /\ set_imagesWithPoorLight_var!imagesWithPoorLight_var -> SKIP)));share__choice(true & (share__choice(set_model!1 -> SKIP))) ; CheckModel::enter -> SKIP))))
									 [] dbisim(((model<=const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS))&(internal__!NID_CheckModel -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(true & (share__choice(set_image!1 -> SKIP)));share__choice(share__choice(get_modelScore?modelScore -> true & (share__choice(set_modelScore!(modelScore ^ <0>) -> SKIP)))) ; CheckImage::enter -> SKIP)))
									 [] dbisim(((image<=length(imagesWithPoorLight_var)))&(internal__!NID_CheckImage -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_image?image -> share__choice(get_imagesWithLight_var?imagesWithLight_var -> share__choice(get_model?model -> share__choice(get_imagesWithPoorLight_var?imagesWithPoorLight_var -> share__choice(get_modelScore?modelScore -> (model <= length(modelScore))&(model >= 1) & (share__choice(set_modelScore!update_(modelScore,Plus(access_(modelScore, model), ((let
									 			light = tuple3_2((access_(imagesWithLight_var, access_(imagesWithPoorLight_var, image))))
									 			within
									 				(if ((light<tuple2_1(((callFunc((IDEAL_LIGHTING), (model)))))) or (light>tuple2_2(((callFunc((IDEAL_LIGHTING), (model))))))) then 0 else 1)
									 			)), core_nat),model) -> SKIP)))))))) ; CheckImage::enter -> SKIP)))
									 [] dbisim(((image>length(imagesWithPoorLight_var)))&(internal__!NID_CheckImage -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_model?model -> share__choice(get_modelRanking?modelRanking -> true & (share__choice(set_modelRanking!(<model> ^ modelRanking) -> SKIP)))));share__choice(true & (share__choice(set_pos!1 -> SKIP))) ; RankModel::enter -> SKIP)))
									 [] dbisim((((pos<length(modelRanking)) and (access_(modelScore, model)<=access_(modelScore, access_(modelRanking, Plus(pos, 1, core_nat))))))&(internal__!NID_RankModel -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_pos?pos -> share__choice(get_modelRanking?modelRanking -> (pos <= length(modelRanking))&(pos >= 1)&Plus(pos, 1, core_nat) <= length(modelRanking)&Plus(pos, 1, core_nat) >= 1 & (share__choice(set_modelRanking!update_(modelRanking,access_(modelRanking, Plus(pos, 1, core_nat)),pos) -> SKIP)))));share__choice(share__choice(get_pos?pos -> share__choice(get_model?model -> share__choice(get_modelRanking?modelRanking -> (Plus(pos, 1, core_nat) <= length(modelRanking))&(Plus(pos, 1, core_nat) >= 1) & (share__choice(set_modelRanking!update_(modelRanking,model,Plus(pos, 1, core_nat)) -> SKIP))))));share__choice(share__choice(get_pos?pos -> true & (share__choice(set_pos!Plus(pos, 1, core_nat) -> SKIP)))) ; RankModel::enter -> SKIP)))
									 [] dbisim((((pos>=length(modelRanking)) or (access_(modelScore, model)>access_(modelScore, access_(modelRanking, Plus(pos, 1, core_nat))))))&(internal__!NID_RankModel -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; share__choice(share__choice(get_model?model -> true & (share__choice(set_model!Plus(model, 1, core_nat) -> SKIP)))) ; CheckModel::enter -> SKIP)))
									 [] dbisim(((model>const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS))&(internal__!NID_CheckModel -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; f0::enter -> SKIP)))
									 []
									 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
									 []
									 terminate -> SKIP
									 )
								,SKIP);Trans
								)
							within
								Trans [|{terminate}|> SKIP
							)
							)
							
							
							-- Clocks
							Clock_CLID_CheckModel(id__,x__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
								TimeOut_1(
									CheckModel::entered -> Clock_CLID_CheckModel(id__,0,
											          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
											          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
											          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									[]
									get_CLID_CheckModel!x__ -> Clock_CLID_CheckModel(id__,x__,
											          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
											          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
											          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									[]
									terminate -> SKIP,Clock_CLID_CheckModel(id__,clock_type_plus(x__,1,CLID_CheckModel_clock_type(id__,
											          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
											          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
											          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
											          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
											          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
											          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
							Clock_CLID_CheckImage(id__,x__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
								TimeOut_1(
									CheckImage::entered -> Clock_CLID_CheckImage(id__,0,
											          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
											          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
											          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									[]
									get_CLID_CheckImage!x__ -> Clock_CLID_CheckImage(id__,x__,
											          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
											          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
											          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									[]
									terminate -> SKIP,Clock_CLID_CheckImage(id__,clock_type_plus(x__,1,CLID_CheckImage_clock_type(id__,
											          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
											          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
											          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
											          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
											          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
											          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
							Clock_CLID_RankModel(id__,x__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
								TimeOut_1(
									RankModel::entered -> Clock_CLID_RankModel(id__,0,
											          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
											          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
											          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									[]
									get_CLID_RankModel!x__ -> Clock_CLID_RankModel(id__,x__,
											          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
											          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
											          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									[]
									terminate -> SKIP,Clock_CLID_RankModel(id__,clock_type_plus(x__,1,CLID_RankModel_clock_type(id__,
											          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
											          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
											          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
											          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
											          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
											          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
							
							StateClocks(id__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = dbisim(Clock_CLID_CheckModel(id__,0,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
							[| { terminate } |] (
							dbisim(Clock_CLID_CheckImage(id__,0,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
							[| { terminate } |] (
							dbisim(Clock_CLID_RankModel(id__,0,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
							)
							)
							
							stateClockSync = {|get_CLID_CheckModel,CheckModel::entered,get_CLID_CheckImage,CheckImage::entered,get_CLID_RankModel,RankModel::entered|}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: PlanMade
					module PlanMade
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_modelRanking?modelRanking -> pre_sequence_toolkit_head(modelRanking)&(share__choice(set_newModel.out!sequence_toolkit_head(modelRanking) -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_modelRanking?modelRanking -> pre_sequence_toolkit_head(modelRanking)&(share__choice(set_newModel.out!sequence_toolkit_head(modelRanking) -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: WaitForVerification
					module WaitForVerification
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Replan
					module Replan
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_modelRanking?modelRanking -> true&(if (length(modelRanking)>0) then (share__choice(share__choice(get_modelRanking?modelRanking -> true & (share__choice(set_modelRanking!sequence_toolkit_tail(modelRanking) -> SKIP))))) else (share__choice(true & (share__choice(set_modelRanking!<const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL> -> SKIP)))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= share__choice(get_modelRanking?modelRanking -> true&(if (length(modelRanking)>0) then (share__choice(share__choice(get_modelRanking?modelRanking -> true & (share__choice(set_modelRanking!sequence_toolkit_tail(modelRanking) -> SKIP))))) else (share__choice(true & (share__choice(set_modelRanking!<const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL> -> SKIP)))))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__,
										    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					)\sharedVarHide
					
					STM_VS_O(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__,
										    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
										    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
										    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__,
								    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
								    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
								    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					)\sharedVarHide
					
					-- Transitions
					Transitions(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; Initialise::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_Initialise -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForSignal::enter -> SKIP)))
							 [] dbisim((true)&(requestPlan__!NID_WaitForSignal.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; MakePlan::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_MakePlan -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; PlanMade::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_PlanMade -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(planningCompleted.out -> SKIP)) ; WaitForVerification::enter -> SKIP)))
							 [] dbisim((true)&(requestPlan__!NID_WaitForVerification.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; MakePlan::enter -> SKIP)))
							 [] dbisim((true)&(planRejected__!NID_WaitForVerification.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; Replan::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_Replan -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; PlanMade::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Initialise::enter,
								WaitForSignal::enter,
								MakePlan::enter,
								PlanMade::enter,
								WaitForVerification::enter,
								Replan::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_Initialise,requestPlan__.NID_WaitForSignal.in,internal__.NID_MakePlan,internal__.NID_PlanMade,requestPlan__.NID_WaitForVerification.in,planRejected__.NID_WaitForVerification.in,internal__.NID_Replan|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__,
									   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									   [| { share__, terminate } |] (
									   Initialise::D__(id__,
									   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									   [| { share__, terminate } |] (
									   WaitForSignal::D__(id__,
									   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									   [| { share__, terminate } |] (
									   MakePlan::D__(id__,
									   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									   [| { share__, terminate } |] (
									   PlanMade::D__(id__,
									   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									   [| { share__, terminate } |] (
									   WaitForVerification::D__(id__,
									   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									   [| { share__, terminate } |] (
									   Replan::D__(id__,
									   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									   )
									   )
									   )
									   )
									   )
									   )
									 )
									 [[Initialise::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialise|}]]
									 [[WaitForSignal::interrupt <- x__ | x__ <- {|interrupt,requestPlan__.NID_WaitForSignal.in|}]]
									 [[MakePlan::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_MakePlan|}]]
									 [[PlanMade::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_PlanMade|}]]
									 [[WaitForVerification::interrupt <- x__ | x__ <- {|interrupt,requestPlan__.NID_WaitForVerification.in,planRejected__.NID_WaitForVerification.in|}]]
									 [[Replan::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Replan|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
								[[
									planningCompleted__.x____ <- planningCompleted,
									planRejected__.x____ <- planRejected,
									requestPlan__.x____ <- requestPlan,
									newModel__.x____ <- newModel,
									get_newModel__.x____ <- get_newModel,
									set_newModel__.x____ <- set_newModel,
									imagesWithLight__.x____ <- imagesWithLight,
									get_imagesWithLight__.x____ <- get_imagesWithLight,
									newConfidences__.x____ <- newConfidences,
									get_newConfidences__.x____ <- get_newConfidences,
									imagesWithPoorLight__.x____ <- imagesWithPoorLight,
									get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							 		          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							 		          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						dbisim((let
							stateClockSync = {|get_CLID_PlanMade,PlanMade::entered,get_CLID_Replan,Replan::entered,get_CLID_MakePlan,MakePlan::entered,get_CLID_WaitForSignal,WaitForSignal::entered,get_CLID_Initialise,Initialise::entered,get_CLID_WaitForVerification,WaitForVerification::entered|}
						 within
							(MachineBody(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						dbisim((let
							stateClockSync = {|get_CLID_PlanMade,PlanMade::entered,get_CLID_Replan,Replan::entered,get_CLID_MakePlan,MakePlan::entered,get_CLID_WaitForSignal,WaitForSignal::entered,get_CLID_Initialise,Initialise::entered,get_CLID_WaitForVerification,WaitForVerification::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			MachineBody(id__,
																					    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																					    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																					    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
																			[| {|get_CLID_WaitForVerification,WaitForVerification::entered,terminate|} |]
																			dbisim(Clock_CLID_WaitForVerification(id__,0,
																					          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																					          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																					          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
																		)\{|get_CLID_WaitForVerification|}
																	)
																	[| {|get_CLID_Initialise,Initialise::entered,terminate|} |]
																	dbisim(Clock_CLID_Initialise(id__,0,
																			          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																			          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																			          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
																)\{|get_CLID_Initialise|}
															)
															[| {|get_CLID_WaitForSignal,WaitForSignal::entered,terminate|} |]
															dbisim(Clock_CLID_WaitForSignal(id__,0,
																	          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																	          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																	          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
														)\{|get_CLID_WaitForSignal|}
													)
													[| {|get_CLID_MakePlan,MakePlan::entered,terminate|} |]
													dbisim(Clock_CLID_MakePlan(id__,0,
															          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
															          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
															          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
												)\{|get_CLID_MakePlan|}
											)
											[| {|get_CLID_Replan,Replan::entered,terminate|} |]
											dbisim(Clock_CLID_Replan(id__,0,
													          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
													          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
													          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
										)\{|get_CLID_Replan|}
									)
									[| {|get_CLID_PlanMade,PlanMade::entered,terminate|} |]
									dbisim(Clock_CLID_PlanMade(id__,0,
											          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
											          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
											          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
								)\{|get_CLID_PlanMade|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						((let
							getsetLocalChannels = {|get_modelScore,set_modelScore,
							get_modelRanking,set_modelRanking,
							get_model,set_model,
							get_image,set_image,
							get_pos,set_pos,
							get_imagesWithLight_var,set_imagesWithLight_var,
							get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
							clockSync = {||}
						within
							(Behaviour(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							 		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							 		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) [| {terminate} |] Clocks(id__,
							 		          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							 		          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							 		          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				IteratedBehaviour(id__,
																						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
																				[| {|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,terminate|} |]
																				Memory_imagesWithPoorLight_var(<>)
																			)\{|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
																		)
																		[| {|get_imagesWithLight_var,set_imagesWithLight_var,terminate|} |]
																		Memory_imagesWithLight_var(<>)
																	)\{|get_imagesWithLight_var,set_imagesWithLight_var|}
																)
																[| {|get_pos,set_pos,terminate|} |]
																Memory_pos(0)
															)\{|get_pos,set_pos|}
														)
														[| {|get_image,set_image,terminate|} |]
														Memory_image(0)
													)\{|get_image,set_image|}
												)
												[| {|get_model,set_model,terminate|} |]
												Memory_model(0)
											)\{|get_model,set_model|}
										)
										[| {|get_modelRanking,set_modelRanking,terminate|} |]
										Memory_modelRanking(<>)
									)\{|get_modelRanking,set_modelRanking|}
								)
								[| {|get_modelScore,set_modelScore,terminate|} |]
								Memory_modelScore(<>)
							)\{|get_modelScore,set_modelScore|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Initialise::enter,
								WaitForSignal::enter,
								MakePlan::enter,
								PlanMade::enter,
								WaitForVerification::enter,
								Replan::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_Initialise,requestPlan__.NID_WaitForSignal.in,internal__.NID_MakePlan,internal__.NID_PlanMade,requestPlan__.NID_WaitForVerification.in,planRejected__.NID_WaitForVerification.in,internal__.NID_Replan|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__,
									   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									   [| { share__, terminate } |] (
									   Initialise::VS_O__(id__,
									   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									   [| { share__, terminate } |] (
									   WaitForSignal::VS_O__(id__,
									   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									   [| { share__, terminate } |] (
									   MakePlan::VS_O__(id__,
									   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									   [| { share__, terminate } |] (
									   PlanMade::VS_O__(id__,
									   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									   [| { share__, terminate } |] (
									   WaitForVerification::VS_O__(id__,
									   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									   [| { share__, terminate } |] (
									   Replan::VS_O__(id__,
									   		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									   		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									   		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
									   )
									   )
									   )
									   )
									   )
									   )
									 )
									 [[Initialise::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialise|}]]
									 [[WaitForSignal::interrupt <- x__ | x__ <- {|interrupt,requestPlan__.NID_WaitForSignal.in|}]]
									 [[MakePlan::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_MakePlan|}]]
									 [[PlanMade::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_PlanMade|}]]
									 [[WaitForVerification::interrupt <- x__ | x__ <- {|interrupt,requestPlan__.NID_WaitForVerification.in,planRejected__.NID_WaitForVerification.in|}]]
									 [[Replan::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Replan|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__,
									 		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									 		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									 		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
								[[
									planningCompleted__.x____ <- planningCompleted,
									planRejected__.x____ <- planRejected,
									requestPlan__.x____ <- requestPlan,
									newModel__.x____ <- newModel,
									get_newModel__.x____ <- get_newModel,
									set_newModel__.x____ <- set_newModel,
									imagesWithLight__.x____ <- imagesWithLight,
									get_imagesWithLight__.x____ <- get_imagesWithLight,
									newConfidences__.x____ <- newConfidences,
									get_newConfidences__.x____ <- get_newConfidences,
									imagesWithPoorLight__.x____ <- imagesWithPoorLight,
									get_imagesWithPoorLight__.x____ <- get_imagesWithPoorLight
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__,
							 		          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							 		          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							 		          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						dbisim((let
							stateClockSync = {|get_CLID_PlanMade,PlanMade::entered,get_CLID_Replan,Replan::entered,get_CLID_MakePlan,MakePlan::entered,get_CLID_WaitForSignal,WaitForSignal::entered,get_CLID_Initialise,Initialise::entered,get_CLID_WaitForVerification,WaitForVerification::entered|}
						 within
							(MachineBody_VS_O(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) [| union(stateClockSync,{terminate}) |] StateClocks(id__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						dbisim((let
							stateClockSync = {|get_CLID_PlanMade,PlanMade::entered,get_CLID_Replan,Replan::entered,get_CLID_MakePlan,MakePlan::entered,get_CLID_WaitForSignal,WaitForSignal::entered,get_CLID_Initialise,Initialise::entered,get_CLID_WaitForVerification,WaitForVerification::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															dbisim(
																sbisim(
																	dbisim(
																		sbisim(
																			MachineBody_VS_O(id__,
																					    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																					    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																					    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
																			[| {|get_CLID_WaitForVerification,WaitForVerification::entered,terminate|} |]
																			dbisim(Clock_CLID_WaitForVerification(id__,0,
																					          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																					          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																					          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
																		)\{|get_CLID_WaitForVerification|}
																	)
																	[| {|get_CLID_Initialise,Initialise::entered,terminate|} |]
																	dbisim(Clock_CLID_Initialise(id__,0,
																			          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																			          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																			          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
																)\{|get_CLID_Initialise|}
															)
															[| {|get_CLID_WaitForSignal,WaitForSignal::entered,terminate|} |]
															dbisim(Clock_CLID_WaitForSignal(id__,0,
																	          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																	          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																	          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
														)\{|get_CLID_WaitForSignal|}
													)
													[| {|get_CLID_MakePlan,MakePlan::entered,terminate|} |]
													dbisim(Clock_CLID_MakePlan(id__,0,
															          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
															          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
															          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
												)\{|get_CLID_MakePlan|}
											)
											[| {|get_CLID_Replan,Replan::entered,terminate|} |]
											dbisim(Clock_CLID_Replan(id__,0,
													          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
													          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
													          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
										)\{|get_CLID_Replan|}
									)
									[| {|get_CLID_PlanMade,PlanMade::entered,terminate|} |]
									dbisim(Clock_CLID_PlanMade(id__,0,
											          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
											          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
											          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
								)\{|get_CLID_PlanMade|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						dbisim((let
							getsetLocalChannels = {|get_modelScore,set_modelScore,
							get_modelRanking,set_modelRanking,
							get_model,set_model,
							get_image,set_image,
							get_pos,set_pos,
							get_imagesWithLight_var,set_imagesWithLight_var,
							get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__,
									    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__,
							 		    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							 		    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							 		    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) [| {terminate} |] Clocks(id__,
							 		          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							 		          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							 		          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) =
						(dbisim(
							sbisim(
								dbisim(
									sbisim(
										dbisim(
											sbisim(
												dbisim(
													sbisim(
														dbisim(
															sbisim(
																dbisim(
																	sbisim(
																		dbisim(
																			sbisim(
																				IteratedBehaviour_VS_O(id__,
																						    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
																						    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
																						    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
																				[| {|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var,terminate|} |]
																				Memory_imagesWithPoorLight_var(<>)
																			)\{|get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
																		)
																		[| {|get_imagesWithLight_var,set_imagesWithLight_var,terminate|} |]
																		Memory_imagesWithLight_var(<>)
																	)\{|get_imagesWithLight_var,set_imagesWithLight_var|}
																)
																[| {|get_pos,set_pos,terminate|} |]
																Memory_pos(0)
															)\{|get_pos,set_pos|}
														)
														[| {|get_image,set_image,terminate|} |]
														Memory_image(0)
													)\{|get_image,set_image|}
												)
												[| {|get_model,set_model,terminate|} |]
												Memory_model(0)
											)\{|get_model,set_model|}
										)
										[| {|get_modelRanking,set_modelRanking,terminate|} |]
										Memory_modelRanking(<>)
									)\{|get_modelRanking,set_modelRanking|}
								)
								[| {|get_modelScore,set_modelScore,terminate|} |]
								Memory_modelScore(<>)
							)\{|get_modelScore,set_modelScore|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_modelScore(modelScore) =
						get_modelScore!modelScore -> Memory_modelScore(modelScore)
						[]
						set_modelScore?x__ -> Memory_modelScore(x__)
						[]
						terminate -> SKIP
					Memory_modelRanking(modelRanking) =
						get_modelRanking!modelRanking -> Memory_modelRanking(modelRanking)
						[]
						set_modelRanking?x__ -> Memory_modelRanking(x__)
						[]
						terminate -> SKIP
					Memory_model(model) =
						get_model!model -> Memory_model(model)
						[]
						set_model?x__ -> Memory_model(x__)
						[]
						terminate -> SKIP
					Memory_image(image) =
						get_image!image -> Memory_image(image)
						[]
						set_image?x__ -> Memory_image(x__)
						[]
						terminate -> SKIP
					Memory_pos(pos) =
						get_pos!pos -> Memory_pos(pos)
						[]
						set_pos?x__ -> Memory_pos(x__)
						[]
						terminate -> SKIP
					Memory_imagesWithLight_var(imagesWithLight_var) =
						get_imagesWithLight_var!imagesWithLight_var -> Memory_imagesWithLight_var(imagesWithLight_var)
						[]
						set_imagesWithLight_var?x__ -> Memory_imagesWithLight_var(x__)
						[]
						terminate -> SKIP
					Memory_imagesWithPoorLight_var(imagesWithPoorLight_var) =
						get_imagesWithPoorLight_var!imagesWithPoorLight_var -> Memory_imagesWithPoorLight_var(imagesWithPoorLight_var)
						[]
						set_imagesWithPoorLight_var?x__ -> Memory_imagesWithPoorLight_var(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = Memory_modelScore(<>)
					[| { terminate } |] (
					Memory_modelRanking(<>)
					[| { terminate } |] (
					Memory_model(0)
					[| { terminate } |] (
					Memory_image(0)
					[| { terminate } |] (
					Memory_pos(0)
					[| { terminate } |] (
					Memory_imagesWithLight_var(<>)
					[| { terminate } |] (
					Memory_imagesWithPoorLight_var(<>)
					)
					)
					)
					)
					)
					)
					
					getsetLocalChannels = {|get_modelScore,set_modelScore,get_modelRanking,set_modelRanking,get_model,set_model,get_image,set_image,get_pos,set_pos,get_imagesWithLight_var,set_imagesWithLight_var,get_imagesWithPoorLight_var,set_imagesWithPoorLight_var|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = STM_VS_O(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) \ localClockResets
					D__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = timed_priority(STM(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) \ union(internal_events,localClockResets))
					O__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = dbisim(D__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					VS__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = FVS__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
					VS_O__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = dbisim(FVS__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					HEXT__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = O__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) [|shared_variable_events|] SKIP
					FVS_C__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = dbisim(timed_priority(STM(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) \ internal_events))
					HUP__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = timed_priority(O__(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_PlanMade(id__,x__,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						TimeOut_1(
							PlanMade::entered -> Clock_CLID_PlanMade(id__,0,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							[]
							get_CLID_PlanMade!x__ -> Clock_CLID_PlanMade(id__,x__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							[]
							terminate -> SKIP,Clock_CLID_PlanMade(id__,clock_type_plus(x__,1,CLID_PlanMade_clock_type(id__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					Clock_CLID_Replan(id__,x__,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						TimeOut_1(
							Replan::entered -> Clock_CLID_Replan(id__,0,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							[]
							get_CLID_Replan!x__ -> Clock_CLID_Replan(id__,x__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							[]
							terminate -> SKIP,Clock_CLID_Replan(id__,clock_type_plus(x__,1,CLID_Replan_clock_type(id__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					Clock_CLID_MakePlan(id__,x__,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						TimeOut_1(
							MakePlan::entered -> Clock_CLID_MakePlan(id__,0,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							[]
							get_CLID_MakePlan!x__ -> Clock_CLID_MakePlan(id__,x__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							[]
							terminate -> SKIP,Clock_CLID_MakePlan(id__,clock_type_plus(x__,1,CLID_MakePlan_clock_type(id__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					Clock_CLID_WaitForSignal(id__,x__,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						TimeOut_1(
							WaitForSignal::entered -> Clock_CLID_WaitForSignal(id__,0,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							[]
							get_CLID_WaitForSignal!x__ -> Clock_CLID_WaitForSignal(id__,x__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							[]
							terminate -> SKIP,Clock_CLID_WaitForSignal(id__,clock_type_plus(x__,1,CLID_WaitForSignal_clock_type(id__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					Clock_CLID_Initialise(id__,x__,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						TimeOut_1(
							Initialise::entered -> Clock_CLID_Initialise(id__,0,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							[]
							get_CLID_Initialise!x__ -> Clock_CLID_Initialise(id__,x__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							[]
							terminate -> SKIP,Clock_CLID_Initialise(id__,clock_type_plus(x__,1,CLID_Initialise_clock_type(id__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					Clock_CLID_WaitForVerification(id__,x__,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = 
						TimeOut_1(
							WaitForVerification::entered -> Clock_CLID_WaitForVerification(id__,0,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							[]
							get_CLID_WaitForVerification!x__ -> Clock_CLID_WaitForVerification(id__,x__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)
							[]
							terminate -> SKIP,Clock_CLID_WaitForVerification(id__,clock_type_plus(x__,1,CLID_WaitForVerification_clock_type(id__,
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)),
									          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
									          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
									          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					
					StateClocks(id__,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = dbisim(Clock_CLID_PlanMade(id__,0,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					[| { terminate } |] (
					dbisim(Clock_CLID_Replan(id__,0,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					[| { terminate } |] (
					dbisim(Clock_CLID_MakePlan(id__,0,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					[| { terminate } |] (
					dbisim(Clock_CLID_WaitForSignal(id__,0,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					[| { terminate } |] (
					dbisim(Clock_CLID_Initialise(id__,0,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					[| { terminate } |] (
					dbisim(Clock_CLID_WaitForVerification(id__,0,
							          const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							          const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							          const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL))
					)
					)
					)
					)
					)
					
					stateClockSync = {|get_CLID_PlanMade,PlanMade::entered,get_CLID_Replan,Replan::entered,get_CLID_MakePlan,MakePlan::entered,get_CLID_WaitForSignal,WaitForSignal::entered,get_CLID_Initialise,Initialise::entered,get_CLID_WaitForVerification,WaitForVerification::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__,
							    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
							    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
							    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			module stm_ref4
			exports
				transparent diamond
				transparent sbisim
				transparent dbisim
				transparent chase
			
				-- Transition identifiers
				-- declaring identifiers of transitions
				datatype NIDS = 
				              NID_i0|
				              NID_Initialise|
				              NID_WaitForSignal|
				              NID_SendOutputs|
				              NID_FinishAdaptation
				
				channel internal__ : NIDS
				
				-- Flow channels		
				channel interrupt
				channel exited
				channel exit
				channel terminate
				
				-- Variable channels
				channel get_newModel_var, set_newModel_var, setL_newModel_var, setR_newModel_var: core_nat
				
				-- Shared variable channels
				
				-- Local variable channels for defined operations that are required by the state machine
				
				-- Declaring state machine events
				channel executePlan__: NIDS.InOut
				channel executePlan: InOut
				channel adaptationCompleted__: NIDS.InOut
				channel adaptationCompleted: InOut
				channel newModel__: NIDS.InOut.core_nat
				channel newModel: InOut.core_nat
				channel get_newModel__: NIDS.InOut
				channel get_newModel: InOut
				channel switchModel__: NIDS.InOut.core_nat
				channel switchModel: InOut.core_nat
				
				-- Declaring call and ret events for undefined operations
				
				enterSS = {|
				i0::enter,
				Initialise::enter,
				WaitForSignal::enter,
				SendOutputs::enter,
				FinishAdaptation::enter
				|}
				
				enteredSS = 	{|
				Initialise::entered,
				WaitForSignal::entered,
				SendOutputs::entered,
				FinishAdaptation::entered
				|}
				
				internal_events = union(enteredSS,union(enterSS,{|interrupt,exited|}))
				
				shared_variable_events = {|
				|}
				
				-- channel set with all visible events
				sem__events = {|
					terminate
				,	executePlan,
					adaptationCompleted,
					newModel,
					get_newModel,
					switchModel
					|}
				
				channel clockReset, clockResetL, clockResetR 
				
				localClockResets = {||}
				
				
				channel get_CLID_SendOutputs : core_clock_type 
				channel get_CLID_WaitForSignal : core_clock_type 
				channel get_CLID_FinishAdaptation : core_clock_type 
				channel get_CLID_Initialise : core_clock_type 
				--channel increment__
				
				CLID_SendOutputs_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_WaitForSignal_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_FinishAdaptation_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				CLID_Initialise_clock_type(id__) = 
					let
						max = (clock_type_max(Union({
				}))+1)
					ctype = {0..max}
				within
					if member(max,core_clock_type) then ctype else error("core_clock_type is not wide enough")
				
				
			
					-- Nodes --
					-- declaring all nodes
					
					----------------------------------------------------------------------
					-- Initial: i0
					module i0
					exports
					
						channel enter, interrupt
						
						Timed(OneStep) {
							D__(id__) = 
								dbisim(let
									Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
									
									Termination = terminate -> SKIP
									
									Active 		= share__choice(interrupt -> SKIP) ; Inactive
								within
									Inactive [| {terminate} |> SKIP)
							
							VS_O__(id__) = D__(id__)
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: Initialise
					module Initialise
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: WaitForSignal
					module WaitForSignal
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: SendOutputs
					module SendOutputs
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(get_newModel.out -> SKIP));true&(share__choice(newModel.in?newModel_var -> (SStop /\ set_newModel_var!newModel_var -> SKIP)));share__choice(get_newModel_var?newModel_var -> true&(share__choice(switchModel.out!newModel_var -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= true&(share__choice(get_newModel.out -> SKIP));true&(share__choice(newModel.in?newModel_var -> (SStop /\ set_newModel_var!newModel_var -> SKIP)));share__choice(get_newModel_var?newModel_var -> true&(share__choice(switchModel.out!newModel_var -> SKIP))) ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					
					----------------------------------------------------------------------
					-- State: FinishAdaptation
					module FinishAdaptation
					
					enterSS = {}
					
					enteredSS = {}
					
					exports
					
						--  Declarations
						
						channel enter, entered, interrupt
						channel enteredL, enteredR
						
										
						
						--channel increment__
						
						
						--	Nodes
						-- declaring all nodes
						
						
						Timed(OneStep) {
							--	Rule: behaviours(Node)
							--  Note that FDR has problems with efficiently compiling the process below
							-- 	if using a different recursion pattern.
							D__(id__) = 
							dbisim(let
								-- IMPLEMENTATION NOTE: 
								-- The following should be defined as: Inactive = share__choice(Activation [] Termination),
								-- however FDR struggles with that form in certain cases. So we use the exception operator
								-- instead to 'terminate'.
								
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
								
							VS_O__(id__) = 
							dbisim(let
								Inactive 	= share__choice(enter -> SKIP [] terminate -> SKIP) ; Active
								
								Termination = terminate -> SKIP
								
								Active 		= SKIP ; 
										 	  Behaviour ; 
										 	  share__choice(exit -> SKIP) ; SKIP ; 
										 	  share__choice(exited -> SKIP) ; Inactive
							
								Behaviour 	= entered -> During
								During 		= ((SKIP ; SStop) /\ interrupt -> SKIP)
							within
								Inactive [| {terminate} |> SKIP)
							
							
							-- Clocks
							
							StateClocks(id__) = terminate -> SKIP
							
							stateClockSync = {||}
						}
					
					endmodule
					----------------------------------------------------------------------
					
					-- END of Nodes --
					
					Timed(OneStep) {
					-- Operation calls --
					-- Only the undefined operations are declared here.
					-- If the state machine is in isolation, all required operations will be undefined.
					-- If it is in the context of a controller, the required operations not provided by the
					-- controller will be declared here, and the defined operations will be defined in the
					-- context of the Controller module, and therefore within scope of the state machine module.
					
					-- END of Operation calls --
				
					-- STM processes
					STM(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					
					STM_VS_O(id__) = -- RULE: [[stm:StateMachineDef]]_STM^nops : CSPProcess
					( 
						(
							(
								(IteratedStateful_VS_O(id__) \ {terminate} ; share__choice(terminate -> SKIP))
							 	[[ share__ <- x__ | x__ <- {||} ]]
							)
						[| {share__} |]
						SKIP
						)
						[| union(sharedVarSync,{terminate}) |]
						dbisim(sharedVarMemory(id__))
					)\sharedVarHide
					
					-- Transitions
					Transitions(id__) = ((let
						Trans = TimeOut_1(
							 (share__ -> SKIP
							 [] dbisim((true)&(internal__!NID_i0 -> SKIP ;  ((SKIP ; Initialise::enter -> SKIP))))
							 [] dbisim((true)&(internal__!NID_Initialise -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForSignal::enter -> SKIP)))
							 [] dbisim((true)&(executePlan__!NID_WaitForSignal.in -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; SendOutputs::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_SendOutputs -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; true&(share__choice(adaptationCompleted.out -> SKIP)) ; FinishAdaptation::enter -> SKIP)))
							 [] dbisim((true)&(internal__!NID_FinishAdaptation -> SKIP ;  share__choice(exit -> SKIP) ; (share__choice(exited -> SKIP) ; SKIP ; WaitForSignal::enter -> SKIP)))
							 []
							 (interrupt -> share__choice(exit -> SKIP) ; share__choice(exited -> terminate -> SKIP))
							 []
							 terminate -> SKIP
							 )
						,SKIP);Trans
					within
						Trans [|{terminate}|> SKIP
					)
					)
					
					-- Stateful
					-- RULE: Stateful(stm:StateMachineBody) : CSPProcess
					
					-- Named process definitions
					MachineBody(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Initialise::enter,
								WaitForSignal::enter,
								SendOutputs::enter,
								FinishAdaptation::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_Initialise,executePlan__.NID_WaitForSignal.in,internal__.NID_SendOutputs,internal__.NID_FinishAdaptation|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::D__(id__)
									   [| { share__, terminate } |] (
									   Initialise::D__(id__)
									   [| { share__, terminate } |] (
									   WaitForSignal::D__(id__)
									   [| { share__, terminate } |] (
									   SendOutputs::D__(id__)
									   [| { share__, terminate } |] (
									   FinishAdaptation::D__(id__)
									   )
									   )
									   )
									   )
									 )
									 [[Initialise::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialise|}]]
									 [[WaitForSignal::interrupt <- x__ | x__ <- {|interrupt,executePlan__.NID_WaitForSignal.in|}]]
									 [[SendOutputs::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SendOutputs|}]]
									 [[FinishAdaptation::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_FinishAdaptation|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
								[[
									executePlan__.x____ <- executePlan,
									adaptationCompleted__.x____ <- adaptationCompleted,
									newModel__.x____ <- newModel,
									get_newModel__.x____ <- get_newModel,
									switchModel__.x____ <- switchModel
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_SendOutputs,SendOutputs::entered,get_CLID_WaitForSignal,WaitForSignal::entered,get_CLID_FinishAdaptation,FinishAdaptation::entered,get_CLID_Initialise,Initialise::entered|}
						 within
							(MachineBody(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ union(stateClockSync,enteredSS)
						)
						)
					
					IteratedBehaviour(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_SendOutputs,SendOutputs::entered,get_CLID_WaitForSignal,WaitForSignal::entered,get_CLID_FinishAdaptation,FinishAdaptation::entered,get_CLID_Initialise,Initialise::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody(id__)
															[| {|get_CLID_Initialise,Initialise::entered,terminate|} |]
															dbisim(Clock_CLID_Initialise(id__,0))
														)\{|get_CLID_Initialise|}
													)
													[| {|get_CLID_FinishAdaptation,FinishAdaptation::entered,terminate|} |]
													dbisim(Clock_CLID_FinishAdaptation(id__,0))
												)\{|get_CLID_FinishAdaptation|}
											)
											[| {|get_CLID_WaitForSignal,WaitForSignal::entered,terminate|} |]
											dbisim(Clock_CLID_WaitForSignal(id__,0))
										)\{|get_CLID_WaitForSignal|}
									)
									[| {|get_CLID_SendOutputs,SendOutputs::entered,terminate|} |]
									dbisim(Clock_CLID_SendOutputs(id__,0))
								)\{|get_CLID_SendOutputs|}
							)
							) \ union(stateClockSync,enteredSS)
						)
						)
					
					Stateful(id__) = 
						((let
							getsetLocalChannels = {|get_newModel_var,set_newModel_var|}
							clockSync = {||}
						within
							(Behaviour(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful(id__) =
						(dbisim(
							sbisim(
								IteratedBehaviour(id__)
								[| {|get_newModel_var,set_newModel_var,terminate|} |]
								Memory_newModel_var(0)
							)\{|get_newModel_var,set_newModel_var|}
						)
						)
					
					-- Visible counterparts
					MachineBody_VS_O(id__) = 
						dbisim((
						let
							finalNodesEntered = {||}
						within
							(dbisim((dbisim((let
								-- IMPLEMENTATION NOTE:
								-- Here the 'enter' channel set is calculated explicitly because of the use of CSPM 
								-- modules for defining the semantics of each node.
								enterSS = {|
								i0::enter,
								Initialise::enter,
								WaitForSignal::enter,
								SendOutputs::enter,
								FinishAdaptation::enter
								|}
								hideSet = union(enterSS,{|exit,exited,internal__|})
							within 
								((let
									-- IMPLEMENTATION NOTE: the channel set 'enter' is calculated explicitly
									-- because CSPM modules are used for the semantics of Node.
									flowevts = union(enterSS,{|exit,exited,interrupt|})
									transSync = {|internal__.NID_i0,internal__.NID_Initialise,executePlan__.NID_WaitForSignal.in,internal__.NID_SendOutputs,internal__.NID_FinishAdaptation|}
								within
									((
									 (((-- RULE composeNodes(nc:NodeContainer)^nops : CSPProcess
									   i0::VS_O__(id__)
									   [| { share__, terminate } |] (
									   Initialise::VS_O__(id__)
									   [| { share__, terminate } |] (
									   WaitForSignal::VS_O__(id__)
									   [| { share__, terminate } |] (
									   SendOutputs::VS_O__(id__)
									   [| { share__, terminate } |] (
									   FinishAdaptation::VS_O__(id__)
									   )
									   )
									   )
									   )
									 )
									 [[Initialise::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_Initialise|}]]
									 [[WaitForSignal::interrupt <- x__ | x__ <- {|interrupt,executePlan__.NID_WaitForSignal.in|}]]
									 [[SendOutputs::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_SendOutputs|}]]
									 [[FinishAdaptation::interrupt <- x__ | x__ <- {|interrupt,internal__.NID_FinishAdaptation|}]]
									 [[i0::interrupt <- x__ | x__ <- {|internal__.NID_i0|}]]
									 )
									  [[ share__ <- x__ | x__ <- {| share__ |} ]] 
									 )
									 [| union(union(union(flowevts,transSync),{terminate}),{|share__
									|}) |]
									 ((i0::enter -> Transitions(id__))
									  [[ share__ <- x__ | x__ <- {| share__ |} ]]
									 )
									)
									)
								)
								 \ hideSet)
								[[
									executePlan__.x____ <- executePlan,
									adaptationCompleted__.x____ <- adaptationCompleted,
									newModel__.x____ <- newModel,
									get_newModel__.x____ <- get_newModel,
									switchModel__.x____ <- switchModel
									| x____ <- NIDS
								]]
							)
							)
							 [| union(stateClockSync,{terminate}) |]
							 StateClocks(id__)
							)\diff(stateClockSync,enteredSS))
							 [| {| interrupt |} |] SKIP)
						)
						)
					
					Behaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_SendOutputs,SendOutputs::entered,get_CLID_WaitForSignal,WaitForSignal::entered,get_CLID_FinishAdaptation,FinishAdaptation::entered,get_CLID_Initialise,Initialise::entered|}
						 within
							(MachineBody_VS_O(id__) [| union(stateClockSync,{terminate}) |] StateClocks(id__)) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					IteratedBehaviour_VS_O(id__) = 
						dbisim((let
							stateClockSync = {|get_CLID_SendOutputs,SendOutputs::entered,get_CLID_WaitForSignal,WaitForSignal::entered,get_CLID_FinishAdaptation,FinishAdaptation::entered,get_CLID_Initialise,Initialise::entered|}
						 within
							(dbisim(
								sbisim(
									dbisim(
										sbisim(
											dbisim(
												sbisim(
													dbisim(
														sbisim(
															MachineBody_VS_O(id__)
															[| {|get_CLID_Initialise,Initialise::entered,terminate|} |]
															dbisim(Clock_CLID_Initialise(id__,0))
														)\{|get_CLID_Initialise|}
													)
													[| {|get_CLID_FinishAdaptation,FinishAdaptation::entered,terminate|} |]
													dbisim(Clock_CLID_FinishAdaptation(id__,0))
												)\{|get_CLID_FinishAdaptation|}
											)
											[| {|get_CLID_WaitForSignal,WaitForSignal::entered,terminate|} |]
											dbisim(Clock_CLID_WaitForSignal(id__,0))
										)\{|get_CLID_WaitForSignal|}
									)
									[| {|get_CLID_SendOutputs,SendOutputs::entered,terminate|} |]
									dbisim(Clock_CLID_SendOutputs(id__,0))
								)\{|get_CLID_SendOutputs|}
							)
							) \ diff(union(stateClockSync,enteredSS),enteredSS)
						)
						)
					
					Stateful_VS_O(id__) = 
						dbisim((let
							getsetLocalChannels = {|get_newModel_var,set_newModel_var|}
							clockSync = {||}
						within
							(Behaviour_VS_O(id__) 
							 [| union(union(getsetLocalChannels,clockSync),{terminate}) |] 
							 (varMemory(id__) [| {terminate} |] Clocks(id__))
						 	)\union(getsetLocalChannels,clockSync)
						)
						)
					
					IteratedStateful_VS_O(id__) =
						(dbisim(
							sbisim(
								IteratedBehaviour_VS_O(id__)
								[| {|get_newModel_var,set_newModel_var,terminate|} |]
								Memory_newModel_var(0)
							)\{|get_newModel_var,set_newModel_var|}
						)
						)
					
					-- END
					
					-- Memory
					-- Memory variables
					Memory_newModel_var(newModel_var) =
						get_newModel_var!newModel_var -> Memory_newModel_var(newModel_var)
						[]
						set_newModel_var?x__ -> Memory_newModel_var(x__)
						[]
						terminate -> SKIP
					
					-- varMemory process
					varMemory(id__) = Memory_newModel_var(0)
					
					getsetLocalChannels = {|get_newModel_var,set_newModel_var|}
					
					-- Definition of the behaviour of state machines (default, optimised, visible, visible and optimised)
					FVS__(id__) = STM_VS_O(id__) \ localClockResets
					D__(id__) = timed_priority(STM(id__) \ union(internal_events,localClockResets))
					O__(id__) = dbisim(D__(id__))
					VS__(id__) = FVS__(id__)
					VS_O__(id__) = dbisim(FVS__(id__))
					HEXT__(id__) = O__(id__) [|shared_variable_events|] SKIP
					FVS_C__(id__) = dbisim(timed_priority(STM(id__) \ internal_events))
					HUP__(id__) = timed_priority(O__(id__) [|{share__}|] SKIP)
					
					-- Clocks
					
					Clocks(id__) = terminate -> SKIP
					
					clockSync = {||}
					
					Clock_CLID_SendOutputs(id__,x__) = 
						TimeOut_1(
							SendOutputs::entered -> Clock_CLID_SendOutputs(id__,0)
							[]
							get_CLID_SendOutputs!x__ -> Clock_CLID_SendOutputs(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_SendOutputs(id__,clock_type_plus(x__,1,CLID_SendOutputs_clock_type(id__))))
					Clock_CLID_WaitForSignal(id__,x__) = 
						TimeOut_1(
							WaitForSignal::entered -> Clock_CLID_WaitForSignal(id__,0)
							[]
							get_CLID_WaitForSignal!x__ -> Clock_CLID_WaitForSignal(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_WaitForSignal(id__,clock_type_plus(x__,1,CLID_WaitForSignal_clock_type(id__))))
					Clock_CLID_FinishAdaptation(id__,x__) = 
						TimeOut_1(
							FinishAdaptation::entered -> Clock_CLID_FinishAdaptation(id__,0)
							[]
							get_CLID_FinishAdaptation!x__ -> Clock_CLID_FinishAdaptation(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_FinishAdaptation(id__,clock_type_plus(x__,1,CLID_FinishAdaptation_clock_type(id__))))
					Clock_CLID_Initialise(id__,x__) = 
						TimeOut_1(
							Initialise::entered -> Clock_CLID_Initialise(id__,0)
							[]
							get_CLID_Initialise!x__ -> Clock_CLID_Initialise(id__,x__)
							[]
							terminate -> SKIP,Clock_CLID_Initialise(id__,clock_type_plus(x__,1,CLID_Initialise_clock_type(id__))))
					
					StateClocks(id__) = dbisim(Clock_CLID_SendOutputs(id__,0))
					[| { terminate } |] (
					dbisim(Clock_CLID_WaitForSignal(id__,0))
					[| { terminate } |] (
					dbisim(Clock_CLID_FinishAdaptation(id__,0))
					[| { terminate } |] (
					dbisim(Clock_CLID_Initialise(id__,0))
					)
					)
					)
					
					stateClockSync = {|get_CLID_SendOutputs,SendOutputs::entered,get_CLID_WaitForSignal,WaitForSignal::entered,get_CLID_FinishAdaptation,FinishAdaptation::entered,get_CLID_Initialise,Initialise::entered|}
					
					-- Shared memory
					-- Shared memory variables
					
					-- sharedVarMemory process
					sharedVarMemory(id__) = terminate -> SKIP
					
					sharedVarSync = {||}
					
					sharedVarHide = {||}
					}
			endmodule
			
			Timed(OneStep) {
					-- undefined operations
					
					-- declaring controller memory
					Memory(id__) = SKIP
					
					D__(id__,
							    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
							    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
							    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
							    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL) = prioritise(	((
							(
								stm_ref0::D__(id__)[[
									stm_ref0::terminate <- terminate,
									stm_ref0::ambientLight <- ambientLight,
									stm_ref0::imagesWithLight.in <- stm_ref5::imagesWithLight.out,
									stm_ref0::imagesWithLight.out <- stm_ref5::imagesWithLight.in,
									stm_ref0::currentModel <- currentModel,
									stm_ref0::imageTaken <- imageTaken
								]]
							)
								[|{|terminate, stm_ref0::processedData, stm_ref5::imagesWithLight, stm_ref0::set_imagesWithLight, stm_ref0::get_imagesWithLight|}|]
							(
								(
									let
										const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD = const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD
										const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING = const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING
										const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD = const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD
									within 
									stm_ref1::D__(id__,
											    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
											    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
											    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)[[
										stm_ref1::terminate <- terminate,
										stm_ref1::processedData.in <- stm_ref0::processedData.out,
										stm_ref1::processedData.out <- stm_ref0::processedData.in,
										stm_ref1::imagesWithLight.in <- stm_ref5::imagesWithLight_Analyse.out,
										stm_ref1::imagesWithLight.out <- stm_ref5::imagesWithLight_Analyse.in,
										stm_ref1::imagesWithPoorLight.in <- stm_ref5::imagesWithPoorLight.out,
										stm_ref1::imagesWithPoorLight.out <- stm_ref5::imagesWithPoorLight.in,
										stm_ref1::adaptationCompleted.in <- stm_ref4::adaptationCompleted.out,
										stm_ref1::adaptationCompleted.out <- stm_ref4::adaptationCompleted.in
									]]
								)
									[|{|terminate, stm_ref5::imagesWithLight_Analyse, stm_ref5::imagesWithPoorLight, stm_ref1::get_imagesWithPoorLight, stm_ref1::anomalyFound, stm_ref1::set_imagesWithPoorLight, stm_ref1::get_imagesWithLight, stm_ref4::adaptationCompleted|}|]
								(
									(
										let
											const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD = const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD
										within 
										stm_ref3::D__(id__,
												    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)[[
											stm_ref3::terminate <- terminate,
											stm_ref3::verifyPlan.in <- stm_ref2::planningCompleted.out,
											stm_ref3::verifyPlan.out <- stm_ref2::planningCompleted.in,
											stm_ref3::imagesWithLight.in <- stm_ref5::imagesWithLight_Legitimate.out,
											stm_ref3::imagesWithLight.out <- stm_ref5::imagesWithLight_Legitimate.in,
											stm_ref3::newConfidences.in <- stm_ref5::newConfidences.out,
											stm_ref3::newConfidences.out <- stm_ref5::newConfidences.in,
											stm_ref3::newModel.in <- stm_ref5::newModel_Legitimate.out,
											stm_ref3::newModel.out <- stm_ref5::newModel_Legitimate.in,
											stm_ref3::imagesWithPoorLight.in <- stm_ref5::imagesWithPoorLight_Legitimate.out,
											stm_ref3::imagesWithPoorLight.out <- stm_ref5::imagesWithPoorLight_Legitimate.in
										]]
									)
										[|{|terminate, stm_ref3::get_newModel, stm_ref3::planAccepted, stm_ref2::planningCompleted, stm_ref3::planRejected, stm_ref5::imagesWithLight_Legitimate, stm_ref3::get_imagesWithPoorLight, stm_ref3::get_imagesWithLight, stm_ref3::set_newConfidences, stm_ref5::newConfidences, stm_ref5::newModel_Legitimate, stm_ref5::imagesWithPoorLight_Legitimate, stm_ref3::get_newConfidences|}|]
									(
										(
											stm_ref5::D__(id__)[[
												stm_ref5::terminate <- terminate,
												stm_ref5::get_newConfidences_Plan.in <- stm_ref2::get_newConfidences.out,
												stm_ref5::get_newConfidences_Plan.out <- stm_ref2::get_newConfidences.in,
												stm_ref5::get_newModel_Execute.in <- stm_ref4::get_newModel.out,
												stm_ref5::get_newModel_Execute.out <- stm_ref4::get_newModel.in,
												stm_ref5::get_imagesWithPoorLight_Plan.in <- stm_ref2::get_imagesWithPoorLight.out,
												stm_ref5::get_imagesWithPoorLight_Plan.out <- stm_ref2::get_imagesWithPoorLight.in,
												stm_ref5::get_newModel_Legitimate.in <- stm_ref3::get_newModel.out,
												stm_ref5::get_newModel_Legitimate.out <- stm_ref3::get_newModel.in,
												stm_ref5::get_imagesWithLight_Plan.in <- stm_ref2::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight_Plan.out <- stm_ref2::get_imagesWithLight.in,
												stm_ref5::get_newModel.in <- stm_ref2::get_newModel.out,
												stm_ref5::get_newModel.out <- stm_ref2::get_newModel.in,
												stm_ref5::set_newModel.in <- stm_ref2::set_newModel.out,
												stm_ref5::set_newModel.out <- stm_ref2::set_newModel.in,
												stm_ref5::get_imagesWithPoorLight.in <- stm_ref1::get_imagesWithPoorLight.out,
												stm_ref5::get_imagesWithPoorLight.out <- stm_ref1::get_imagesWithPoorLight.in,
												stm_ref5::get_imagesWithPoorLight_Legitimate.in <- stm_ref3::get_imagesWithPoorLight.out,
												stm_ref5::get_imagesWithPoorLight_Legitimate.out <- stm_ref3::get_imagesWithPoorLight.in,
												stm_ref5::get_imagesWithLight_Legitimate.in <- stm_ref3::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight_Legitimate.out <- stm_ref3::get_imagesWithLight.in,
												stm_ref5::set_newConfidences.in <- stm_ref3::set_newConfidences.out,
												stm_ref5::set_newConfidences.out <- stm_ref3::set_newConfidences.in,
												stm_ref5::set_imagesWithLight.in <- stm_ref0::set_imagesWithLight.out,
												stm_ref5::set_imagesWithLight.out <- stm_ref0::set_imagesWithLight.in,
												stm_ref5::set_imagesWithPoorLight.in <- stm_ref1::set_imagesWithPoorLight.out,
												stm_ref5::set_imagesWithPoorLight.out <- stm_ref1::set_imagesWithPoorLight.in,
												stm_ref5::get_imagesWithLight_Analyse.in <- stm_ref1::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight_Analyse.out <- stm_ref1::get_imagesWithLight.in,
												stm_ref5::get_newConfidences.in <- stm_ref3::get_newConfidences.out,
												stm_ref5::get_newConfidences.out <- stm_ref3::get_newConfidences.in,
												stm_ref5::get_imagesWithLight.in <- stm_ref0::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight.out <- stm_ref0::get_imagesWithLight.in
											]]
											\ {|
												stm_ref5::imagesWithLight_ext,
												stm_ref5::get_imagesWithLight_ext,
												stm_ref5::imagesWithPoorLight_ext,
												stm_ref5::get_imagesWithPoorLight_ext,
												stm_ref5::newModel_ext,
												stm_ref5::get_newModel_ext,
												stm_ref5::newConfidences_ext,
												stm_ref5::get_newConfidences_ext
											|}
										)
											[|{|terminate, stm_ref2::get_newConfidences, stm_ref4::get_newModel, stm_ref2::get_imagesWithPoorLight, stm_ref2::get_imagesWithLight, stm_ref5::newModel_Execute, stm_ref2::get_newModel, stm_ref2::set_newModel, stm_ref5::imagesWithPoorLight_Plan, stm_ref5::newConfidences_Plan, stm_ref5::newModel, stm_ref5::imagesWithLight_Plan|}|]
										(
											(
												let
													const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS = const_Adaptation_Adaptation_stm_ref2_NUM_MODELS
													const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING = const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING
													const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL = const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL
												within 
												stm_ref2::D__(id__,
														    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
														    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
														    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)[[
													stm_ref2::terminate <- terminate,
													stm_ref2::requestPlan.in <- stm_ref1::anomalyFound.out,
													stm_ref2::requestPlan.out <- stm_ref1::anomalyFound.in,
													stm_ref2::planRejected.in <- stm_ref3::planRejected.out,
													stm_ref2::planRejected.out <- stm_ref3::planRejected.in,
													stm_ref2::imagesWithPoorLight.in <- stm_ref5::imagesWithPoorLight_Plan.out,
													stm_ref2::imagesWithPoorLight.out <- stm_ref5::imagesWithPoorLight_Plan.in,
													stm_ref2::newConfidences.in <- stm_ref5::newConfidences_Plan.out,
													stm_ref2::newConfidences.out <- stm_ref5::newConfidences_Plan.in,
													stm_ref2::newModel.in <- stm_ref5::newModel.out,
													stm_ref2::newModel.out <- stm_ref5::newModel.in,
													stm_ref2::imagesWithLight.in <- stm_ref5::imagesWithLight_Plan.out,
													stm_ref2::imagesWithLight.out <- stm_ref5::imagesWithLight_Plan.in
												]]
											)
												[|{|terminate|}|]
											(
												stm_ref4::D__(id__)[[
													stm_ref4::terminate <- terminate,
													stm_ref4::newModel.in <- stm_ref5::newModel_Execute.out,
													stm_ref4::newModel.out <- stm_ref5::newModel_Execute.in,
													stm_ref4::executePlan.in <- stm_ref3::planAccepted.out,
													stm_ref4::executePlan.out <- stm_ref3::planAccepted.in,
													stm_ref4::switchModel <- switchModel
												]]
											)
										)
										\diff(
											{|terminate|},
											{|terminate|}
										)
									)
									\diff(
										{|terminate, stm_ref2::get_newConfidences, stm_ref4::get_newModel, stm_ref2::get_imagesWithPoorLight, stm_ref2::get_imagesWithLight, stm_ref5::newModel_Execute, stm_ref2::get_newModel, stm_ref2::set_newModel, stm_ref5::imagesWithPoorLight_Plan, stm_ref5::newConfidences_Plan, stm_ref5::newModel, stm_ref5::imagesWithLight_Plan|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate, stm_ref3::get_newModel, stm_ref3::planAccepted, stm_ref2::planningCompleted, stm_ref3::planRejected, stm_ref5::imagesWithLight_Legitimate, stm_ref3::get_imagesWithPoorLight, stm_ref3::get_imagesWithLight, stm_ref3::set_newConfidences, stm_ref5::newConfidences, stm_ref5::newModel_Legitimate, stm_ref5::imagesWithPoorLight_Legitimate, stm_ref3::get_newConfidences|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate, stm_ref5::imagesWithLight_Analyse, stm_ref5::imagesWithPoorLight, stm_ref1::get_imagesWithPoorLight, stm_ref1::anomalyFound, stm_ref1::set_imagesWithPoorLight, stm_ref1::get_imagesWithLight, stm_ref4::adaptationCompleted|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref0::processedData, stm_ref5::imagesWithLight, stm_ref0::set_imagesWithLight, stm_ref0::get_imagesWithLight|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>)
					
					-- VS version
					VS__(id__,
							    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
							    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
							    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
							    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL) = prioritise(	((
							(
								stm_ref0::VS__(id__)[[
									stm_ref0::terminate <- terminate,
									stm_ref0::ambientLight <- ambientLight,
									stm_ref0::imagesWithLight.in <- stm_ref5::imagesWithLight.out,
									stm_ref0::imagesWithLight.out <- stm_ref5::imagesWithLight.in,
									stm_ref0::currentModel <- currentModel,
									stm_ref0::imageTaken <- imageTaken
								]]
							)
								[|{|terminate, stm_ref0::processedData, stm_ref5::imagesWithLight, stm_ref0::set_imagesWithLight, stm_ref0::get_imagesWithLight|}|]
							(
								(
									let
										const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD = const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD
										const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING = const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING
										const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD = const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD
									within 
									stm_ref1::VS__(id__,
											    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
											    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
											    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)[[
										stm_ref1::terminate <- terminate,
										stm_ref1::processedData.in <- stm_ref0::processedData.out,
										stm_ref1::processedData.out <- stm_ref0::processedData.in,
										stm_ref1::imagesWithLight.in <- stm_ref5::imagesWithLight_Analyse.out,
										stm_ref1::imagesWithLight.out <- stm_ref5::imagesWithLight_Analyse.in,
										stm_ref1::imagesWithPoorLight.in <- stm_ref5::imagesWithPoorLight.out,
										stm_ref1::imagesWithPoorLight.out <- stm_ref5::imagesWithPoorLight.in,
										stm_ref1::adaptationCompleted.in <- stm_ref4::adaptationCompleted.out,
										stm_ref1::adaptationCompleted.out <- stm_ref4::adaptationCompleted.in
									]]
								)
									[|{|terminate, stm_ref5::imagesWithLight_Analyse, stm_ref5::imagesWithPoorLight, stm_ref1::get_imagesWithPoorLight, stm_ref1::anomalyFound, stm_ref1::set_imagesWithPoorLight, stm_ref1::get_imagesWithLight, stm_ref4::adaptationCompleted|}|]
								(
									(
										let
											const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD = const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD
										within 
										stm_ref3::VS__(id__,
												    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)[[
											stm_ref3::terminate <- terminate,
											stm_ref3::verifyPlan.in <- stm_ref2::planningCompleted.out,
											stm_ref3::verifyPlan.out <- stm_ref2::planningCompleted.in,
											stm_ref3::imagesWithLight.in <- stm_ref5::imagesWithLight_Legitimate.out,
											stm_ref3::imagesWithLight.out <- stm_ref5::imagesWithLight_Legitimate.in,
											stm_ref3::newConfidences.in <- stm_ref5::newConfidences.out,
											stm_ref3::newConfidences.out <- stm_ref5::newConfidences.in,
											stm_ref3::newModel.in <- stm_ref5::newModel_Legitimate.out,
											stm_ref3::newModel.out <- stm_ref5::newModel_Legitimate.in,
											stm_ref3::imagesWithPoorLight.in <- stm_ref5::imagesWithPoorLight_Legitimate.out,
											stm_ref3::imagesWithPoorLight.out <- stm_ref5::imagesWithPoorLight_Legitimate.in
										]]
									)
										[|{|terminate, stm_ref3::get_newModel, stm_ref3::planAccepted, stm_ref2::planningCompleted, stm_ref3::planRejected, stm_ref5::imagesWithLight_Legitimate, stm_ref3::get_imagesWithPoorLight, stm_ref3::get_imagesWithLight, stm_ref3::set_newConfidences, stm_ref5::newConfidences, stm_ref5::newModel_Legitimate, stm_ref5::imagesWithPoorLight_Legitimate, stm_ref3::get_newConfidences|}|]
									(
										(
											stm_ref5::VS__(id__)[[
												stm_ref5::terminate <- terminate,
												stm_ref5::get_newConfidences_Plan.in <- stm_ref2::get_newConfidences.out,
												stm_ref5::get_newConfidences_Plan.out <- stm_ref2::get_newConfidences.in,
												stm_ref5::get_newModel_Execute.in <- stm_ref4::get_newModel.out,
												stm_ref5::get_newModel_Execute.out <- stm_ref4::get_newModel.in,
												stm_ref5::get_imagesWithPoorLight_Plan.in <- stm_ref2::get_imagesWithPoorLight.out,
												stm_ref5::get_imagesWithPoorLight_Plan.out <- stm_ref2::get_imagesWithPoorLight.in,
												stm_ref5::get_newModel_Legitimate.in <- stm_ref3::get_newModel.out,
												stm_ref5::get_newModel_Legitimate.out <- stm_ref3::get_newModel.in,
												stm_ref5::get_imagesWithLight_Plan.in <- stm_ref2::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight_Plan.out <- stm_ref2::get_imagesWithLight.in,
												stm_ref5::get_newModel.in <- stm_ref2::get_newModel.out,
												stm_ref5::get_newModel.out <- stm_ref2::get_newModel.in,
												stm_ref5::set_newModel.in <- stm_ref2::set_newModel.out,
												stm_ref5::set_newModel.out <- stm_ref2::set_newModel.in,
												stm_ref5::get_imagesWithPoorLight.in <- stm_ref1::get_imagesWithPoorLight.out,
												stm_ref5::get_imagesWithPoorLight.out <- stm_ref1::get_imagesWithPoorLight.in,
												stm_ref5::get_imagesWithPoorLight_Legitimate.in <- stm_ref3::get_imagesWithPoorLight.out,
												stm_ref5::get_imagesWithPoorLight_Legitimate.out <- stm_ref3::get_imagesWithPoorLight.in,
												stm_ref5::get_imagesWithLight_Legitimate.in <- stm_ref3::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight_Legitimate.out <- stm_ref3::get_imagesWithLight.in,
												stm_ref5::set_newConfidences.in <- stm_ref3::set_newConfidences.out,
												stm_ref5::set_newConfidences.out <- stm_ref3::set_newConfidences.in,
												stm_ref5::set_imagesWithLight.in <- stm_ref0::set_imagesWithLight.out,
												stm_ref5::set_imagesWithLight.out <- stm_ref0::set_imagesWithLight.in,
												stm_ref5::set_imagesWithPoorLight.in <- stm_ref1::set_imagesWithPoorLight.out,
												stm_ref5::set_imagesWithPoorLight.out <- stm_ref1::set_imagesWithPoorLight.in,
												stm_ref5::get_imagesWithLight_Analyse.in <- stm_ref1::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight_Analyse.out <- stm_ref1::get_imagesWithLight.in,
												stm_ref5::get_newConfidences.in <- stm_ref3::get_newConfidences.out,
												stm_ref5::get_newConfidences.out <- stm_ref3::get_newConfidences.in,
												stm_ref5::get_imagesWithLight.in <- stm_ref0::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight.out <- stm_ref0::get_imagesWithLight.in
											]]
											\ {|
												stm_ref5::imagesWithLight_ext,
												stm_ref5::get_imagesWithLight_ext,
												stm_ref5::imagesWithPoorLight_ext,
												stm_ref5::get_imagesWithPoorLight_ext,
												stm_ref5::newModel_ext,
												stm_ref5::get_newModel_ext,
												stm_ref5::newConfidences_ext,
												stm_ref5::get_newConfidences_ext
											|}
										)
											[|{|terminate, stm_ref2::get_newConfidences, stm_ref4::get_newModel, stm_ref2::get_imagesWithPoorLight, stm_ref2::get_imagesWithLight, stm_ref5::newModel_Execute, stm_ref2::get_newModel, stm_ref2::set_newModel, stm_ref5::imagesWithPoorLight_Plan, stm_ref5::newConfidences_Plan, stm_ref5::newModel, stm_ref5::imagesWithLight_Plan|}|]
										(
											(
												let
													const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS = const_Adaptation_Adaptation_stm_ref2_NUM_MODELS
													const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING = const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING
													const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL = const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL
												within 
												stm_ref2::VS__(id__,
														    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
														    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
														    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)[[
													stm_ref2::terminate <- terminate,
													stm_ref2::requestPlan.in <- stm_ref1::anomalyFound.out,
													stm_ref2::requestPlan.out <- stm_ref1::anomalyFound.in,
													stm_ref2::planRejected.in <- stm_ref3::planRejected.out,
													stm_ref2::planRejected.out <- stm_ref3::planRejected.in,
													stm_ref2::imagesWithPoorLight.in <- stm_ref5::imagesWithPoorLight_Plan.out,
													stm_ref2::imagesWithPoorLight.out <- stm_ref5::imagesWithPoorLight_Plan.in,
													stm_ref2::newConfidences.in <- stm_ref5::newConfidences_Plan.out,
													stm_ref2::newConfidences.out <- stm_ref5::newConfidences_Plan.in,
													stm_ref2::newModel.in <- stm_ref5::newModel.out,
													stm_ref2::newModel.out <- stm_ref5::newModel.in,
													stm_ref2::imagesWithLight.in <- stm_ref5::imagesWithLight_Plan.out,
													stm_ref2::imagesWithLight.out <- stm_ref5::imagesWithLight_Plan.in
												]]
											)
												[|{|terminate|}|]
											(
												stm_ref4::VS__(id__)[[
													stm_ref4::terminate <- terminate,
													stm_ref4::newModel.in <- stm_ref5::newModel_Execute.out,
													stm_ref4::newModel.out <- stm_ref5::newModel_Execute.in,
													stm_ref4::executePlan.in <- stm_ref3::planAccepted.out,
													stm_ref4::executePlan.out <- stm_ref3::planAccepted.in,
													stm_ref4::switchModel <- switchModel
												]]
											)
										)
										\diff(
											{|terminate|},
											{|terminate|}
										)
									)
									\diff(
										{|terminate, stm_ref2::get_newConfidences, stm_ref4::get_newModel, stm_ref2::get_imagesWithPoorLight, stm_ref2::get_imagesWithLight, stm_ref5::newModel_Execute, stm_ref2::get_newModel, stm_ref2::set_newModel, stm_ref5::imagesWithPoorLight_Plan, stm_ref5::newConfidences_Plan, stm_ref5::newModel, stm_ref5::imagesWithLight_Plan|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate, stm_ref3::get_newModel, stm_ref3::planAccepted, stm_ref2::planningCompleted, stm_ref3::planRejected, stm_ref5::imagesWithLight_Legitimate, stm_ref3::get_imagesWithPoorLight, stm_ref3::get_imagesWithLight, stm_ref3::set_newConfidences, stm_ref5::newConfidences, stm_ref5::newModel_Legitimate, stm_ref5::imagesWithPoorLight_Legitimate, stm_ref3::get_newConfidences|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate, stm_ref5::imagesWithLight_Analyse, stm_ref5::imagesWithPoorLight, stm_ref1::get_imagesWithPoorLight, stm_ref1::anomalyFound, stm_ref1::set_imagesWithPoorLight, stm_ref1::get_imagesWithLight, stm_ref4::adaptationCompleted|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref0::processedData, stm_ref5::imagesWithLight, stm_ref0::set_imagesWithLight, stm_ref0::get_imagesWithLight|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>)
				
					-- O version (optimised) THESE TWO PROCESSES SHOULD BE KEPT IN SYNC WITH THE ABOVE TWO
					O__(id__,
							    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
							    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
							    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
							    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL) = dbisim(prioritise(	((
							(
								stm_ref0::O__(id__)[[
									stm_ref0::terminate <- terminate,
									stm_ref0::ambientLight <- ambientLight,
									stm_ref0::imagesWithLight.in <- stm_ref5::imagesWithLight.out,
									stm_ref0::imagesWithLight.out <- stm_ref5::imagesWithLight.in,
									stm_ref0::currentModel <- currentModel,
									stm_ref0::imageTaken <- imageTaken
								]]
							)
								[|{|terminate, stm_ref0::processedData, stm_ref5::imagesWithLight, stm_ref0::set_imagesWithLight, stm_ref0::get_imagesWithLight|}|]
							(
								(
									let
										const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD = const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD
										const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING = const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING
										const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD = const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD
									within 
									stm_ref1::O__(id__,
											    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
											    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
											    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)[[
										stm_ref1::terminate <- terminate,
										stm_ref1::processedData.in <- stm_ref0::processedData.out,
										stm_ref1::processedData.out <- stm_ref0::processedData.in,
										stm_ref1::imagesWithLight.in <- stm_ref5::imagesWithLight_Analyse.out,
										stm_ref1::imagesWithLight.out <- stm_ref5::imagesWithLight_Analyse.in,
										stm_ref1::imagesWithPoorLight.in <- stm_ref5::imagesWithPoorLight.out,
										stm_ref1::imagesWithPoorLight.out <- stm_ref5::imagesWithPoorLight.in,
										stm_ref1::adaptationCompleted.in <- stm_ref4::adaptationCompleted.out,
										stm_ref1::adaptationCompleted.out <- stm_ref4::adaptationCompleted.in
									]]
								)
									[|{|terminate, stm_ref5::imagesWithLight_Analyse, stm_ref5::imagesWithPoorLight, stm_ref1::get_imagesWithPoorLight, stm_ref1::anomalyFound, stm_ref1::set_imagesWithPoorLight, stm_ref1::get_imagesWithLight, stm_ref4::adaptationCompleted|}|]
								(
									(
										let
											const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD = const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD
										within 
										stm_ref3::O__(id__,
												    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)[[
											stm_ref3::terminate <- terminate,
											stm_ref3::verifyPlan.in <- stm_ref2::planningCompleted.out,
											stm_ref3::verifyPlan.out <- stm_ref2::planningCompleted.in,
											stm_ref3::imagesWithLight.in <- stm_ref5::imagesWithLight_Legitimate.out,
											stm_ref3::imagesWithLight.out <- stm_ref5::imagesWithLight_Legitimate.in,
											stm_ref3::newConfidences.in <- stm_ref5::newConfidences.out,
											stm_ref3::newConfidences.out <- stm_ref5::newConfidences.in,
											stm_ref3::newModel.in <- stm_ref5::newModel_Legitimate.out,
											stm_ref3::newModel.out <- stm_ref5::newModel_Legitimate.in,
											stm_ref3::imagesWithPoorLight.in <- stm_ref5::imagesWithPoorLight_Legitimate.out,
											stm_ref3::imagesWithPoorLight.out <- stm_ref5::imagesWithPoorLight_Legitimate.in
										]]
									)
										[|{|terminate, stm_ref3::get_newModel, stm_ref3::planAccepted, stm_ref2::planningCompleted, stm_ref3::planRejected, stm_ref5::imagesWithLight_Legitimate, stm_ref3::get_imagesWithPoorLight, stm_ref3::get_imagesWithLight, stm_ref3::set_newConfidences, stm_ref5::newConfidences, stm_ref5::newModel_Legitimate, stm_ref5::imagesWithPoorLight_Legitimate, stm_ref3::get_newConfidences|}|]
									(
										(
											stm_ref5::O__(id__)[[
												stm_ref5::terminate <- terminate,
												stm_ref5::get_newConfidences_Plan.in <- stm_ref2::get_newConfidences.out,
												stm_ref5::get_newConfidences_Plan.out <- stm_ref2::get_newConfidences.in,
												stm_ref5::get_newModel_Execute.in <- stm_ref4::get_newModel.out,
												stm_ref5::get_newModel_Execute.out <- stm_ref4::get_newModel.in,
												stm_ref5::get_imagesWithPoorLight_Plan.in <- stm_ref2::get_imagesWithPoorLight.out,
												stm_ref5::get_imagesWithPoorLight_Plan.out <- stm_ref2::get_imagesWithPoorLight.in,
												stm_ref5::get_newModel_Legitimate.in <- stm_ref3::get_newModel.out,
												stm_ref5::get_newModel_Legitimate.out <- stm_ref3::get_newModel.in,
												stm_ref5::get_imagesWithLight_Plan.in <- stm_ref2::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight_Plan.out <- stm_ref2::get_imagesWithLight.in,
												stm_ref5::get_newModel.in <- stm_ref2::get_newModel.out,
												stm_ref5::get_newModel.out <- stm_ref2::get_newModel.in,
												stm_ref5::set_newModel.in <- stm_ref2::set_newModel.out,
												stm_ref5::set_newModel.out <- stm_ref2::set_newModel.in,
												stm_ref5::get_imagesWithPoorLight.in <- stm_ref1::get_imagesWithPoorLight.out,
												stm_ref5::get_imagesWithPoorLight.out <- stm_ref1::get_imagesWithPoorLight.in,
												stm_ref5::get_imagesWithPoorLight_Legitimate.in <- stm_ref3::get_imagesWithPoorLight.out,
												stm_ref5::get_imagesWithPoorLight_Legitimate.out <- stm_ref3::get_imagesWithPoorLight.in,
												stm_ref5::get_imagesWithLight_Legitimate.in <- stm_ref3::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight_Legitimate.out <- stm_ref3::get_imagesWithLight.in,
												stm_ref5::set_newConfidences.in <- stm_ref3::set_newConfidences.out,
												stm_ref5::set_newConfidences.out <- stm_ref3::set_newConfidences.in,
												stm_ref5::set_imagesWithLight.in <- stm_ref0::set_imagesWithLight.out,
												stm_ref5::set_imagesWithLight.out <- stm_ref0::set_imagesWithLight.in,
												stm_ref5::set_imagesWithPoorLight.in <- stm_ref1::set_imagesWithPoorLight.out,
												stm_ref5::set_imagesWithPoorLight.out <- stm_ref1::set_imagesWithPoorLight.in,
												stm_ref5::get_imagesWithLight_Analyse.in <- stm_ref1::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight_Analyse.out <- stm_ref1::get_imagesWithLight.in,
												stm_ref5::get_newConfidences.in <- stm_ref3::get_newConfidences.out,
												stm_ref5::get_newConfidences.out <- stm_ref3::get_newConfidences.in,
												stm_ref5::get_imagesWithLight.in <- stm_ref0::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight.out <- stm_ref0::get_imagesWithLight.in
											]]
											\ {|
												stm_ref5::imagesWithLight_ext,
												stm_ref5::get_imagesWithLight_ext,
												stm_ref5::imagesWithPoorLight_ext,
												stm_ref5::get_imagesWithPoorLight_ext,
												stm_ref5::newModel_ext,
												stm_ref5::get_newModel_ext,
												stm_ref5::newConfidences_ext,
												stm_ref5::get_newConfidences_ext
											|}
										)
											[|{|terminate, stm_ref2::get_newConfidences, stm_ref4::get_newModel, stm_ref2::get_imagesWithPoorLight, stm_ref2::get_imagesWithLight, stm_ref5::newModel_Execute, stm_ref2::get_newModel, stm_ref2::set_newModel, stm_ref5::imagesWithPoorLight_Plan, stm_ref5::newConfidences_Plan, stm_ref5::newModel, stm_ref5::imagesWithLight_Plan|}|]
										(
											(
												let
													const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS = const_Adaptation_Adaptation_stm_ref2_NUM_MODELS
													const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING = const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING
													const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL = const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL
												within 
												stm_ref2::O__(id__,
														    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
														    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
														    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)[[
													stm_ref2::terminate <- terminate,
													stm_ref2::requestPlan.in <- stm_ref1::anomalyFound.out,
													stm_ref2::requestPlan.out <- stm_ref1::anomalyFound.in,
													stm_ref2::planRejected.in <- stm_ref3::planRejected.out,
													stm_ref2::planRejected.out <- stm_ref3::planRejected.in,
													stm_ref2::imagesWithPoorLight.in <- stm_ref5::imagesWithPoorLight_Plan.out,
													stm_ref2::imagesWithPoorLight.out <- stm_ref5::imagesWithPoorLight_Plan.in,
													stm_ref2::newConfidences.in <- stm_ref5::newConfidences_Plan.out,
													stm_ref2::newConfidences.out <- stm_ref5::newConfidences_Plan.in,
													stm_ref2::newModel.in <- stm_ref5::newModel.out,
													stm_ref2::newModel.out <- stm_ref5::newModel.in,
													stm_ref2::imagesWithLight.in <- stm_ref5::imagesWithLight_Plan.out,
													stm_ref2::imagesWithLight.out <- stm_ref5::imagesWithLight_Plan.in
												]]
											)
												[|{|terminate|}|]
											(
												stm_ref4::O__(id__)[[
													stm_ref4::terminate <- terminate,
													stm_ref4::newModel.in <- stm_ref5::newModel_Execute.out,
													stm_ref4::newModel.out <- stm_ref5::newModel_Execute.in,
													stm_ref4::executePlan.in <- stm_ref3::planAccepted.out,
													stm_ref4::executePlan.out <- stm_ref3::planAccepted.in,
													stm_ref4::switchModel <- switchModel
												]]
											)
										)
										\diff(
											{|terminate|},
											{|terminate|}
										)
									)
									\diff(
										{|terminate, stm_ref2::get_newConfidences, stm_ref4::get_newModel, stm_ref2::get_imagesWithPoorLight, stm_ref2::get_imagesWithLight, stm_ref5::newModel_Execute, stm_ref2::get_newModel, stm_ref2::set_newModel, stm_ref5::imagesWithPoorLight_Plan, stm_ref5::newConfidences_Plan, stm_ref5::newModel, stm_ref5::imagesWithLight_Plan|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate, stm_ref3::get_newModel, stm_ref3::planAccepted, stm_ref2::planningCompleted, stm_ref3::planRejected, stm_ref5::imagesWithLight_Legitimate, stm_ref3::get_imagesWithPoorLight, stm_ref3::get_imagesWithLight, stm_ref3::set_newConfidences, stm_ref5::newConfidences, stm_ref5::newModel_Legitimate, stm_ref5::imagesWithPoorLight_Legitimate, stm_ref3::get_newConfidences|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate, stm_ref5::imagesWithLight_Analyse, stm_ref5::imagesWithPoorLight, stm_ref1::get_imagesWithPoorLight, stm_ref1::anomalyFound, stm_ref1::set_imagesWithPoorLight, stm_ref1::get_imagesWithLight, stm_ref4::adaptationCompleted|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref0::processedData, stm_ref5::imagesWithLight, stm_ref0::set_imagesWithLight, stm_ref0::get_imagesWithLight|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>))
									
					-- VS_O version
					VS_O__(id__,
							    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
							    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
							    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
							    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL) = dbisim(prioritise(	((
							(
								stm_ref0::VS_O__(id__)[[
									stm_ref0::terminate <- terminate,
									stm_ref0::ambientLight <- ambientLight,
									stm_ref0::imagesWithLight.in <- stm_ref5::imagesWithLight.out,
									stm_ref0::imagesWithLight.out <- stm_ref5::imagesWithLight.in,
									stm_ref0::currentModel <- currentModel,
									stm_ref0::imageTaken <- imageTaken
								]]
							)
								[|{|terminate, stm_ref0::processedData, stm_ref5::imagesWithLight, stm_ref0::set_imagesWithLight, stm_ref0::get_imagesWithLight|}|]
							(
								(
									let
										const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD = const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD
										const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING = const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING
										const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD = const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD
									within 
									stm_ref1::VS_O__(id__,
											    const_Adaptation_Analyse_Adaptation_Analyse_CONFIDENCE_THRESHOLD,
											    const_Adaptation_Analyse_Adaptation_Analyse_IDEAL_LIGHTING,
											    const_Adaptation_Analyse_Adaptation_Analyse_ANOMALY_TIME_THRESHOLD)[[
										stm_ref1::terminate <- terminate,
										stm_ref1::processedData.in <- stm_ref0::processedData.out,
										stm_ref1::processedData.out <- stm_ref0::processedData.in,
										stm_ref1::imagesWithLight.in <- stm_ref5::imagesWithLight_Analyse.out,
										stm_ref1::imagesWithLight.out <- stm_ref5::imagesWithLight_Analyse.in,
										stm_ref1::imagesWithPoorLight.in <- stm_ref5::imagesWithPoorLight.out,
										stm_ref1::imagesWithPoorLight.out <- stm_ref5::imagesWithPoorLight.in,
										stm_ref1::adaptationCompleted.in <- stm_ref4::adaptationCompleted.out,
										stm_ref1::adaptationCompleted.out <- stm_ref4::adaptationCompleted.in
									]]
								)
									[|{|terminate, stm_ref5::imagesWithLight_Analyse, stm_ref5::imagesWithPoorLight, stm_ref1::get_imagesWithPoorLight, stm_ref1::anomalyFound, stm_ref1::set_imagesWithPoorLight, stm_ref1::get_imagesWithLight, stm_ref4::adaptationCompleted|}|]
								(
									(
										let
											const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD = const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD
										within 
										stm_ref3::VS_O__(id__,
												    const_Adaptation_Legitimate_Adaptation_Legitimate_CONFIDENCE_THRESHOLD)[[
											stm_ref3::terminate <- terminate,
											stm_ref3::verifyPlan.in <- stm_ref2::planningCompleted.out,
											stm_ref3::verifyPlan.out <- stm_ref2::planningCompleted.in,
											stm_ref3::imagesWithLight.in <- stm_ref5::imagesWithLight_Legitimate.out,
											stm_ref3::imagesWithLight.out <- stm_ref5::imagesWithLight_Legitimate.in,
											stm_ref3::newConfidences.in <- stm_ref5::newConfidences.out,
											stm_ref3::newConfidences.out <- stm_ref5::newConfidences.in,
											stm_ref3::newModel.in <- stm_ref5::newModel_Legitimate.out,
											stm_ref3::newModel.out <- stm_ref5::newModel_Legitimate.in,
											stm_ref3::imagesWithPoorLight.in <- stm_ref5::imagesWithPoorLight_Legitimate.out,
											stm_ref3::imagesWithPoorLight.out <- stm_ref5::imagesWithPoorLight_Legitimate.in
										]]
									)
										[|{|terminate, stm_ref3::get_newModel, stm_ref3::planAccepted, stm_ref2::planningCompleted, stm_ref3::planRejected, stm_ref5::imagesWithLight_Legitimate, stm_ref3::get_imagesWithPoorLight, stm_ref3::get_imagesWithLight, stm_ref3::set_newConfidences, stm_ref5::newConfidences, stm_ref5::newModel_Legitimate, stm_ref5::imagesWithPoorLight_Legitimate, stm_ref3::get_newConfidences|}|]
									(
										(
											stm_ref5::VS_O__(id__)[[
												stm_ref5::terminate <- terminate,
												stm_ref5::get_newConfidences_Plan.in <- stm_ref2::get_newConfidences.out,
												stm_ref5::get_newConfidences_Plan.out <- stm_ref2::get_newConfidences.in,
												stm_ref5::get_newModel_Execute.in <- stm_ref4::get_newModel.out,
												stm_ref5::get_newModel_Execute.out <- stm_ref4::get_newModel.in,
												stm_ref5::get_imagesWithPoorLight_Plan.in <- stm_ref2::get_imagesWithPoorLight.out,
												stm_ref5::get_imagesWithPoorLight_Plan.out <- stm_ref2::get_imagesWithPoorLight.in,
												stm_ref5::get_newModel_Legitimate.in <- stm_ref3::get_newModel.out,
												stm_ref5::get_newModel_Legitimate.out <- stm_ref3::get_newModel.in,
												stm_ref5::get_imagesWithLight_Plan.in <- stm_ref2::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight_Plan.out <- stm_ref2::get_imagesWithLight.in,
												stm_ref5::get_newModel.in <- stm_ref2::get_newModel.out,
												stm_ref5::get_newModel.out <- stm_ref2::get_newModel.in,
												stm_ref5::set_newModel.in <- stm_ref2::set_newModel.out,
												stm_ref5::set_newModel.out <- stm_ref2::set_newModel.in,
												stm_ref5::get_imagesWithPoorLight.in <- stm_ref1::get_imagesWithPoorLight.out,
												stm_ref5::get_imagesWithPoorLight.out <- stm_ref1::get_imagesWithPoorLight.in,
												stm_ref5::get_imagesWithPoorLight_Legitimate.in <- stm_ref3::get_imagesWithPoorLight.out,
												stm_ref5::get_imagesWithPoorLight_Legitimate.out <- stm_ref3::get_imagesWithPoorLight.in,
												stm_ref5::get_imagesWithLight_Legitimate.in <- stm_ref3::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight_Legitimate.out <- stm_ref3::get_imagesWithLight.in,
												stm_ref5::set_newConfidences.in <- stm_ref3::set_newConfidences.out,
												stm_ref5::set_newConfidences.out <- stm_ref3::set_newConfidences.in,
												stm_ref5::set_imagesWithLight.in <- stm_ref0::set_imagesWithLight.out,
												stm_ref5::set_imagesWithLight.out <- stm_ref0::set_imagesWithLight.in,
												stm_ref5::set_imagesWithPoorLight.in <- stm_ref1::set_imagesWithPoorLight.out,
												stm_ref5::set_imagesWithPoorLight.out <- stm_ref1::set_imagesWithPoorLight.in,
												stm_ref5::get_imagesWithLight_Analyse.in <- stm_ref1::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight_Analyse.out <- stm_ref1::get_imagesWithLight.in,
												stm_ref5::get_newConfidences.in <- stm_ref3::get_newConfidences.out,
												stm_ref5::get_newConfidences.out <- stm_ref3::get_newConfidences.in,
												stm_ref5::get_imagesWithLight.in <- stm_ref0::get_imagesWithLight.out,
												stm_ref5::get_imagesWithLight.out <- stm_ref0::get_imagesWithLight.in
											]]
											\ {|
												stm_ref5::imagesWithLight_ext,
												stm_ref5::get_imagesWithLight_ext,
												stm_ref5::imagesWithPoorLight_ext,
												stm_ref5::get_imagesWithPoorLight_ext,
												stm_ref5::newModel_ext,
												stm_ref5::get_newModel_ext,
												stm_ref5::newConfidences_ext,
												stm_ref5::get_newConfidences_ext
											|}
										)
											[|{|terminate, stm_ref2::get_newConfidences, stm_ref4::get_newModel, stm_ref2::get_imagesWithPoorLight, stm_ref2::get_imagesWithLight, stm_ref5::newModel_Execute, stm_ref2::get_newModel, stm_ref2::set_newModel, stm_ref5::imagesWithPoorLight_Plan, stm_ref5::newConfidences_Plan, stm_ref5::newModel, stm_ref5::imagesWithLight_Plan|}|]
										(
											(
												let
													const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS = const_Adaptation_Adaptation_stm_ref2_NUM_MODELS
													const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING = const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING
													const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL = const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL
												within 
												stm_ref2::VS_O__(id__,
														    const_Adaptation_Plan_Adaptation_Plan_NUM_MODELS,
														    const_Adaptation_Plan_Adaptation_Plan_IDEAL_LIGHTING,
														    const_Adaptation_Plan_Adaptation_Plan_FALLBACK_MODEL)[[
													stm_ref2::terminate <- terminate,
													stm_ref2::requestPlan.in <- stm_ref1::anomalyFound.out,
													stm_ref2::requestPlan.out <- stm_ref1::anomalyFound.in,
													stm_ref2::planRejected.in <- stm_ref3::planRejected.out,
													stm_ref2::planRejected.out <- stm_ref3::planRejected.in,
													stm_ref2::imagesWithPoorLight.in <- stm_ref5::imagesWithPoorLight_Plan.out,
													stm_ref2::imagesWithPoorLight.out <- stm_ref5::imagesWithPoorLight_Plan.in,
													stm_ref2::newConfidences.in <- stm_ref5::newConfidences_Plan.out,
													stm_ref2::newConfidences.out <- stm_ref5::newConfidences_Plan.in,
													stm_ref2::newModel.in <- stm_ref5::newModel.out,
													stm_ref2::newModel.out <- stm_ref5::newModel.in,
													stm_ref2::imagesWithLight.in <- stm_ref5::imagesWithLight_Plan.out,
													stm_ref2::imagesWithLight.out <- stm_ref5::imagesWithLight_Plan.in
												]]
											)
												[|{|terminate|}|]
											(
												stm_ref4::VS_O__(id__)[[
													stm_ref4::terminate <- terminate,
													stm_ref4::newModel.in <- stm_ref5::newModel_Execute.out,
													stm_ref4::newModel.out <- stm_ref5::newModel_Execute.in,
													stm_ref4::executePlan.in <- stm_ref3::planAccepted.out,
													stm_ref4::executePlan.out <- stm_ref3::planAccepted.in,
													stm_ref4::switchModel <- switchModel
												]]
											)
										)
										\diff(
											{|terminate|},
											{|terminate|}
										)
									)
									\diff(
										{|terminate, stm_ref2::get_newConfidences, stm_ref4::get_newModel, stm_ref2::get_imagesWithPoorLight, stm_ref2::get_imagesWithLight, stm_ref5::newModel_Execute, stm_ref2::get_newModel, stm_ref2::set_newModel, stm_ref5::imagesWithPoorLight_Plan, stm_ref5::newConfidences_Plan, stm_ref5::newModel, stm_ref5::imagesWithLight_Plan|},
										{|terminate|}
									)
								)
								\diff(
									{|terminate, stm_ref3::get_newModel, stm_ref3::planAccepted, stm_ref2::planningCompleted, stm_ref3::planRejected, stm_ref5::imagesWithLight_Legitimate, stm_ref3::get_imagesWithPoorLight, stm_ref3::get_imagesWithLight, stm_ref3::set_newConfidences, stm_ref5::newConfidences, stm_ref5::newModel_Legitimate, stm_ref5::imagesWithPoorLight_Legitimate, stm_ref3::get_newConfidences|},
									{|terminate|}
								)
							)
							\diff(
								{|terminate, stm_ref5::imagesWithLight_Analyse, stm_ref5::imagesWithPoorLight, stm_ref1::get_imagesWithPoorLight, stm_ref1::anomalyFound, stm_ref1::set_imagesWithPoorLight, stm_ref1::get_imagesWithLight, stm_ref4::adaptationCompleted|},
								{|terminate|}
							)
						)
						\diff(
							{|terminate, stm_ref0::processedData, stm_ref5::imagesWithLight, stm_ref0::set_imagesWithLight, stm_ref0::get_imagesWithLight|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
					\ union(
						{|
						|},
						{|
						|}
					)
					[|{|terminate|}|>SKIP
					,<visibleMemoryEvents,{tock}>))
				
					HEXT(id__,
							    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
							    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
							    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
							    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL) = O__(id__,
							    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
							    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
							    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
							    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
							    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL) [|shared_variable_events|] SKIP			
			}
	
		endmodule
	
	Timed(OneStep) {
		visibleMemoryEvents = {||}
		
		-- declaring module memory
		Memory(id__) = SKIP
		
		D__(id__,
				    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
				    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
				    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
				    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
				    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
				    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
				    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL) = prioritise(let
			Buffer0(<v>) = 
				ctrl_ref0::imageTaken.out?x -> Buffer0(<x>)
				[]
				ctrl_ref1::imageTaken.in!v -> Buffer0(<>)
			Buffer0(<>) = ctrl_ref0::imageTaken.out?x -> Buffer0(<x>)
			Buffer1(<v>) = 
				ctrl_ref0::ambientLight.out?x -> Buffer1(<x>)
				[]
				ctrl_ref1::ambientLight.in!v -> Buffer1(<>)
			Buffer1(<>) = ctrl_ref0::ambientLight.out?x -> Buffer1(<x>)
			Buffer2(<v>) = 
				ctrl_ref0::currentModel.out?x -> Buffer2(<x>)
				[]
				ctrl_ref1::currentModel.in!v -> Buffer2(<>)
			Buffer2(<>) = ctrl_ref0::currentModel.out?x -> Buffer2(<x>)
			Buffer3(<v>) = 
				ctrl_ref1::switchModel.out?x -> Buffer3(<x>)
				[]
				ctrl_ref0::switchModel.in!v -> Buffer3(<>)
			Buffer3(<>) = ctrl_ref1::switchModel.out?x -> Buffer3(<x>)
			
		within
			(
				(
					(Buffer0(<>)|||
					Buffer1(<>)|||
					Buffer2(<>)|||
					Buffer3(<>)
					)
						[|{|ctrl_ref1::imageTaken,ctrl_ref0::imageTaken,ctrl_ref1::ambientLight,ctrl_ref0::ambientLight,ctrl_ref1::currentModel,ctrl_ref0::currentModel,ctrl_ref0::switchModel,ctrl_ref1::switchModel|}|]
					(
						(
							(
								ctrl_ref0::D__(id__)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::moveCall <- moveCall
								]]
								\ {|
									ctrl_ref0::forceTorque,
									ctrl_ref0::positionOrientation,
									ctrl_ref0::getImage,
									ctrl_ref0::lightLevel
								|}
							)
								[|{|terminate|}|]
							(
								ctrl_ref1::D__(id__,
										    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
										    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
										    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
										    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
										    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL)[[
									ctrl_ref1::terminate <- terminate
								]]
							)
						)
						\
						diff(
							{|terminate|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
				)
				\ Union({
					{|
						ctrl_ref1::imageTaken,
						ctrl_ref0::imageTaken,
						ctrl_ref1::ambientLight,
						ctrl_ref0::ambientLight,
						ctrl_ref1::currentModel,
						ctrl_ref0::currentModel,
						ctrl_ref0::switchModel,
						ctrl_ref1::switchModel
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>)
		
		-- visible state equivalent
		
		VS__(id__,
				    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
				    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
				    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
				    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
				    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
				    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
				    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL) = prioritise(let
			Buffer0(<v>) = 
				ctrl_ref0::imageTaken.out?x -> Buffer0(<x>)
				[]
				ctrl_ref1::imageTaken.in!v -> Buffer0(<>)
			Buffer0(<>) = ctrl_ref0::imageTaken.out?x -> Buffer0(<x>)
			Buffer1(<v>) = 
				ctrl_ref0::ambientLight.out?x -> Buffer1(<x>)
				[]
				ctrl_ref1::ambientLight.in!v -> Buffer1(<>)
			Buffer1(<>) = ctrl_ref0::ambientLight.out?x -> Buffer1(<x>)
			Buffer2(<v>) = 
				ctrl_ref0::currentModel.out?x -> Buffer2(<x>)
				[]
				ctrl_ref1::currentModel.in!v -> Buffer2(<>)
			Buffer2(<>) = ctrl_ref0::currentModel.out?x -> Buffer2(<x>)
			Buffer3(<v>) = 
				ctrl_ref1::switchModel.out?x -> Buffer3(<x>)
				[]
				ctrl_ref0::switchModel.in!v -> Buffer3(<>)
			Buffer3(<>) = ctrl_ref1::switchModel.out?x -> Buffer3(<x>)
			
		within
			(
				(
					(Buffer0(<>)|||
					Buffer1(<>)|||
					Buffer2(<>)|||
					Buffer3(<>)
					)
						[|{|ctrl_ref1::imageTaken,ctrl_ref0::imageTaken,ctrl_ref1::ambientLight,ctrl_ref0::ambientLight,ctrl_ref1::currentModel,ctrl_ref0::currentModel,ctrl_ref0::switchModel,ctrl_ref1::switchModel|}|]
					(
						(
							(
								ctrl_ref0::VS__(id__)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::moveCall <- moveCall
								]]
								\ {|
									ctrl_ref0::forceTorque,
									ctrl_ref0::positionOrientation,
									ctrl_ref0::getImage,
									ctrl_ref0::lightLevel
								|}
							)
								[|{|terminate|}|]
							(
								ctrl_ref1::VS__(id__,
										    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
										    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
										    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
										    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
										    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL)[[
									ctrl_ref1::terminate <- terminate
								]]
							)
						)
						\
						diff(
							{|terminate|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						Memory(id__)
					)
				)
				\ Union({
					{|
						ctrl_ref1::imageTaken,
						ctrl_ref0::imageTaken,
						ctrl_ref1::ambientLight,
						ctrl_ref0::ambientLight,
						ctrl_ref1::currentModel,
						ctrl_ref0::currentModel,
						ctrl_ref0::switchModel,
						ctrl_ref1::switchModel
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>)
		
		-- O version (optimised)
		
		O__(id__,
				    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
				    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
				    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
				    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
				    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
				    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
				    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL) = dbisim(prioritise(let
			Buffer0(<v>) = 
				ctrl_ref0::imageTaken.out?x -> Buffer0(<x>)
				[]
				ctrl_ref1::imageTaken.in!v -> Buffer0(<>)
			Buffer0(<>) = ctrl_ref0::imageTaken.out?x -> Buffer0(<x>)
			Buffer1(<v>) = 
				ctrl_ref0::ambientLight.out?x -> Buffer1(<x>)
				[]
				ctrl_ref1::ambientLight.in!v -> Buffer1(<>)
			Buffer1(<>) = ctrl_ref0::ambientLight.out?x -> Buffer1(<x>)
			Buffer2(<v>) = 
				ctrl_ref0::currentModel.out?x -> Buffer2(<x>)
				[]
				ctrl_ref1::currentModel.in!v -> Buffer2(<>)
			Buffer2(<>) = ctrl_ref0::currentModel.out?x -> Buffer2(<x>)
			Buffer3(<v>) = 
				ctrl_ref1::switchModel.out?x -> Buffer3(<x>)
				[]
				ctrl_ref0::switchModel.in!v -> Buffer3(<>)
			Buffer3(<>) = ctrl_ref1::switchModel.out?x -> Buffer3(<x>)
			
		within
			(
				(
					(Buffer0(<>)|||
					Buffer1(<>)|||
					Buffer2(<>)|||
					Buffer3(<>)
					)
						[|{|ctrl_ref1::imageTaken,ctrl_ref0::imageTaken,ctrl_ref1::ambientLight,ctrl_ref0::ambientLight,ctrl_ref1::currentModel,ctrl_ref0::currentModel,ctrl_ref0::switchModel,ctrl_ref1::switchModel|}|]
					(
						(
							(
								ctrl_ref0::O__(id__)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::moveCall <- moveCall
								]]
								\ {|
									ctrl_ref0::forceTorque,
									ctrl_ref0::positionOrientation,
									ctrl_ref0::getImage,
									ctrl_ref0::lightLevel
								|}
							)
								[|{|terminate|}|]
							(
								ctrl_ref1::O__(id__,
										    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
										    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
										    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
										    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
										    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL)[[
									ctrl_ref1::terminate <- terminate
								]]
							)
						)
						\
						diff(
							{|terminate|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
				)
				\ Union({
					{|
						ctrl_ref1::imageTaken,
						ctrl_ref0::imageTaken,
						ctrl_ref1::ambientLight,
						ctrl_ref0::ambientLight,
						ctrl_ref1::currentModel,
						ctrl_ref0::currentModel,
						ctrl_ref0::switchModel,
						ctrl_ref1::switchModel
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>))
		
		-- visible state optimised equivalent
		
		VS_O__(id__,
				    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
				    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
				    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
				    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
				    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
				    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
				    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL) = dbisim(prioritise(let
			Buffer0(<v>) = 
				ctrl_ref0::imageTaken.out?x -> Buffer0(<x>)
				[]
				ctrl_ref1::imageTaken.in!v -> Buffer0(<>)
			Buffer0(<>) = ctrl_ref0::imageTaken.out?x -> Buffer0(<x>)
			Buffer1(<v>) = 
				ctrl_ref0::ambientLight.out?x -> Buffer1(<x>)
				[]
				ctrl_ref1::ambientLight.in!v -> Buffer1(<>)
			Buffer1(<>) = ctrl_ref0::ambientLight.out?x -> Buffer1(<x>)
			Buffer2(<v>) = 
				ctrl_ref0::currentModel.out?x -> Buffer2(<x>)
				[]
				ctrl_ref1::currentModel.in!v -> Buffer2(<>)
			Buffer2(<>) = ctrl_ref0::currentModel.out?x -> Buffer2(<x>)
			Buffer3(<v>) = 
				ctrl_ref1::switchModel.out?x -> Buffer3(<x>)
				[]
				ctrl_ref0::switchModel.in!v -> Buffer3(<>)
			Buffer3(<>) = ctrl_ref1::switchModel.out?x -> Buffer3(<x>)
			
		within
			(
				(
					(Buffer0(<>)|||
					Buffer1(<>)|||
					Buffer2(<>)|||
					Buffer3(<>)
					)
						[|{|ctrl_ref1::imageTaken,ctrl_ref0::imageTaken,ctrl_ref1::ambientLight,ctrl_ref0::ambientLight,ctrl_ref1::currentModel,ctrl_ref0::currentModel,ctrl_ref0::switchModel,ctrl_ref1::switchModel|}|]
					(
						(
							(
								ctrl_ref0::VS_O__(id__)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::moveCall <- moveCall
								]]
								\ {|
									ctrl_ref0::forceTorque,
									ctrl_ref0::positionOrientation,
									ctrl_ref0::getImage,
									ctrl_ref0::lightLevel
								|}
							)
								[|{|terminate|}|]
							(
								ctrl_ref1::VS_O__(id__,
										    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
										    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
										    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
										    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
										    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL)[[
									ctrl_ref1::terminate <- terminate
								]]
							)
						)
						\
						diff(
							{|terminate|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
				)
				\ Union({
					{|
						ctrl_ref1::imageTaken,
						ctrl_ref0::imageTaken,
						ctrl_ref1::ambientLight,
						ctrl_ref0::ambientLight,
						ctrl_ref1::currentModel,
						ctrl_ref0::currentModel,
						ctrl_ref0::switchModel,
						ctrl_ref1::switchModel
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		,<visibleMemoryEvents,{tock}>))
		
		-- O version (optimised) with visible assignments
		
		AS_O__(id__,
				    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
				    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
				    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
				    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
				    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
				    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
				    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL) = dbisim(let
			Buffer0(<v>) = 
				ctrl_ref0::imageTaken.out?x -> Buffer0(<x>)
				[]
				ctrl_ref1::imageTaken.in!v -> Buffer0(<>)
			Buffer0(<>) = ctrl_ref0::imageTaken.out?x -> Buffer0(<x>)
			Buffer1(<v>) = 
				ctrl_ref0::ambientLight.out?x -> Buffer1(<x>)
				[]
				ctrl_ref1::ambientLight.in!v -> Buffer1(<>)
			Buffer1(<>) = ctrl_ref0::ambientLight.out?x -> Buffer1(<x>)
			Buffer2(<v>) = 
				ctrl_ref0::currentModel.out?x -> Buffer2(<x>)
				[]
				ctrl_ref1::currentModel.in!v -> Buffer2(<>)
			Buffer2(<>) = ctrl_ref0::currentModel.out?x -> Buffer2(<x>)
			Buffer3(<v>) = 
				ctrl_ref1::switchModel.out?x -> Buffer3(<x>)
				[]
				ctrl_ref0::switchModel.in!v -> Buffer3(<>)
			Buffer3(<>) = ctrl_ref1::switchModel.out?x -> Buffer3(<x>)
			
		within
			(
				(
					(Buffer0(<>)|||
					Buffer1(<>)|||
					Buffer2(<>)|||
					Buffer3(<>)
					)
						[|{|ctrl_ref1::imageTaken,ctrl_ref0::imageTaken,ctrl_ref1::ambientLight,ctrl_ref0::ambientLight,ctrl_ref1::currentModel,ctrl_ref0::currentModel,ctrl_ref0::switchModel,ctrl_ref1::switchModel|}|]
					(
						(
							(
								ctrl_ref0::O__(id__)[[
									ctrl_ref0::terminate <- terminate,
									ctrl_ref0::moveCall <- moveCall
								]]
								\ {|
									ctrl_ref0::forceTorque,
									ctrl_ref0::positionOrientation,
									ctrl_ref0::getImage,
									ctrl_ref0::lightLevel
								|}
							)
								[|{|terminate|}|]
							(
								ctrl_ref1::O__(id__,
										    const_Adaptation_Adaptation_stm_ref1_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Adaptation_stm_ref1_IDEAL_LIGHTING,
										    const_Adaptation_Adaptation_stm_ref1_ANOMALY_TIME_THRESHOLD,
										    const_Adaptation_Adaptation_stm_ref3_CONFIDENCE_THRESHOLD,
										    const_Adaptation_Adaptation_stm_ref2_NUM_MODELS,
										    const_Adaptation_Adaptation_stm_ref2_IDEAL_LIGHTING,
										    const_Adaptation_Adaptation_stm_ref2_FALLBACK_MODEL)[[
									ctrl_ref1::terminate <- terminate
								]]
							)
						)
						\
						diff(
							{|terminate|},
							{|terminate|}
						)
							[|
								union(
									{|
									|},
									{|
									|}
								)
							|]
						dbisim(Memory(id__))
					)
				)
				\ Union({
					{|
						ctrl_ref1::imageTaken,
						ctrl_ref0::imageTaken,
						ctrl_ref1::ambientLight,
						ctrl_ref0::ambientLight,
						ctrl_ref1::currentModel,
						ctrl_ref0::currentModel,
						ctrl_ref0::switchModel,
						ctrl_ref1::switchModel
					|},
					{|
					|},
					{|
					|}
				})
				[|{|terminate|}|>SKIP
			)
			\{|terminate|}
		)
	}
	
endmodule
